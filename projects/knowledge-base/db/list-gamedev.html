<h1>Изучение разработки игр</h1>

<h2>С++</h2>
- Книги
- Видеокурсы
- Закладки
<h2>Математика</h2>
- Исходники шейдеров UE4 (fastmath)
- GLM

- Теория оптимизации
- тригонометрия, 
- теория вероятностей, 
- матан, 
- математика для геймдева
- Кривые Безье
- статистика
- Фурье
- кватернионы
- Линейная алгебра и наналитическая геометрия: http://immersivemath.com/ila/index.html
- Дж. Андерсон - Дискретная математика и комбинаторика
   - А. Диксит - Теория игр
   - В. Жуков - Теория погрешностей
-----------------------
- Теория множеств
- Общая алгебра: мономы, биномы, полиномы, алгебраические структуры (решётки, кольца, структуры, поля, группы)
- Числа: комплексные числа
- Математический анализ: векторный анализ, комплексный анализ
- Тригонометрия
- Линейная алгебра
- Аналитическая геометрия
- Комбинаторика: сложение/умножение, принцип Дирихле, размещения/перестановки/сочетания, бином. коэф., полином. коэф., включения/исключения, выравнивания
- Теория вероятностей
- Статистика
- Дискретная математика: математическая логика, теория графов
- Вариационное исчисление и методы оптимизации: https://portal.edu.asu.ru/course/view.php?id=912
- Топология
- Теория категорий
- Теория игр
- Теория интерполяции
- Дифференциальная геометрия
- Теория групп и теория категорий

- Арифметика
- Теория чисел
- Дроби
- Степени
- Одночлены
- Многочлены
- Уравнения
- Системы уравнений
- Неравенства
- Системы неравенств
- Прогрессии

- Тригонометрия
- Числовые ряды
- Функциональные ряды
- Множества
- Квадратичная форма
- Численные методы
- Ряды Фурье
- Теорема Байеса

- Разделы:
  - Алгебраические структуры (кольца, структуры, поля, группы)
  - Теория погрешностей
  - Теория интерполяции
  - Теория игр
  - Статистика
  - Топология

- Линейная алгебра и аналитическая геометрия:
  - Матрицы
  - Векторы

- Дискретная математика:
  - Математическая логика
  - Теория множеств
  - Отношения
  - Теория типов
  - Теория графов
  - Деревья
  - Теория вероятностей
  - Сжатие/кодирование информации
  - Алгебраические структуры
  - Булева алгебра
  - Теория автоматов
  - Контекстно-свободные языки
  - Теория чисел
  - Комбинаторика
  - Функции
  - Матрицы
  - Сети
  - Поиск информации
<h2>Физика</h2>
- Цвет и свет
<h2>Проектирование ПО, лучшие практики</h2>
- Законы, хаки: hacker-laws.pdf
- UML
- С. Макконнел - Совершенный код
- М. Нейгард - Release It!
<h2>Структуры данных и алгоритмы</h2>
- Коды восстановления данных (яндекс) 
- Р. Стивенс - Алгоритмы. Теория и практическое применение
- Г. Уоррен - Алгоритмические трюки для программистов
- Т. Стюарт - Теория вычислений для программистов (для низко квалифицированных)
- Дж. Вьега - 24 смертных греха компьютерной безопасности
* D. Williamson - The Design of Approximation Algorithms (Продвинутые алгоритмы)
? Продвинутые структуры данных (B-дерево, R-дерево, Линейный хэш)
<h2>Кодирование и шифрование данных</h2>
- Б. Шнайер - Прикладная криптография
<h2>Информатика</h2>
- Computer Systems. A Programmer's Perspective
<h2>Архитектура компьютера и GPU</h2>
- WEPSKAM, 
- WEPSKAFPA (https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)
- Hyper Threading
- Параллелизм на уровне команд
- Параллелизм на уровне процессов
- Параллелизм на уровне потоков
- Параллелизм на уровне задач
- Параллелизм на уровне битов
<h2>Операционные системы</h2>
- Windows Internals
<h2>Язык ассемблера и реверс-инженеринг</h2>

   - К. Касперски - Искусство дизассемблирования                    
   - Д. Юричев - Reverse Engineering для начинающих 
<h2>Геймдизайн</h2>
- A. Thorn - Game Development Principles
- Despain - 100 Principles of Game Design
<h2>Свой язык программирования</h2>
- Crafting interp.
- Деструктуризация
- Декораторы
- Распаковка, деструктуризация
- Циклы по объектам, массивам
- Классы
- Генераторы
- Передавать аргументы по имени как в питоне
- flags как enum
- for, loop, while, do-while
- 0b
- 0x
- 123
- 123.e5
- 123_123_356
<h2>Обработка цифровых сигналов</h2>
<h2>Тестирование</h2>
- TDD, BDD, unit-тестирование, e2e-тестирование, CI
<h2>Навыки CG-художника</h2>
моделирование, текстурирование, анимация, симуляция, моушн, цвет, композиция, шрифты, режессура, монтаж
<h2>Компьютерные сети</h2>
- Э. Таненбаум - Компьютерные сети
<h2>Искусственный интеллект</h2>
- Я. Гудфеллоу - Глубокое обучение
<h2>Игровой движок</h2>
- J. Gregory - Game Engine Architecture
- R. Nystrom - Game Programming Patterns

Сжатие:
- Изображения: astc, lossless (png, webp)
- Видео
- Аудио: mp3, vorbis, flac, ogg, opus
- Анимации
- Карты
- Модели

Вычисление
- SIMD, Cuda, OpenCL, Compute Shader

выравнивание памяти (адреса, структуры)

Порядок разработки:
- types.h
- memory.h
- string.h (fmt, encodings, serialization)
- file_system.h
- math.h
- compression.h
- cryptography.h
- codecs/*.h

AUDIO:
Game Engine Audio Requirements:
- Effects, Filters
- On-Fly Device detection and switch
- Multi-channel support
- Low latency
- Streaming & playback

Audio Backends:
- FMOD uses WASAPI in Windows by default (see FMOD_OUTPUTTYPE, https://cutt.ly/pvkJnHH)
- Wwise looks first for XAudio2, then WASAPI, and finally DirectSound (https://cutt.ly/KvkJrBN)

Audio Backends:
- WASAPI - The Windows Audio Session API, also used on Mac.
- XAudio2 - A Windows-shipped cross-platform audio API from Microsoft, which typically yields low latency.
- DirectSound - DEPRECATED sound backend

WASAPI vs XAudio2:
- XAudio2 faster, more simple, low latency, designed specially for game engines, less code (https://cutt.ly/TvkKfiL)

Sources:
- Beep to Boom


Звуковой движок должен поддерживать много событий, делить звуки на банки, банки должны поддерживать релокации в памяти.



================================================================================================================================

Алгоритмы и структуры данных:
- Встроенные в язык алгоритмы (сортировки) всегда будут быстрее самописных, потому что...
- Копирование/перемещение памяти быстрее перемещения элементов массива, потому что...
- Для криптографии нужно использовать криптостойкие ГПСЧ, потому что...
- Если нужно получить сумму двух брошенных кубиков, то нужно дважды сгенерить числа от 1 до 6, а потом сложить, а не один раз от 1 до 12
- Возведение в степень по шагам (стр. 54)

Физика:
- Hue - преобладающая wavelength цветового спектра (цвета)
- Saturation/chroma/color intensity - насыщенность, у насыщенных цветов все wavelengths сконцентированы около доминирующей wavelength, а у ненасыщенных задействован большой диапазон wavelengths
- Brightness/Lightness/value/brilliance/luminosity - видимая интенсивность света
- Refraction - свет проходит через атомы пыли или дыма, электрон внутри атома начинает вибрировать и перенаправляет свет в другую сторону.
- Маленькие частицы, типа молекул воздуха, рассеивают луч неравномерно (луч распадается на спектр), а крупные частицы, например, воды, отражают луч практически без распада на спектр.

c++:
Unique Pointer:
- Только один UPtr может содержать конкретный raw pointer
- Не поддерживает комирование
- UPtr можно передавать в функции по ссылке или через перемещение std::move


Анимации:
- rigid hierarchical animation - модель является иерархией твёрдых мешей; подходит для анимации роботов
- Per-Vertex Animation - положение каждого вертекса записывается для каждого кадра, требует много памяти; подходит для анимации мягких тел, но редко используется
- morph target animation - то же самое, что PVA, только позиции для вертексов записываются не для каждого кадра, а только для экстремумов, а анимации интерполируются и смешиваются в реал-тайме; подходит для лицевой анимации (всегда!)
- joint rig - ?
- skinned animation - берёт лучшее от PVA и MTA, лучше всего подходит для кожи и тканей
  Используется skeleton, который состоит из костей, как и в RHA.
  Мэш, который натянут на эти кости, называется skin и прикреплён к суставам.
  Вертексы меша двигаются в зависимости от движения суставов.
  Каждый вертекс может зависеть от нескольких суставов.



- Дата публикации, автор, компания, название

================================================================================================================================

- Архитектура CPU

- NVIDIA: DLSS, HairWorks, PhysX...
- Структуры данных, алгоритмы
- Проектирование, лучшие практики, чистый код
- Математика, физика
- Vulkan
- Движок:
  - Общая архитектура (файловая система, менеджмент памяти, сжатие, стриминг, многопоточность)
  - Рендеринг
  - Физика
  - Звук
  - Анимации
  - Управление
  - ИИ
  - Разработка языка программирования
- Закладки, книги, статьи, готовые софтины




================================================================================================================================


---------------------------------------------
---------------------------------------------

Слои:
- Слой 3rd Party софта
  - Vulkan/DirectX/OpenGL
  - Havok/PhysX
  - Euphoria
  - FMOD/Wwise
- Слой Platform Independency Layer - обёртка вокруг необходимых частей ОС, которая предоставляет верхнм слоям унифицированный API
  - Platform Detection
  - Primitive Data Types
  - Collections and Iterators
  - File System
  - Networking
  - High-Res Timer
  - Обёртка над графическим API
  - Обёртка над API физики
  - Обёртка над API анимации
  - Обёртка над API звука
- Слой ядра
  - Module Startup/Shutdown
  - Assertion
  - Unit Testing
  - Memory Allocation
  - Math Library
  - Strings and Hashed String Ids
  - Debug Logging
  - l10n/i18n
  - Movie Player
  - Parsers
  - Profiling
  - Engine Config
  - Random Number Generator
  - Curves & Surfaces Library
  - RTTI/Reflection & Serialization
  - Object Handles/Unique Ids
  - Async File I/O
- Resource Manager + Resources (Assets)
  - 3D Models
  - Textures
  - Materials
  - Sounds
  - Collision Models
  - Physics Models
  - Skeletons
  - Fonts
  - World Maps
- Low-Level Renderer - на этом уровне инициализируется рендер (GDI), а на вход он принимает много примитивов и рендерит их как можно быстрее.
  Он содержит абстракцию над вьюпортом с камерой и метрицами, приимает на вход список примитивов их материалами, шейдерами и n кол-вом источников света.
  Этот слой рендерит все входящие примитивы без учёта их видимости в сцене, поэтому отсеивать примитивы по видимости должен верхний слой, присылающий сюда примитивы.
  - Materials & Shaders
  - Static & Dynamic Lighting
  - Cameras
  - Text & Fonts
  - Primitive Submission
  - Viewports and Virtual Screens
  - Texture & Surface Management
  - Debug Drawing
- Scene Graph/Culling Optimization - более высокий уровень рендера, !здесь происходит отсеивание геометрии для рендера!, которая будет отправлена для рендера на уровень Low-Level Renderer.
  Для простых миров можно отсеивать все объекты, которые не видит камера (Frustum Cull), а для более сложных нужно использовать продвинутые техники для выявления множества потенциально-видимых
  примитивов (PVS), для этого используется spatial subdivision структуры данных: binary space partitioning tree (BSP), quadtree, octree, kd-tree, sphere hierarchy.
  На этом уровне также можно применять порталы и occlusion culling.
  - Spatial Hash (BSP, kd-Tree, ...)
  - Occlusion & PVS
  - LOD System
- Visual Effects - так же как и уровень Scene Graph, этот уровень посылает данные для рендера в Low-Level Renderer.
  - Particles
  - Decals
  - Light/Environment Mapping
  - Dynamic Shadows
  - Full-Screen Post Effects - может быть как частью low-level рендеринга, так и отдельным компонентом, работающим с выводом low-level рендеринга.
- Front End - 2D-оверлей поверх 3D-сцены
  - Heads-Up Display
  - Full-Motion Video
  - In-Game Cinematics
  - In-Game GUI
  - In-Game Menus
  - Wrappers/Attact Mode
- Profiling & Debugging
  - Recording & Playback
  - Memory & Performance Stats
  - In-Game Menus or Console
- Collision and Physics
  ...
- [Skeletal] Animation - при использовании скелетной анимации, эта система задаёт позу скелету, конвертирует в последовательность матриц и передаёт рендерингу.
  Кроме того, позу скелету может задавать физический движок, который присыдает позиционированный скелет системе анимации, а та конвертирует в последовательность матриц и передаёт рендерингу.
  - Animation State Tree & Layers
  - Inverse Kinematics (IK)
  - Game-Specific Post-Processing
  - LERP and Additive Blending
  - Animation Playback
  - Sub-skeletal Animation
  - Animation Decompression
- Human Interface Device (HID):
  ...
- Audio
  - DSP Effects
  - 3D Audio Model
  - Audio Playback Management
- Online Multiplayer
  ...
- Gameplay

Области:
- UML
- Алгоритмы и структуры данных
- Математика
- C++, STL, лучшие практики C++, шаблоны проектирования C++
- Ассемблер
- Программирование SIMD, AVX
- Проектирование ПО 
- Графика
- Звук
- Физика
- Языки программирования
- Компрессия, кодирование аудио (FLAC)

Математика:
- Лин. алгебра
- Тригонометрия
- Матан

C++:
- if-else, switch-case
- Переменные:
  - Инициализация
  - Все способы инициализации
  - Предстваление в памяти
  - Область видимости:
    - Ключеове слово static
    - inline-функции
  - Хранилища:
    - Автоматическое хранилище (automatic storage duration)
    - Статическое хранилище (static storage duration)
    - Динамическое хранилище (dynamic storage duration)
    - Потоковое хранилище (thread storage duration)
  - Типы
    - Булевый тип
    - Целочисленный тип
      - Со знаком
      - Без знака
      - Прямой, обратный и дополнительный код
    - Тип с плавающей точкой
      - IEEE 754
      - Subnormal Values
      - Units in the Last Place
    - Диапазоны числовых типов
    - Строки
    - Массивы
    - Указатели
      - Сырые
      - Умные
      - Константный казатель
      - Указатель на константу
      - Передача указателей
      - Владение ресурсом и его передача
      - Когда и какие указатели использовать
    - Ссылки:
      - Lvalue
      - Rvalue
      - &
      - &&
      - Семантика перемещения (std::move)
      - std::forward
- Константы:
  - Передача констант в функции
  - Передача переменных как констант
- Пространства имён
- Указатели: сырые, умные, как передавать, когда и какие использовать
- Union
- Структуры: вложенные, битовые поля, выравнивание, их расположение в памяти
- ООП:
  - Классы, объекты, выравниване, и их расположение в памяти
  - Конструкторы: множественные, удалённые, по умолчанию, делегированные
  - Виртуальные функции: обычные, чистые
  - Классы-друзья
  - Абстрактные классы
  - Наследование (обычное, множественное)
  - Полиморфизм
- Интерфейсы в C++
- Static, dynamic и shared библиотеки
- C++ и архитектура Windows
- Семантика перемещения и ссылки: rvalue, lvalue, &&, &, std::move, std::forward
- SIMD/AVX
- Загрузка из файлов в структуры и валидация
- Лямбды
- RTTI, RAII, SOLID
- template
- Выравнивание в памяти
- Aggregates and PODs (https://stackoverflow.com/q/4178175/3738245)
- Где хранятся объекты, созданные разными способами
- __attribute__ и __declspec
- __asm
- Обработка исключений, noexcept
- Строки, строковые литералы
- Битовые поля в структурах
- TDD/BDD
- Тестирование
- Float/Double Byte Swap
- Потоки: буферизованные и нет
- Все препроцессорные директивы
- Что класть в .h-файлы
- Вещественные числа, особенно Subnormal Values и Units in the Last Place 
- Битовые хаки с целыми и вещественными числами:
  - https://graphics.stanford.edu/~seander/bithacks.html
  - Game Programming Gems, p.167
- Константность
-------------------
- Параллелизм
- Лучшие практики
- STL
-------------------
- What Every Programmer Should Know About Memory
- Effective C++
- Effective STL
- Large-Scale C++ Software Design
- S. Maguire - Writing Solid Code.pdf
- M. Gregoire - Professional C++ (4ed, 2018).pdf
-------------------
- https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/
- https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines


Заметки:
- Чтобы скелет с анимацией можно было использовать для разных моделей, и скелет, и анимацию нужно экспортировать в отдельные файлы.
- Все ресурсы можно объединять в банки по типу.
- Стоит разработать интерпретируемый язык с поддержкой горячей замены, чтобы быстрее шла разработка.

Модули:
- Общее:
  - Свой GLFW
  - Свой GLEW
  - Библиотека математики
  - Свой кросс-компилятор шейдеров
  - Логирование
- Редатор:
  - Редактор мира (в нём можно рисовать текстурами, как в редакторе FC5)
  - Редактор аудио (типа FMOD Designer)
  - Редактор исходного кода
  - Редактор шейдеров
  - Редактор скриптового кода
  - База данных ассетов
  - Компилятор ресурсов
  - Профайлер, дебаггер
  - Инструмент для оптимизации мэшей и создания LODов
  - Набор плагинов для экспорта из редакторов
  - Редактор локализации, субтитров
- Рантайм:
  - Рендер, шрифты, Vulkan/OpenGL/DirectX
  - Физика
  - Анимация
  - Звук
  - Управление, контроллеры
  - i18n, текст, субтитры, авто-липсинк
  - Искусственный интеллект
  - Система сохранений
  - Собственный язык скриптинга

Движки:
- Unreal Engine
- Unity
- CryEngine
- Source Engine
- Decima Engine
- Torque3D
- OGRE
--------------------
- Bullet
- Havok
- Euphoria
- Open Dynamics Engine
- Newton Dynamics
- Chaos (UE)
--------------------
- FMOD
- Wwise
- XAudio
- Miles Sound System

Что узнать:
- Как всё устроено в памяти.
- Как структуры, классы, файлы выравниваются в памяти и как это связано с архитектурой платформы (пагинация, сегметация).
- Все способы инициализации переменных разного типа и в разных участках памяти.
- Приведение типов.

C++:
- Инкапсуляция - сокрытие данных.
  Наследование - наследование классов.
  Полиморфизм - разнородные классы имет одинаковый интерфейс.
  Композиция - объект А содержит объект Б, при этом объект Б создаётся/уничтожается, когда создаётся/уничтожается объект А. То есть А владеет (own) Б.
  Агрегация - объект А содержит имеет ссылку на объект Б, но не владеет им монопольно.
- Использовать множественное наследование только от нескольких классов, у которых нет родительских классов (такие простые классы называются mix-in'ами).
- Singleton - какой-то класс имеет только один экземпляр и глобальный указатель на него.
  Iterator - класс, который может итерировать по своим свойствам.
  Abstract factory - позволяет создавать объекты разных классов.
  RAII - конструктор класса захватывает ресурс (указатель на файл, поток, блок памяти или мьютекс), а деструктор освобождает ресурс.
  Janitor-классы и аллокаторы памяти - [GEA, p.112]
- Держать *.h файлы чистыми и хорошо прокомментированными
- Ошибки:
  - Если какой-то ассет не удалось загрузить, то выдавать ошибку в консоли, а сам ассет отображать красной моделью ошибки в редакторе мира.
  - Каждая функция должна возвращать enum-значение успешности операции SUCCESS/FAILURE, а сам результат клась в out-параметр.
    Вызывающая функция должна проверить этот код и решить, что делать дальше. Если она решит закончить свою работу из-за ошибки, то должна вернуть ошибку наверх.
  - Если какая-то библиотека или функция использует исключения, то их вызовы должны ть обёрнуты в try-catch.
    Использование исключений может снизить эффективность I-кэша, а также может привести к тому, что компилятор не заинлайнит функцию из-за раздувшегося кода.
    ! Лучше вообще не использовать исключения, потому что они снижают производительность, эффективность некоторых средств языка, и становится сложнее написать надёжный софт. 
  - Использовать свои ассерты для разных сборок. Можно использовать быстрый ASSERT для всех сборок и SLOW_ASSERT только для dev-соборок. [GEA, p.126]
    Не использовать ассерты для user-input данных. 
    Использовать ассерты с брейкпоинтом для фатальных ошибок, и ассерты с выводом ошибки в конслоль для нефатальных.
    Использовать static_assert (С++11) для выявления ошибок compile-time.
- Числа. 
  - ? Использовать Subnormal Values [GEA, p.135]. 
  - ? Сравнение чисел с плавающей точкой [GEA, p.136]
  - ? floating-point трюки [Game Programming Gems, p.167]
  - ? Трюки с битами [https://graphics.stanford.edu/~seander/bithacks.html]
  - В играх часто используется float, а не double, поскольку в SIMD-регистры помещается в 2 раза больше float, чем double.
  - Число: 0x00123456
    Адрес памяти:  0    1    2    3
    Little-Endian: 0x56 0x34 0x12 0x00
    Big-Endian:    0x00 0x12 0x34 0x56
  - ? Type Punning [http://www.cocoawithlove.com/2008/04/using-pointers-to-recast-in-c-is-bad.html]
Компиляция:
  - Declaration - просто сигнатура сущности, которая испаряется после компиляции
  - Definition - сама сущность (переменная, класс, функция), которая занимает место в памяти
  - В .h класть:
    - Сигнатуры функций
    - inline-функции
    - Шаблонные функции и классы, поскольку у template-сущностей не различается Declaration и Definition
  - Структуруры и классы могут инстанцироваться не только в куче, но и в стеке.
static:
  - При использование в скоупе файла означает внутреннее свзывание в рамках .cpp
  - При использование в скоупе функции означает, что эта переменная глобальна, но видна только в этой функции. (хранится в BSS)
  - При использование в скоупе структуры или класса означает, что свойство является членом не инстансов, а класса.
Структуры в памяти:
  Члены структур упаковываются не плотно, а с выравниванием. Компилятор можно попросить не добавлять выравнивание с помощью #pragma pack. 
  Выравнивание выполняется так, чтобы каждый адрес каждого элемента структуры в памяти был кратен размеру этого элемента. [GEA, p.159]
  Кроме того, выравнивание гарантирует и выровненность структур в массиве.
  Можно явно добавлять байты выравнивания.
  ! Важно помнить о выравнивании при объявлении структуры, чтобы отсортировать элементы структуры в оптимальном порядке.
Классы в памяти:
  Когда какой-то класс унаследован от другого, то в памяти все классы идут один за другим в порядке наследования, а каждый класс выравнен.
  Если класс содержит виртуальную функцию, то в самое начало класса добавляется 32/64-битный указатель на структуру-таблицу виртуальных функций.
  Эта vtable хранит список указателей на все унаследованные и собственные виртуальные функции.
Кэш памяти
  Нужно писать код и выбирать структуры данных, чтобы по максимуму использовать кэши процессора. [GEA, p.197]
----------------------------------------
- Никогда не класть using <namespace> в .h-файлы
- [C++17] Использовать std::byte для несимвольных переменных
- [C++17] if (<initializer> ; <conditional_expression>) { <body> }
- [C++17] switch [[fallthrough]]
- [C++17] switch (<initializer> ; <expression>) { <body> }
- [C++17] Использовать std::size(), чтобы узнать размер обычного массива.
- Использовать std::array и std::vector вместо обычного массива.
- [C++17] Structured Bindings: auto [x, y, z] = values, где values - это std::array, struct, std::pair, std::tuple
- [C++17] Range-Based for: for (int i : arr) { ... } // копирует. for (int &i : arr) { ... } // берёт по ссылке.
- #include <initializer_list>
  int makeSum(initializer_list<int> lst); - функция с переменным кол-вом элементов.
  makeSum({10,20,30,40,50,60});
- Чтобы функция могла принимать по ссылке не только переменную, но и литерал, эту ссылку нужно объявить как const.
- Если функция должна модифицировать параметр, то передавать по обычной ссылке, а если нет, то по const-ссылке.
- auto всегда вырезает const и & из типа, поэтому эти квалификаторы нужно добавлять явно: const auto&...
- decltype работает, как auto, но не вырезает const и &. Лучше всего работает с template.
- В классах все методы, не изменяющие состояния объекта (inspectors), лучше обозначать как const, в отличие от модифицирующих (mutators).
- Инициализация объектов:
  - Если нужно инициализировать объект аргументами конструктора без их изменения, то лучше использовать constructor initializer.
  - Если нужно инициализировать объект аргументами конструктора предварительно изменив их, то можно использовать тело конструктора.
  - Значения по умолчанию для членов объекта можно указывать напрямую при обявлении этого члена.
- Инициализация:
  - До C++11 и после
  - В куче и в стеке
  - Разные типы, в том числе template
  - Не допускает сужения
  - Direct List Initialization vs Copy List Initialization (PCPP, p.89)
  CircleStruct myCircle1 = {10, 10, 2.5};  // инициализация stack-структуры до C++11
  CircleClass myCircle2(10, 10, 2.5);      // инициализация stack-класса до C++11
  CircleStruct myCircle3 = {10, 10, 2.5};  // инициализация stack-структуры с C++11
  CircleClass myCircle4 = {10, 10, 2.5};   // инициализация stack-класса с C++11
  CircleStruct myCircle3{10, 10, 2.5};     // инициализация stack-структуры с C++11 (можно опустить знак =)
  CircleClass myCircle4{10, 10, 2.5};      // инициализация stack-класса с C++11 (можно опустить знак =)
  int x[]{1, 2, 3};
  int* pArray = new int[3]{1, 2, 3};
- Строки:
  char* ptr = "hello"; ptr[1] = 'a';        // это неправильно, т.к. "hello" - это const-литерал, его нельзя модифицировать, но компилятор может разрешить
  const char* ptr = "hello"; ptr[1] = 'a';  // тоже неправильно, но компилятор выдаст ошибку
  char arr[] = "hello"; arr[1] = 'a';       // правильно, т.к. в этом случае компилятор не будет трактовать "hello" как const-литерал, а значит можно модифицировать
  Raw-string литерал R"(...)" возволяет использовать перенос строк
  std::string.c_str() - указатель на сырую C-строку, который станет не валидным после изменения строки, потому что строка может быть перемещщена в памяти.
  std::string.data() - до C++17 идентичен c_str, но начиная с C++17 возвращает не константный указатель.
  - Литералы:
    "..." - литерал C-строки
    "..."s - литерал std::string-строки (std::string_literals)
    "..."sv - литерал string_view
  - Метод to_string из стандартной библиотеки переводит числовые значения в std::string.
    Методы stoi/stol/stoul/stoll/stoull/stof/stod/stold переводят std::string в числовую переменную.
    НО! [C++17] Для высокой производительности и независимости от локали нужно использовать функции из хежера charconv.
  - [C++17] std::string_view - унифицированный способ принимать C-строки и std::string как аргумент, всегда принимают по значению, потому что очень дёшево копируются.
    ! Всегда использовать std::string_view для const std::string& и const char*.
  - Комментарии:
    Комментировать только то, что не может объяснить код.
    Если функция возвращает примитивный тип, то лучше дать ему псевдоним (typedef/using), который объяснит, что именно возвращает функция.
- ! Принимать по ссылке, а не по указателю. [PCPP, p.130]
- Проектирование:
  - Всегда проектировать с UML.
  - Самые важные принципы проектирования на C++:
    - Абстрагирование - взаимодействие с объектом должно происходить через интерфейс, а реализация не должна вылезать наружу.
    - Повторное использование - .

-------------------------------------

- mutable - позволяет изменять члены класса, объявленные с этим ключевым словом, когда изменение происходит в методе с квалификатором const (например, в геттерах).
  Второй случай: по умолчанию лямбды не позволяют модифицировать переменные, захваченные по значению, но если сделать лямбду mutable, то можно.
- volatile - возволяет отменить оптимизацию переменной, чтобы код гарантированно вошёл в конечную программу. (https://habr.com/ru/company/abbyy/blog/161607/)
- static:
  - ? Для констант, объявленных вне всех блоков кода, переключает связывание с внутреннего на внешее.
  - Для переменных, объявленных вне всех блоков кода, переключает связывание с внешнего на внутреннее.
  - Для переменных, объявленных в блоке кода, позволяет этим переменным сохранять своё состояние между всеми выполнениями этого блока.
  - При использовании с членами класса означает, что этот член относится не к экземпляру класса (obj->member), а к самому классу (Cls::staticMember)
  - Все переменные, объявленные с этим ключевым словом, хранятся в статическом хранилище вместе с глобальными переменными.
  - Все inline-функции неявно имеют ключевое слово static для переключения связывания с внешнего на внутреннее, чтобы каждый .cpp-файл получал свой экземпляр такой функции.
- extern:
  - При использовании с глобальными переменными означает, что эта переменная определена в другом файле, при этом в том файле она должна иметь значение и не иметь extern, а текущем файле - наоборот.
  - При использовании с const, меняет внутреннее связывание на внешнее.
  - extern "C" { ... } означает, что сущности внутри этого блока имеют внешнее связывание с правилами вызова языка C.
- decltype - выводит тип переменной, почти как template, или почти как auto, только не отбрасывает const и &.
- constexpr:
  - При использовании перед именем функции и при условии, что аргументы функции будут известны на этапе компиляции, функция будет вычислена на этапе компиляции.
  - При использовании перед имененм переменной, и при условии, что выражение справа от знака = является constexpr, будет создана константа.
- explicit - при использовании с функцией/конструктором запрещает неявное приведение типов параметров.
- override - ключевое слово, которое используется после списка аргументов метода производного класса, чтобы явно указать, что этот метод перегружает одноимённый метод базового класса.
- final - запрещает перегрузку метода данного класса методом из его производного класса.
  При использовании с целым классом запрещает наследование класса.
- noexcept  

-------------------------------------

ООП:

- Конструкторы могут писать в const
- Конструктор по умолчанию не имеет аргументов
- Если класс не имеет ни одного конструктора, то компилятор создаст конструктор по умолчанию (т.е. без аргументов)
- Квалификатор default указывает компилятору автоматически создать определение (definition) конструктора (Example() = default;)
- Квалификатор delete указывает компилятору удалить конструктор с определённым типом аргументов (Example(int) = delete;)
- [BP] Всегда задавать значение по умолчанию для свойств класса.
- Инициализатор конструктора может инициализировать const-свойства, &-свойства.
- Один конструктор может делегировать свой вызов другому конструктору, вызвав его из инициализатора.
- Конструктор копирования (T (const T&)):
  - Если не создавать конструктор копирования, то компилятор создаст его сам, этот конструктор будет выполнять побитовую копию.
  - Конструктор копирования вызывается в следующих случаях:
    - Employee emp2(emp1);
    - Employee emp3 = emp2;
    - void foo(Employee emp);
- Структуры можно объявлять внутри классов.
- 

--------------------------------------

КОДИРОВАНИЕ, КОМПРЕССИЯ, ШИФРОВАНИЕ

- LZMA - основан на LZ77 + AC (range)
  https://github.com/sisong/lzma
- Fast-LZMA2
  https://github.com/conor42/fast-lzma2
  https://overclockers.ru/softnews/show/48318/7-Zip_9.28_Alpha_novyj_format_szhatiya_LZMA2_po_umolchaniju_i_chem_nam_eto_grozit
- LZNA:
  - Oodle Leviathan
  - Oodle Kraken 
  - Oodle Mermaid
  - Oodle Selkie
  http://www.radgametools.com/oodlecompressors.htm
- LZO
  https://github.com/nemequ/lzo
- LZ4 - LZ77 без окна и энтропийного сжатия, LZ4Frame быстрее распаковывает, Lizard быстрее распаковывает
  https://github.com/lz4/lz4
- LZHAM
  https://github.com/richgel999/lzham_codec
- LZFSE
  https://github.com/lzfse/lzfse
- LZTurbo - основан на LZ77
  https://sites.google.com/site/powturbo/home
- Lizard
  https://github.com/inikep/lizard
- FSE (tANS)
  https://github.com/Cyan4973/FiniteStateEntropy (tANS)
  https://github.com/rygorous/ryg_rans (rANS + SIMD)
- ZLIB - Deflate: LZ77 + Хаффман
  https://github.com/madler/zlib
- ZStd - + ANS (FSE?)
  https://github.com/facebook/zstd
- Brotli (RFC 7932) - LZ77 + Хаффман + моделирование 2-ого порядка 
  https://github.com/google/brotli
- FastLZ - быстро упаковывает/распаковывает LZ77, но ниже коэф. сжатия
  https://github.com/ariya/FastLZ
---------------------------------------
- Huff0 - быстрый кодек Хаффмана


Методы энтропийного кодирования - код назначается каждому символу исходного сообщения *:
- Префиксные:
  - Шеннон-Фано
  - Хаффман
- Арифметический (AE, Arithmetic Encodings)
- ANS/ABS (Asymmetric Numeral/Binary Systems) (компромисс между Хаффманом и арифметическим методом):
  - rANS
  - tANS
    - FSE (Finite State Entropy) - оптимизированная реализация tANS.
  - qABS
  - rABS
  - tABS
  - uABS
Методы словарного кодирования - код назначается словам, на которые предварительно разбивается исходное сообщение *:
- 
Методы кодирования сортировкой блоков - делят сообщения на блоки, сортируют символы так, чтобы было много повторов, сжимают каким-то другим алгоритмом. Средняя скорость и сжатие:
- BWT/BS 
Методы статистического моделирования - сильно сжимают, очень медленные:
- PPM, DMC, ACB, ...

* Методы словарного кодирования используются не сами по себе, а как этап предварительной обработки перед энтропийным кодированием

Заметки:
- ??? статистическое сжатие
- модели, текстуры (GST, WebP), анимации, сохранения, текст, аудио (opus, flac), видео (WebM, av1, H265(HEVC))
- ! делить файл на блоки, сжимать словарём + адаптивное энтропийное сжатие, размер блока зависит от сброса таблицы энтропийного кодека

Перед разработкой своего алго:
- What Every Programmer Should Know About Memory
- Virtual Memory in x86
- x86 Memory
- Everyday Efficiency in Modern C++: https://www.youtube.com/watch?v=LFv7XwgsdLY
- Работа с памятью C++: https://www.youtube.com/watch?v=TajLTcjBgIg
- Модель памяти C++: https://www.youtube.com/watch?v=SIZmLPtcZiE
- Память в C++: https://www.youtube.com/watch?v=vVA46EvbL4E
- Lock-Free: https://preshing.com/20120612/an-introduction-to-lock-free-programming/
- Acq-Release Semantics: https://preshing.com/20120913/acquire-and-release-semantics/
- Программа в памяти: https://habr.com/ru/post/265509/
- С++ Concurrency in Action
- Изучить лучшие практики по работе с файлами и буферами
- Научиться эффективно работать с памятью
- Алгоритмы и структуры данных (?)
- Дочитать Understanding Compression
- Написать алгоритм быстрого поиска префикса
- Попытаться сделать Хаффмена адаптивным и быстрым (https://en.wikipedia.org/wiki/Adaptive_Huffman_coding)
- Изучить:
  - Исх. код: LZ4, Lizard, FastZL, Fast-LZMA2, LZHAM, LZMA, LZO, ZStd, FSE
  - Отреверсить LZTurbo, Oodle
- Искать в других алгоритмах:
  - На что влияет степень сжатия
  - Использование SIMD/AVX/OpenCL
  - Поиск префикса
  - Адаптивность, блочность frame'овость
  - Реализацию LZ77 и других словарных кодеков
  - Реализацию Хаффмана
  - Реализацию ANS
  - В каком направлении идёт сжатие и распаковка

Требования:
- Статический и адаптивный алгоритмы
- Разные суб-алгоритмы в зависимости от условий (энтропии, размеров блоков, словарей, буферов и тд.)
- Память должна выделяться аренами, а переменные должны выравниваться
- Использовать параллелизм
- Использовать Overlapped IO
- Использовать SSE, AVX, OpenCL, ComputeShader
- Быстрая упаковка и распаковка при небольшом использовании CPU и RAM
- Попробовать упаковывать/распаковывать данные in-place
- Возможно, использовать блоки и frame'ы
- На разных процессорах должно работать одинаково

Бенчмарки:
- https://quixdb.github.io/squash-benchmark/#results-table
- https://catchchallenger.first-world.info/wiki/Quick_Benchmark:_Gzip_vs_Bzip2_vs_LZMA_vs_XZ_vs_LZ4_vs_LZO
- http://cbloomrants.blogspot.com/2018/03/oodle-260-some-more-perf-comparisons.html
- https://sites.google.com/site/powturbo/home/benchmark

Источники:
- https://osandamalith.com/2019/08/26/converting-an-exe-to-a-dll/
- https://stackoverflow.com/questions/28635496/difference-lz77-vs-lz4-vs-lz4hc-compression-algorithms
- https://sites.google.com/site/powturbo/home/benchmark
- https://habr.com/ru/company/playrix/blog/324116/
- https://encode.su/threads/2206-new-compressor-LZNA-quot-LZ-nibbled-ANS-quot-quot-Oodle-1-45-quot
- http://cbloomrants.blogspot.com/2015/05/05-09-15-oodle-lzna.html
- https://dropbox.tech/infrastructure/lepton-image-compression-saving-22-losslessly-from-images-at-15mbs
- Быстрый поиск подстрок: 
  - Towards optimal packed string matching
  - http://www-igm.univ-mlv.fr/~lecroq/string/index.html
  - https://en.wikipedia.org/wiki/String-searching_algorithm


--------------------------------------

Теория информации | Программирование https://www.youtube.com/watch?v=crugHYdiJUk&list=PLxGo9dxQkqWA3LPdLogAWG1-NKzEcpZZL
Введение в теорию информации https://www.youtube.com/watch?v=jrT5WquxjqA&list=PL-_cKNuVAYAXgOwEkj9k8Q6sdPFNTtxrq

P = m/n 
- полная группа
- равновероятны
- несовместны

! Не путать вероятность события внутри одного эксперимента с частотой события в некольких процессах.

P(B|A) - вероятность B при условии, что A уже произошло (зависимые события)

Произведение вероятносей независимых событий (отбор людей по красоте и богатству) отличается от произведения вероятностей зависимых событий (?)

"и" - это умножение вероятностей
"или" - это сложение вероятностей

http://rosettacode.org/wiki/Entropy
энтропия может означать минимальное кол-во бит для представления одного значения (LOG2) или множества значений (H(s))

ниже энтропия => выше сжимаемость

- When P(A) == P(B), both symbols are equally likely, and entropy is at its maximum value of LOG2(# symbols); thus, not very compressible.
- The more probable one symbol is, the lower the entropy value, and thus, the more compressible the data set.

--------------------------------------
================================================================================================================================
Игра с плохим дизайном наоборот очень быстро скатывается к
одной выигрышной тактике, которой начинает придерживаться игрок, пока она ему
не надоест.

Я стараюсь выбирать правильные структуры данных и алгоритмы (именно в такой
очередности) и в дальнейшем от них отталкиваюсь.

Если нужно совершить несколько преобразований объекта, то сначала нужно сделать scale, затем rotate, и в конце translate.

---------------------------------------

Религия
Математика
Физика
История
Литература
Геймдизайн
Писательство

------------------------------

МЕТРОИДВАНИЯ + ГОЛОВОЛОМКИ

------------------------------

Производительность пайплайна (цепи, конвейера) определяется производительностью его самого слабого звена.
То есть если самое медленное звено выполняет свою работу за 30 секунд, то этот пайплайн можен выдавать 
новый результат не чаще, чем каждые 30 екунд.
При этом свободное звено, которое проставивает без работы из-а медлительности предыдущих звеньев, называется голодающим.

Пайплайн рендеринга состоит из слещующих этапов [RTR, 8]:
1. Application - это этап самого приложения, написанного с использованием графического API. 
   На этом этапе задачи выполняются на CPU с использованием нескольких потоков.
   Например, рассчёт столкновений, симуляция физики, анимация, обработка инпута и тд.
2. Geometry processing - этап, который отвечает за трансформации, проекции и прочие геометрические обработки.
   На этом этапе определяется что, где и как должно быть нарисовано. Используется GPU.
   Этот этап делится на под-этапы:   
   1. Vertex Shading: выполняет рассчёт положения вершины в пространстве, а также дополнительных данных о ней,
      вроде нормалей, цветов, коодинат текстур. Затем эти данные отправляются в растеризатор и пиксельный шейдер.
      В старые времена этот этап рассчитывал цвет каждой вершины, поэтому так называется. 
      Опциональные этапы обработки вершин:
      - tessellation
      - geometry shading
      - stream output
   2. Projection - выполняется на этапе vertex-шейдера. После выполнения этого преобразования, объекты будут находится в clipping space.
      Vertex-шейдер должен на выходе отдавать вектор с компонентой w, чтобы правильно работал клиппинг.
      Этот этап так называется, потому что координата z вершины переезжает из вектора в z-buffer, а изображение переходит (проецируется) из 3D в 2D.
      Есть два вида проецирования:
      - Orthographic (один из типов parallel-проецирования) - view volume такого проекцирования - это куб, который на этапе клиппинга
        преобразуется в unit-куб.
      - Perspective - view volume такого проекцирования - frustum. На этапе клиппинга frustum тоже преобразуется в unit-куб.
   3. Clipping - урезает область рендера (view volume) до unit-куба (canonical view volume) с координатами (-1 -1 -1) - (1 1 1).
   4. Screen Mapping
3. Rasterization - принимает на вход три вершины одного полигона (треугольника) и определяет пиксели, 
   которые находятся внутри этого треугольника. Используется GPU.
4. Pixel processing - принимает на вход пиксели и определяет всё, что с ними связано: цвет, глубину и тд.
   Ещё этот этап используется для смешивания полупрозрачных цветовых значений одного и того же пикселя.
   Используется GPU.

Часто Application-этап становится бутылочным горлышком при рассчёте физики, коллизий и тд. 
Это потому, что они выполняются на CPU. гораздо лучше их вычислять на GPU, поскольку он намного быстрее 
выполяет параллельные вычисления. Для этого у GPU есть режим compute shader. Этот режим позволяет
использовать GPU в качестве процессора для общих вычислений, а не только для рендера графики.
Если такие рассчёты всё же делают на CPU, то их пытаются распараллелить на несколько ядер/потоков.
Это распараллеливание называется superscalar, что означает возможность запускать несколько процессов 
в одно и то же время на одном и том же этапе.

По умолчанию каждая модель находится в своей model-системе координат. В этой системе координат
эта моделль может быть positioned и oriented. This allows several copies (called instances) of 
the same model to have different locations, orientations, and sizes in the same scene, without 
requiring replication of the basic geometry.

Если к положению каждой модели применить трансформацию, то она будет расположена в world coordinates (world space).
В этой же системе координат расположена камера. В рендере отображаются только те объекты, которые видит камера.
Чтобы выполнить projection и clipping сцены для камеры, координаты всех объектов сцены и самой камеры трансформаруются
во view space. Это делается для того, чтобы расположить камеру в начале координат (0 0 0) и направить её взгляд
по оси -z, y - вверх, x - вправо. Именно потому что во view space камера всегда расположена в начале координат,
эту координатную систему иногда называют camera space или eye space.


Некоторые из этих этапов могут сами из себя представлять пайплайн, а некоторые внутри могут быть распараллелены. 

-------------------------------------------------------
-------------------------------------------------------

НАВЫКИ

- Писательство, сценарии, наратив, сторителлинг
- Психология и социология
- Рисование и Digital Painting
- Цвет, композиция, жесты
- Геймдизайн
- Левел-дизайн
- Моделирование и текстурирование
- Анимация
- Программирвоание (C++, алгоритмы, мастеринг)
- Паттерны проектировани для игр, арх. игрового движка
- Компьютерная графика, Vulkan, DirectX 12
- Математика и ИИ для генерации голоса
- Физика
- Английский язык (и художественный)
  - Free pronunciation podcast
- Русский язык (и художественный)
- Голос
- Музыка, саунд-дизайн и DSP
- Документация Xbox One/PS4


ВДОХНОВЕНИЕ И РЕСУРСЫ ДЛЯ ИЗУЧЕНИЯ

- Читать книги, поэзию
- Смотреть фильмы
- Слушать музыку
- Играть в игры


ИДЕИ, ТЕМЫ И КОНЦЕПЦИИ

- !!! В середине игры, где персонаж теряет близкого, он уходит в депрессию, отчаяние и бессилие.
- !!! В конце сделать цепь твистов, как в Пиле
- !!! Добавить в игру несколько похожих подсказок о том, что будет происходить впереди, сделать их очень незаметными. (игра слов, незаметные надписи)
- Лор должен иметь сильные внутренние связи, то есть если в начале игры говорится о каком-то факте из лора, то спустя какое-то время игрок сталкивается с результатом/послдствием этого факта.
- В игре должны быть предусмотрены самые неожиданные ходы игрока - она должна реагировать на всё, что делает игрок.
- Вместо обычного квиктайма несколько вариантов воспоминаний, которые придадут сил герою или наоборот. Количество положительных воспоминаний зависит от кол-ва положительных поступков.
- Учесть типаж/характер человека с точки зрения психики: кинестетики любят прикасаться, визуалы любят смотреть и тд.
- Ураганные погодные условия (вьюга, гроза (communication Tube); сильный дождь, как в одной из глав Left 4 Dead 2)
- Если в игре будет концепция safe-house, то после того, как игрок привыкнет ей пользоваться, нужно неожиданно создать опасность, когда он в очередной раз будет в safe house и потеряет бдительность.
- Как в The longest journey постоянно упоминать события с такой интонацией, будто игрок уже знает, о чём идёт речь. Он заинтересуется и ему будет интересно распутывать идею.
- Часто вскользь без объяснения упоминать какие-то важные, но уже прошедшие события в мире игры, о кторых знает ГГ, но не знает игрок. А по ходу сюжета постепенно раскрывать детали этих событий. (The Longest Journey)
- Стартануть историю с места: в первые же 20 минут показать острую завязку, к которой возникнет интерес (The Last of Us)
- Можно использовать лютое клише, чтобы отправить зрителя по ложному пути, а потом сделать твист на основе этого клише.
- Если история вертится вокруг глобальных событий (Deus Ex), то у ГГ должна быть своя дополнительная сюжетная линия с его личными проблемами, страхами, кошмарами. 
  Она должна периодически, неожиданно вклиниваться в основной сюжет, раскрывать персонажа.
- В случайные (или нет) моменты игра должна озвучивать мысли ГГ, краткие, лаконичные и что-то говорящие о нём, о событиях или о месте, где он находится.
- По ходу игры персонаж должен сильно трансформироваться: сначала он толстый, хилый, трусливый, закрытый, неуклюжий, но со временем становится более ловким, храбрым, сильным, уверенным.
  Как вариант: в начале игры Prey ГГ можно было сделать "безруким", неумеющим даже крепко держать гаечный ключ в руках - а когда он его достаёт, о роняет.
  Но со временем, если игрок часто пользуется этим ключом (достаёт-убирает), то ГГ начинает очень ловко и пафосно доставать этот ключ подбрасывая вверх. 
------------------------------------
- Игровая динамика - действия какой сложности и как часто выполняет игрок. В Prey каждый монстр представляет опасность в отличие от L4D, поэтому
  часто лучше прятаться или думать как расправиться с очередным врагом. Возможно стоит сделать игру, где каждый враг представляет опасность.
- Искусство от религии ничем не отличается - тоже вера, тоже страсть, тоже романтизм
  Наука принесла больше разрушений (всему миру), чем религия (только людям)
- Инь/ян, добро/зло, драма/комедия, холод/тепло, лёд/огонь
- ГГ несколько раз приходит на испытание, не справляется с ним. В последний раз справляется, потому что понял какую-то истину (возможно, то, что ему не нужно это испытание)
- У ГГ должен быть друг, с которым они развиваются на протяжении долгого времени.
  Игра несколько раз ненавязчиво показывает какую-то обычную вещицу у этого друга или вещицу, которая их связывает.
  Примерно на 70 проценте игры этот друг погибает. Происходит драматичная/меланхоличная сцена прощания (Evgeny Grinko - Prologue).
  В конце игры ГГ суёт руку в карман и неожиданно обнаруживает эту вещицу у себя. Это напомнит игроку об этом друге под конец игры, 
  покажет, что друг знал о своей скорой кончине и подкинул вещь в карман ГГ, а так же покажет, что ГГ чувствует присутствие друга при себе.
  В конце Brothers A Tale of Two Sons умирает старший из двух братьев, у которого были способки важные для прохождения. А младший не может ими воспользоваться из-за смерти старшего.
  Здесь важны не способки, а то что игрок через [потерянную] механику понимает как важен был старший брат, что это потеря.
- В конце игры ГГ должен умереть, добившись своей цели.
- Карма: 
  Сделал хорошее дело - экран теплеет/вспыхивает или что-то такое.
  Сделал плохое - краснеет.
  В зависимости от кармы мир вокруг игрока превращается в ад или рай.
- Факт: людям нравится испытывать чувство изоляции
- Эзотерика, вещества, чувства, восприятие
- Игрок изучает медитацию для восстановления энергии в энергетическом столбе чакр. 
  Чакры расположены в виде вертикального столба. Чем больше энергии в столбе чакр, тем больше способок открыто.
- Ад и рай - это два альтернативных скина реальности в зависимости от поступков игрока.
- Диалоги, как у Тарантино - персонаж познаётся через обычный разговор.
- На некоторых уровнях должна проявляться травма ГГ и игра должна превращаться в триллер (max payne, batman arkham asylum, когда бетмен отравлен)
- Поклонение технологиям и стадный инстинкт (Apple). Это всё должно быть на виду (мол, общество живёт вот так).
  Но потом игра без лишних слов должна показывать обратную сторону такой жизни: фабрики (Apple), загрязняющие атмосферу, трудящиеся дети, задыхающиеся люди, коррупция, полное отсутствие конфиденциальности.
- Цель человечества - создать новую жизнь - андроидов (ИИ). Эта жизнь:
  - Подчинит себе людей, поскольку она становится частью иерархии живых существ, но она совершеннее всех.
  - Просто будет существовать и господствовать, а люди за счёт своих изобретений уничтожат себя, деградируют обратно в слабо развитых существ за счёт своих же изобретений и комфорта.
- ГГ в окружающем мире видит проявление своих страхов в виде гротеска и метафор (например, аллюзия на секс Пирамидоголового с ного-монстрами в Silent Hill 2)
- Заброшенная сельская местность, космические комплексы с монструозными ржавыми сооружениями, от которых должно перехватывать дыхание и вызывать мысли "Руины былого величия"
- Деревенские механизмы, комбайны, мукомольные заводы, сушилки зерна, похоже на Alan Wake, но СССР
- Локации должны сильно контрастировать, чередоваться, создавать ритм: шумный передовой город -> спокойная уютная деревня...
- В сельской местности должны быть дожди, туман, меланхолия (дождь из batman arkham knight)
- Ночь + снег + свет только около ГГ
- Неожидданное для данного сеттинга/жанра/настроения событие (локация) (например, в GTA 5 появляется страшное место, как в Fallout 3)
- Игрок должен получать награду за все достижения (в GTA SA игрок получает важные возможности, при встрече со всеми 6ю девушками)
- Увлекательные философские монологи, как в Far Cry 3 (Ваас) и Far Cry 4 (в конце игры ужин с Пеганом)
- Подшучивать над штампами (над теми же вылизанными монологами)
- Эффект зловещей долины у некоторых персонажей (https://nplus1.ru/blog/2016/11/07/uncanny-valley-effect)
- Абсурдность "цивилизованного" общества (общество современной Европы "Квадрат", светское общество дореволюционной России "незаконченная пьеса для механического пианино")
- Постепенный переход от бытового повествования к метафоре ("мама!")
- Норатор с таким же настроением, как в Анабиозе
- Поэзия, отсылка к легендам, типа Данко
- Последствия действий должны быть видны на протяжении всей игры, в самые неожиданные моменты
- Задачи на время, как в Fahrenheit: идёт полицейский, нужно прибраться
- Зеркальный мир, как в Shattered Memories
- В новой игре+ дожно быть что-то абсолютно новое: другой вид камеры, новая способка, персонаж с другой полярностью
- Люди идеально отслеживают паттерны (закономерности и шаблоны)
- Один психиатр в начале 20 века начал читать роман Уиллс. Книга показалась ему очень скучной и психиатр был в шаге от того, чтобы назвать автора шизофреником. 
  Но вместо этого решил, что книга не для него и не для его времени. так и вышло: роман стал очень популярен лишь в конце 20 века.
- Одно из мест, в которые попадает игрок - оплот прошлого: интерьер и его наполнение напоминает о старой жизни
- Быстро избавиться от любовной линии 
- Тайное правительство, иллюминаты и противопоставление
- Пассивный и активный комфорт
- Деградация поколений и связь этого с излишком пассивного комфорта
- Революции, и их обратная сторона. Идея о том, что сделать жизнь лучше люди могут только через саморазвитие, всё зависит от народа, а не от власти
- Наркотики, борьба с ними, выгода для корпораций, психоделики и чистые наркотики
- Капитал, бизнес, деньги
- Корпорации, их управление миром, обратная их сторона
- Экология и связь этого с другими сторонами жизни людей
- Персонаж-воплощение духовности, восточных практик, йоги
- Ликбез по религии, что религия дескредитирована, а атеисты воюют не с религией, а с её воплощением
- Общество, идолы современности, следования трендам,
- Люди не готовы жить вместе с технологиями, они недостаточно развиты
- Виды комфорта (пассивный/активный), к чему ведёт каждый из них
- Экономика и прочие виды гуманитарных наук, на которые нельзя полагаться, когда речь идёт о решении утопия или нет
- Инновации и то, что их на самом деле нет
- Йога, медитация
- Человечество пытается освоить космос, хотя не научилось жить даже в идеальной среде - на Земле
- По ходу игры игрок натыкается на заметки, которые одна за другой рассказываю о печальной судьбе людей, пытающихся колонизировать другие планеты. Причина - духовная сторона человека, которую не учли учёные.
- Взлом: дизассемблер, самомод. код, квантовые компьютеры
- Темы: ИИ, аугментация, наука, технологии, религия/духовность, политика, бизнес/экономика/капитализм, социализм, искусство, медицина, война, образование, экология, космос, материализм, философия
- Чем медленнее двигаешься, тем страшнее. Скованные действия, узкие пространства, рваная динами, растяжение времени - баланс в пользу противника.
  Героизм, эпичность, скорость, много слабых целей - баланс в пользу игрока. (Если перебрать - получится унылый гринд).
- Если на карте видно какую-то башню или развалины - это точка интереса, игроку захочется туда прийти.
- Очень хорошо работает маханика стэлса: игрок видит противника, а они его - нет. Хорошо конвертируется в чувства.
- Жадность: когда игрок гребёт в инвентарь всё, даже то, что ему не нужно. На этом можно сделать лавушку.
- В Stardew Valley гринд не скучный, потому что он очень разнообразен, постоянно чередуется и разбавляется различными взаимоотношениями с лором и героями.
- The Graveyard - игра, в которой бабушка ДОЛГО идёт через кладбище, садится на лавочку и ждёт [смерти]. Это происходит настолько медленно и мучительно, что хочется умереть.
- ! Наратив и механики работают вместе.
- В платформерах должна быть большая детализация уровней, много мелких деталей, красочночть (Mighty No. 9 - плохо, Mega Man - хорошо)
- В платформерах не должно быть бесконечных дэшей (стрейфов вперёд) в воздухе
- В платформерах левелдизайн должен быть построен вокруг главных игровых механик 
- Способки должны быть универсальными, то есть одна способка должна давать возможность расправляться с врагом и забираться выше
- В платформерах окружение должно соответствовать темпу игры. Если игра рассчитана на высокий темп прохождения, то, например, неожиданные ваншотящие стены - это плохо, они сбивают темп.
- Из босса должна выпадать способка (ульта?), которая выбирается из кольца способностей с замедлением времени в игре
- Нужно заботиться об интеграции игровых механик в наратив. Например, сохранение игры в Ori выполняется не за счёт пункта меню, а замаскировано под по открытие источника силы.
- Вселенная игры не должна быть фрагментиована, игрок всегда должен понимать, в какой точке это вселенной находится и как он туда попал. 
  В Karma Incarnation 1 и Evil Within игра телепортирует игрока между локациями, что фрагментирует вселенную.
- Silent Hill камера всегда расположена так, что игрок не видит часть окружения, из-за чего он не может быть уверен, что в этой части нет врагов. Это вызывает дополнительное неспокойствие.
- Не забыть про ненавязчивые отсылки и пасхалки. Пасхалка в виде первых аккордов Personal Jesus.
- Если использовать идею рухнувшей цивилизации между раем и адом, то она должна быть похожа на Horizon Zero Dawn
- Идея для игры типа Silent Hill: финальная сцена должна означать "город проглотил/освободил свою жертву и притаился в ожидании следующей" (фильм "мама!").
- В мимике персонажей иногда проблёскивают зловещие черты.
- ! У главного персонажа татуировка, которая говорит о неуверенности, недостатке чего-то или желании наносить себе боль.
- В отсылках и пасхалках не должно быть прямой связи с другим произведением, вместо этого должен быть тонкий намёк, который нужно разгадать.
- Закруглённые космо-локации, навеянные Rameses B - Lunar и концовкой Интерстеллара
- Локации: за облаками (Bioshock Infinite), заброшенная заросшая травой цивилизация (Horizon Zero Dawn), душный дизельпанк (F.I.S.T), меланхоличная, но светлая локация с дождём и солнцем, ночь с космическим небом
- ИДЕЯ: я представлял жизнь в виде кольца, где просветлённый приходит в ту же точку, с которой начинал младенцем, но теперь со всем багажом. Игра начинается и заканчивается одной сценой.
----------------------------
- При написании сценария всегда ставить себя на место игрока
- Вести игрока по ложному сюжетному следу, чтобы отвлечь его внимание от твиста
- Добавлять очень тонкие незаметные подсказки, чтобы усилить эффект от твиста, и чтобы после него игрок кричал "И как я это не заметил?!"
- Нельзя слишком много и упорно пыхтеть над твистом, иначе он получится искусственным
- Удостовериться, что в этот твист можно поверить и что он имеет смысл. Гениальный твист - прост.
- Можно сделать небольшой твист, чтобы потом выкатить более крутой твист.
- Можно тонкой нитью вести маленький подсюжет, от которого игрок не ожидает твиста, а в какой-то момент сделать твист и превратить подсюжет в главный сюжет.
- Сюжет должен дать понять, что никто не в безопасности.
- События которые идут за твистом не менее важны, чем сам твист.



АСПЕКТЫ ИСТОРИИ, СТОРИТЕЛЛИНГА, НАРАТИВА

- Сторителлинг - то, как история рассказана: каким языком и с помощью каким инструментов.
- Если не объединить кинематографичность с наративом, то будет диссонанс.
- Кинематограф передает глубину нарратива визуальным путем, то видеоигры – эмпирическим.
- Многие крупнобюджетные игры построены по принципу чередования сюжета (катсцен) и геймплея.
- Определяющий фактор в игре - интерактивность, а не кинематографичность, поэтому её нужно использовать наполную.
- Одной из причин людо-нарративного диссонанса является отделение геймплея от нарратива (катсцен).
- В играх, в отличие от кинематографа и литературы, игрок наблюдает не со стороны, а является частью событий, действующим лицом.
- Проблема деления игры на геймплей и катсцены в том, что в первом случае игрок сам решает что делать, а во втором - игра решает за него и показывает события как факт.
- Если в кино есть принцип "показывай, а не рассказывай", то в играх - "заставь игрока сделать, а не рассказывай".
  Если игра хочет показать, что ГГ ловок, то она не должна об этом утвержать, она должна заставить игрока почувствовать СЕБЯ ловким.
  Для этого она должна дать игроку самому проявить свою ловкость в виде действия.
- Развитие персонажа должно стать развитием самого игрока – это ключ к иммерсивному сторителлингу в играх.
- Проблема кат-сцен в том, что при переключении из игрового режима, где всё зависит от игрока в режим кино, где от него ничего не зависит, мгновенно убивает все эмоции и чувства, накопленные при прохождении игры.
  В серии Half-Life нет катсцен, игра повествует обо всём прямо в интерактивном режиме.
- Самый лучший игровой сторителлинг – это когда история персонажа полностью идентична истории игрока.
  Важно, чтобы игроку было необходимо использовать смекалку для решения проблемы в игре, а не просто вовремя нажать X - в этом случае он испытает нужные эмоции.
  В конце Portal, когда ГГ/игрок едет в огненную ловушку на платформе, игра заставляет игрока сделать то, что нужно ГГ по сюжету игры - сбежать из этой лавушки.
  В данном случае и ГГ, и игрок испытывают эмоции и чувства одной природы - тревогу. Игрок сражается за "жизнь" и ГГ сражается за жизнь.
  В Tomb Raider во время экшн-сцены когда ты видишь, что на героиню сейчас упадёт огромный валун и убьёт её, всё, что нужно сдеать - вовремя нажать Х. ГГ сражается за жизнь, а игрок просто жмёт кнопку.
  Другими словами, все чувства и эмоции, которые мы по сюжету назначаем ГГ, на самом деле должен испытывать игрок, это должна быть история игрока, а не ГГ, а игра - всего лишь "песочница", в которой играет игрок. 


НАБРОСКИ СЮЖЕТОВ

- ГГ живёт плохой жизнью: он преступник/работник офиса/жирный деградировавший потребитель. 
  Каким-то образом он попадает в ад (мир трансформируется или он умирает). 
  По какой-то причине он встречает наставника в Аду, которой говорит ГГ, что он сам создал себе этот
  ад, это его персональный ад, и если он хочет перейти в рай, то ему нужно пройти целый путь Данте.
  (Рай тоже персональный). По ходу игры ГГ и игрок сталкивается с испытаниями, из которых он выносит уроки
  (о смирении, добре и зле, технологиях, науке, религии, жадности, капитализме, социализме, корпорациях и тд.)
  Во ходу игры он находит себе напарника и друга, с которым долгое время идёт рука об руку, напарник
  даёт ему какие-то способки. Со временем эти способки отодвигаются на второй план, а напарник умирает.
  Остаток игры игрок двигается в одиночку, а когда приходит в рай, то понимает, что этот рай тоже отстой 
  и нужно держать баланс между всеми полярностями. В конце игры напарник напоминает о себе.
  Возможно, где-то в середине игры игрок узнаёт о катастрофе, случившейся на земле из-за человеческой цивилизации.
- Серьёзная игра ближе к Survival Horror'у, типа Silent Hill.
  Страх, тревога, мало человечных существ, много замкнутых, узких пространств, медленное время/геймлей. Мало припасов, сохраняться должен сам игрок вручную. 
  Монстры и события олицетворяют пороки, чувства и события из жизни ГГ.
  За основу взята темя ада и рая.
  Имеет много путей прохождения, как Immersive Sim: можно убивать, стелсить, проходить в лоб или окольными путями. 
  Играет с паматью и психикой ГГ, а сам ГГ трансформируется в зависимости от действий. По действиями подразумевается чтение, убийства, разглядывания инвентаря... как SH: Shattered Memories.
  Есть ближняя боёвка и оружие.
  Игра начинается с ада, но в скоре игрок узнаёт, что это его персональный ад, а он - убийца, преступник, неправильно живущий человек.
  С этого момента игрок может выбирать, убивать кого-то или нет.
  Возможно, стоит добавить отмотку времени для воскрешения.
  Сцена: тёплая сцена воспоминаний семьи - жены и детей. Всё нормально. Но в какой-то момент жена произносит очень странную и жестокую фразу, но с такой интонацией, будто это что-то обычное. 
  Референсы: Silent Hill, Evil Within II, Darkness, Анабиоз.
  Варианты диалогов и решений зависят от того, как играл игрок (убивал, стелсил, помогал).
  Может быть: Silent Hill в постсоветской обстановке (35мм), с примесью мистики (Bioshock, Birdbox)

  Игра почти целиком похожа на Deus Ex - immersive sim с серьёзным глобальным сюжетом, стелсом, стрельбой и тд.
  Но иногда у игрока случаются припадки, которые отправляют его в Silent Hill - хоррор, который раскрывает личную историю персонажа, его травмы и особенности.
  Переход из одной реальности в другую происходит плавно или неожиданно.
  Deus Ex (Immersiмe Sim):
  - Это основной мир игры: недалёкое будущее, близкое к коллапсу
  - Альтернативные проходы: вентиляции, двери, убийства, стелс
  - Глобальный сюжет о власти, технологиях, науке, жадности, комфорте, развлечениях, аугментациях, ИИ.
  - В центре внимания человечества - экологические проблемы: катаклизмы, глобальное потепление, загрязнённый воздух.
    Демонстрация тупости (Идиократия), лживости правительства и корпораций, жадности, скупости и рассчётливости корпораций.
  Silent Hill (Survival Horror):
  - Это второй мир игры, в который игрок несколько раз за игру попадает так же, как Бэтмен попадал к Пугалу в Batman: AA.
    Каждое попадание игрока в этот мир рассказывает часть его личной истории, которая ведёт к травме.
    При последнем попадании в этот мир мозайка складывается, а ГГ/игрок получает возможность исправить проблему.
  - Локации тесные, время идёт медленно, жутко, тоскливо, тревожно
  - Мирных живых существ, в компании которых ГГ/игрок мог бы почувствовать себя в безопасности, практически нет.
    Монстры, населяющие этот мир, символизируют страхи и травмы ГГ.
  Bioshock и Birdbox:
  - Символичные вещи

- Варианты вступления и ГГ:
  - ГГ толстый, неуклюжий, хилый, закрытый, неуклюжий. Работает офисной крысой. В один день его коллегу и лучшего друга забирает полиция (тайная полиция?),
    и ГГ, переступая через себя, начинает расследование: лезет в квартиру друга и пытается что-то найти. В этот момент в квартиру поднимается полиция.
    Тогда ГГ кое-как сваливает из квартиры, пытаясь не попасться полиции. Кога ему это удаётся, от адреналина и ватных ног, он съезжает по стене.
    Это характеризует его как слабого перснонажа в начале игры. Со временем он получает оружие, но по началу он очень плохо умеет им пользоваться, 
    зтем всё лучше и лучше. На одном из уровней попадает в передрягу и лишается части тела, вскоре сталкивается с доктором, который ставит имплант.
  - ГГ оказывается в аду, потому что он живёт бандитской жизню, а этот ад - его персональный ад при жизни. Но этот факт открывается ему не сразу.
    А когда открывается, ГГ хочет персональный рай и несколько раз ломится силой в этот рай, а рай не поддаётся. Наконец, когда ГГ становится достаточно 
    мудрым и у него отпадает желание куда-либо ломиться, рай сам наступает в его жизни. ГГ понимает, что это и был единственный путь в рай - найти 
    гармонию со вселенной и всем сущим.

- Варианты игр:
  - Silent Hill с декорациями в стиле пост-СССР (35мм), с примесью Evil Within II, с холодностью Анабиоза.
  - Преимущественно Deus Ex (Immersiмe Sim) для рассказа глобальной истории, со вставками альтернативного мира в духе Silent Hill для рассказа личной истории ГГ.
  - Метроидвания в стиле Ori 
- Варианты локаций:
  - Провинциальный город России, типа Ярославля с многоэтажками, с заводами в далеке

Проблемы для игры в духе Deus Ex:
- Медицина, депрессия и другие современные болезни
- Тупость и идиотизм, графомания и бессилие из-за пассивного комфорта
- Наука как религия, технологии как топливо пассивного комфорта
- Жадность, бездушность, лживость, рассчётливость, манипулятивность корпораций и капитализма в целом
- Распад социальных связей, хиккавсто
- Природные катаклизмы: глобальное потепление, загрязнение воздуха, 
- Пищевая промышленность
- Будущее трансгуманизма и ИИ. Место андроидов в человеческой иерархии.
  ИИ как причина гибели человечества. ИИ как замена человека.
- Параллели между наукой и религией. Почему атеизм - частный случай религиозного фанатизма.


3D-МЕТРОИДВАНИЯ

Лор: 
- Переплетение природы, науки и техники.
- Portal 2
- Horizon Zero Dawn
- Frostpunk
- Локации с разным настроением: тепло и свежесть, страх и опасность, тьма и свет, электричество, мороз. 
Визуальный стиль: 
- Хроматическая абберация
- Шейдеры и частицы
- Киберпанк, стимпанк, дизельпанк
- Электричество, пафосное техно как в Saints Row IV
- Puppeteer, Last Night, красочность и контрастность Ori; хром. абб., шейдеры, частицы, свечения и взрывы из Wolfenstein II и Beathazard, 
- Эффект застывания во времени, как в Evil Within 2
Звук и музыка: пафосное техно как в Saints Row IV, Perturbator, очень богатый и детальный саунд-дизайн
Игровые механики: постоянные автосохранения, плазмиды из Биошока, игры со временем, головоломки
Юмор: Brutal Legends
Примеры игр:
- F.I.S.T.
- Dead Cells
- Hollow Knight
- Season After Fall
- Katana ZERO
- Unravel
- Ori
- Puppeteer
- Darq
- Unruly Heroes

----------------------------------------------------

ГОЛОВОЛОМКА

Визуальный стиль:
- Darq
- Jenny LeClue

Механики:
- Игры со временем:
  - Какие-то объекты можно помечать, чтобы они вели себя во времени иначе
  - Перемотка времени (Braid)
  - Всё движется, только когда игрок движется (Superhot)
- Параллельная реальность, в которой доступно то, что не доступно в текущей реальности (Silent Hill Origins)
- Смена ориентации в пространстве:
  - (Darq, FEZ)
  - Определённые вещи можно увидеть только с определённого ракурса (Batman ?)
- Игры с физикой:
  - (Besige)
  - Дорисовывать определённые объекты, которые обретают физику (Crayon Physics Deluxe)
- Раскрашенные поверхности ведут себя по-разному (Portal, Nihilumbra)
- Порталы (Portal)
- Клоны и управление ими (The Swapper, Inside)
- Лемминги (Zombie Night Terror, Lemmings)
- Двигать кубы так, чтобы можно было пройти
- Большой механизм, состоящий из разных деталей, который должен быть правильной и точно собран
- Выполнять задачи в правильной последовательности, с учётом таймингов (Как достать соседа)

Разное:
- ВАЖНО: Объёмный звук с эффектом присутствия (как в Ori), реверберацией, спокойной и нежной музыкой (Hammock)  
- Постепенно одни механики должны сменяться другими
- Посмотреть механики I Hate This Game
- Не головоломка, а задачи на ловкость и скорость (успевать одно, пока идёт другое, пока идёт третье)

----------------------------------------------------

ЧЕМУ НАУЧИТЬСЯ

- Рисование и Digital Painting (скетчить по 50 обнажённых натур в день 3 месяца)
- Моделирование
- Текстурирование
- Риггинг
- Анимация
---------------------
- Писательство и сторителлинг
- Звукопись
- Юмор
---------------------
- Голос, актёрство
- Музыка
- Звуковой дизайн
- DSP
---------------------
- Геймдизайн
- Левелдизайн
---------------------
- Программирование C++
- Алгоритмы
- Паттерны программирования игр
- Архитектура игрового движка
- Рендеринг
- Физика
- ИИ для игр
- Нейронные сети для обработки голоса


ИСТОЧНИКИ

- 1984 (секта) + Bioshock 1 (антураж) + Deus Ex (em-sim, обходные пути)
- Memento (персонаж не знает кто он) + Пила (твисты)
- Чувство одиночества SH:SM
- Одержимость из Darkness
- Тоска, одиночество, страх Анабиоз
- Камерность Resident Evil 7
- Музыка, визуал You Are Empty
- Оживающие плакаты как в лого Valve
-----------------------------------------
- Dishonored (дизайн)
- Half-Life 2 (дизайн)
- фильм "Memento"
- фильм "Забавные игры"
- https://www.gamasutra.com/blogs/DamienAllan/20170501/297179/Designing_Video_Game_Puzzles.php
- https://krotovv.livejournal.com/233659.html
- Видеокурс Петухова по психологии
- ! Краткие содержания романов, фильмов и быстрые прохождения игр
- Фильмы Джана Имоу
- Матрица (философия)
- Сэмюэл Л. Джексон (голос проповедника)
- Голос Теодора в русской локализации Evil Within 2
- Saints Row IV и DLC (озвучка)
- Wolfenstein II: The New Colossus (актёрская игра, озвучка)  
  https://youtu.be/4ezuTDZO1qM?t=9s
- Аид из "Геркулеса"
- Ведьмак 3 (Вступление из начала игры, актёрская игра)
  https://youtu.be/__y8Emx62K4
- 73 вопроса Нилу Патрику Харрису (актёрская игра)
  https://youtu.be/5DMCDgdkqzg
- Как я встретил вашу маму (актёрская игра)
- Андрей Бебуришвили (юмор)
- Стивен Колберт (юмор, актинг)
- Prototypes - City Of Gold (вступление) 
- Катсцены из GTA San Andreas (режессура, затягивание)
- Юмор и драма в играх:
  https://kdicast.com/e/155-yumor-i-drama-v-igrah
- Birdman (2014)
  Сцена в гримёрке и с дракой
- God of War
- Пила
- Tales by Light
- Древнегреческая мифология
- Обзоры Зулина (анализ)
- Видео Movie Science (анализ)
- Видео and Action (анализ)
- Видео Anoir'а (анализ)
- Развлекаемся до смерти
- О, дивный новый мир
- Библия
- Книги Карлоса Кастанеды
- Книги Эриха Фромма
- Мир полный демонов
- Произведения Чехова
- Всё лучшее, что не купишь за деньги
- Кино между раем и адом
- Поток
- Игры, в которые играют люди. Люди, которые играют в игры.
- Пиши, сокращай
- Слово живое и мёртвое
- Курсы Эльвиры Барякиной
- Курсы MasterClass.com (писательство, актинг, геймдизайн, юмор)
- Пробуждение жизни
- Книги о восточная философии воинов и параллелях меду боевыми искусствами и медитацией/мудростью (фильм "Воин" Чжана Имоу)
- Философская художественная литература о рае и аде
- Книга о Буддизме
- Божественная комедия
- Краткие содержания худ. произведений и эссе по ним
- Сценарное мастерство от Pixar
- Хиллари-Реттинг - Писать профессионально
- Берн - За пределами игр и сценариев
- Книги Нил Стивенсон
- Уильям Гибсон - Нейромант
- Рэй Брэдбери «451 градус по Фаренгейту»
- Эдгар Аллан По - «Золотой Жук», «Овальный портрет», «Ворон».
- Сергей Лукьяненко «Лабиринт отражений»
- Фрэнк Герберт - Дюна
- Чайна Мьевиль «Вокзал потерянных снов»
- Гарри Гаррисон «К западу от Эдема».
- Нил Гейман «Звёздная пыль».
- «Сами боги», Айзек Азимов
- «Пикник на обочине», Аркадий и Борис Стругацкие
- «Марсианские хроники», Рэй Брэдбери
- «Противостояние», Стивен Кинг
- «Цветы для Элджернона», Дэниел Киз
- «Мы», Евгений Замятин
- «Плоский мир», Терри Пратчетт
- «Пересадочная станция», Клиффорд Саймак
- Neuromancer Trilogy, by William Gibson
- Snow Crash, by Neal Stephenson
- Dune, by Frank Herbert
- 1Q84, by Haruki Murakami
- Girl in Landscape, by Jonathan Lethem
- Shikasta: Re, Colonised Planet 5,  by Doris Lessing
- The Left Hand of Darkness, by Ursula K. Le Guin
-------------------
- http://narratorika.com
- https://gdcuffs.com/
- Закладки
- Курс Барякиной
- Прохождения игр
- Слово живое и мёртвое
--------------------
- Прочитать книги об истории религии, о Буддизме и Библию.
- Искать референсы монстров, окружения и событий.
- Посмотреть, почтитать бытовые психологические триллеры.
- Найти релевантные игры и почитать отзывы на обоих языках. Чем игрокам и критикам эти игры (не) нравятся.
- Научиться анализировать сценарии и музыку.
- Прочитать "Теорию кино".
- Изучить придумывание названий.
- Читать о природе страха.
- Посмотреть все фильмы Тима Бёртона.
- Изучить физиогномику.
--------------------
- Что делает актёрскую игру смешной, харизматичной?
- Что такое экспозиция и как это использовать в игре?
- Почему людям нравится чувство изоляции/тревоги/страха/ужаса?
- Как использовать юмор в драме?
- Почему 3D плохо для платформера?
- Почему у Шьямалана не работают твисты?
- Почему зло интереснее добра? В чём баланс добра и зла (философия)?


ИГРЫ

- ! Анабиоз Сон разума
- Alan Wake
- Silent Hill
- Left 4 Dead (Blood Harvest)
- Darkness
- Metro
- Death Stranding
- Evil Within II (особенно концовка)
- Начало Fran Bow
- Мор Утопия
- Puppeteer
- Manhunt
- Fahrenheit
- Outlast
- Deus Ex
- Layers of Fear
- Bioshock
- Singularity
- Prey
- We Happy Few
- The longest journey
- Observer
- Half-Life 2
- Fallout 3
-------------
- Pandemonium (сайдскроллинг по неплоской локации)
- Nier Automata (сайдскроллинг по неплоской локации)
- Last Night
- Inside
- Darq
- Transistor
- Zelda
- metal Gear Solid
- Dead Cells
- Little Nightmares
- Gone Home
- Fran Bow
- Her Story
- Firewatch
- FTL
- To The Moon
- Papers Please
- Castlevania
- Metroid
- Journey (-)
- The Longest Journey
- The Binding of Isaac
- Hyper Light Drifter (ровный геймлей, баланс пазлов, боевой системы и экспозиции)
- FURI (босс-файтинг, оригинальный подход к каждому боссу)
- Stardew Valley
- VA-11 HALL-A
- Samorost 3


МУЗЫКА

- Michael McCann
- Akira Yamaoka
- Daigo Hanada
- communication Tube
- Valve Logo Theme
- Cliff Martinez
- Angelo Badalamenti
- Dying Light
- Wolfenstein
- Katana Zero
- Hommack
---------------------------------------
- Резкие аккорды пианино (Sophie Hutchings - Dream Gate 1:10)
- LoFi-музыка (layers of Fear 2)
- В беспорядочной музыке периодически должен проблёскивать мелодия (Cubering - Mass)
- Тонкий звук с эффектом присутствия (communication Tube - Coma FM)
- Меланхоличный жалобный саунд (Daigo Hanada - Close)
- Колокольный звон (Perturbator - Disco Inferno)


МЕХАНИКИ

- Прокачка (Ori)
- Абилки и перки
- Игры со временем (Braid)
- Время идёт, когда движется игрок (Super Hot)
- Ориентация в пространстве (Darq)
- ГГ потерял память и восстанавливает её по кускам
- Сюжет строится прыжками во времени
---------------------------------------------------
- Забираться на объекты (Dishonored, Prey)
- 


НАЗВАНИЯ

- Ловец снов
- Крио
- Фьюри
- Крамола
- Пикадор
- Серпентарий
---------------
- Code Geass

КАК ПРИДУМАТЬ НАЗВАНИЕ

- https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F
- https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D1%83%D0%BA%D0%BE%D0%BF%D0%B8%D1%81%D1%8C


ЖАНРЫ

- Fran Bow - 2D-квест
- Шутер от первого лица
- Шутер от третьего лица
- Hyper Light Drifter - изометрическая экшн-RPG
- Transistor - 
- Ori - метроидвания, 2D-платформер
- Darq - 3D-головоломка с видом сбоку
- Super Hot - 3D-шутер, время идёт когда игрок движется
- Brutal Legend - экшн-адвенчура/слэшер от третьего лица
- Stardew Valley - симулятор фермера с наворотами 
- Deus Ex - immersive sim
- 



ДВИЖОК

ПАМЯТЬ:
Поскольку обычное выделение памяти медленно, нужно использовать кастомные аллокаторы.
При загрузке игры выделяется огромный блок памяти (несколько Гб), а затем движок самостоятельно 
управляется этим блоком динамически резервируя и освобождая отдельные его части посредством разных типов кастомных аллокаторов:
- StackAllocator - создаёт стек в этом огромном блоке
- DoubleStackAllocator - создаёт два стека на обоих концах блока так, чтобы один рос вверх, а другой вниз. Один можно использовать для подгрузки данных, связанных с уровнем, а другой - для per-frame данных.
- PoolAllocator - выделяет очень много маленьких блоков памяти одинкового размера
- AlignedAllocator
- Single-Frame Allocator
- Double-Buffered Allocator
http://www.swedishcoding.com/2008/08/31/are-we-out-of-memory/
http://www.swedishcoding.com/2017/11/10/multi-core-programming-and-cache-coherency/
http://www.swedishcoding.com/2015/03/08/gdc-2015-presentation-parallelizing-the-naughty-dog-engine/
https://www.youtube.com/watch?v=c0g3S_2QxWM
C++ Управление памятью
Gems 1 (1.9)
Где хранятся:
- Модели
- Текстуры, нормали и прочие изображения
- Аудио
- Шрифты
- Анимации
- Видеоролики


Управление памятью с учётом кэширования, пагинации, фрагментации и тд
Ассемблер, реверс инженеринг, оптимизация посредством асма
Взаимодейтсие с опреационной системой
Многопоточность, такты процессора, оптимизация
Рендеринг через разные API
Менеджмент ресурсов, динамическая подгрузка/выгрузка, LOD и теселляция
Физика, коллизии (хавок, physx, newton dynamics, euphoria)
Симуляция воды, тканей, частиц, тумана
Анимация (воспроизведение и биомеханика)

Сжатие аудио/изображений
Звук, видео (FMOD, Wwise, CRI Middleware, BIK)
Профайлер
Векторная графика
Шрифты, субтитры, интерфейс
Сохранения и моментальная загрузка
Сетевой код
ИИ
Консоль и меню разрабочика
OpenGL, Vulkan, DirectX 12
Фреймворк геймплейного программирования


1. Математика:
   Конспект лекций по высшей математике (20 по 30)
   Тригонометрия
   Теория вероятностей и математическая статистика (15 по 30)
   Mathematics for 3D Game Programming and Computer Graphics (17 по 30)
2. Ассемблер (29 по 20)
3. Professional C++
4. Learn OpenGL (13 по 30)

Алгоритмы и Алгоритмические трюки для прог
Game Engine Architecture
Обработка цифровых сигналов
Криптография и сжатие данных (Serious Crypto) (WebP, H.265, VP8, zStd, DXT1-5) 


Сжатие 
- Если текстура целиком из одного цвета, прозрачностьб HDR, предсказания, ограниченный цветовой диапазон
- https://habr.com/ru/company/yandex/blog/311806/
- Коды исправления ошибок

http://www.swedishcoding.com/2008/08/31/are-we-out-of-memory/
https://habr.com/ru/company/yandex/blog/311806/
https://habr.com/ru/post/272619/

------------------------------------------------------------------
------------------------------------------------------------------
------------------------------------------------------------------


(сначала изучить типы и как они себя ведутт на разных платформах)
------------------------------
Структуры данных и алгоритмы
------------------------------
- Тестирование
- Бэнчмаркинг
- Строки, форматирование и другие утилитарные функции для работы с ними
- Консоль вывода с поддержкой цветов
- Логирование в файл и в консоль, уровни логов
- Обработка ошибок без выбрасывания исключения (ASSERT)
- DataStream, MemoryStream, FileStream, sstream, fstream с учётом кодировок
- Математическая библиотека

-------------------------------

1. Создать экземпляр вулкана через VkInstance, указав инфо о приложении.
2. Запросить инфу о железе и выбрать видеокарту через VkPhysicalDevices.
3. Создать экземляр VkDevice (абстракция над physical devices), 
   в котором нужно описать какие VkPhysicalDeviceFeatures будем использовать.
4. Указать какие queue families будем использовать.
   Большинство операций типа рендеринга и манипуляций с памятью выполняется
   асинхронно посредством отправки этих задач в VkQueue. Queues выделяются
   в queue families, каждая из которых имеет свой специфичный набор операций.
5. Создать окно с помощью GLFW.
6. Создать инстанс VkSurfaceKHR - кросплатформенная абстракция над окном процесса.
   Создать инстанс VkSwapchainKHR - переключатель буферов для рендера.
7. Для того, чтобы рисовать изображение, его нужно обернуть в VkImageView и VkFramebuffer.
   Каждый VkImageView содержит один слой информации о кадре: color, depth или stencil.
   Несколько VkImageView с разной инфой упаковываются в VkFramebuffer.
   Swapchain как раз жонглирует этими VkFramebuffer.
...
8. Команды отправляются в VkCommandBuffer, каждый VkCommandBuffer выделяется 
   в VkCommandPool, каждый из которых соответствует какой-то queue family.

---------------------------------

Память
Логирование
Обработка ошибок

Рендер (материалы, текстуры, частицы, статические и динамические мэши, шейдерные эффекты, источники света)
Физика
Анимация
Интерфейс
Аудио
Искусственный интеллект
Управление
i18n

Редактор

---------------------------------

Ray Tracing Books & Code.zip

---------------------------------

Логирование, assert
Абстракция над render APIs


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

C++
Математика
Игровой движок
Алгоритмы и структуры данных
Проектирование ПО
Рендеринг
Столкновения, физика и симуляция
Криптография, сжатие и кодирование
Ассемблер
Анимация
Музыка и саунддизайн
Операционные системы
Искусственный интеллект
Моделирование, текстурирование, риггинг
Сторителлинг, сценарии
Геймдизайн

-----------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ТЕМА                                     | РЕСУРСЫ                                                                                                                                                       |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| C++                                      | Книги:                                                                                                                                                        |
|                                          | - A. Williams - C++ Concurrency In Action                                                                                                                     |
|                                          | - M. Gregoire - C++ Standard Library Quick Reference                                                                                                          |
|                                          | - M. Gregoire - Professional C++                                                                                                                              |
|                                          | - Д. Вандевурд - Шаблоны C++                                                                                                                                  |
|                                          | - S. Roth - Clean C++17                                                                                                                                       |
|                                          | - С. Мейерс - Эффективный и современный C++                                                                                                                   |
|                                          | - SEI CERT C++ Coding Standard                                                                                                                                |
|                                          |                                                                                                                                                               |
|                                          | Статьи:                                                                                                                                                       |
|                                          | - ООП                                                                                                                                                         |
|                                          | - Шаблоны (template<>)                                                                                                                                        |
|                                          | - Лямбды                                                                                                                                                      |
|                                          | - Параллельное программирование                                                                                                                               |
|                                          | - Лучшие практики и гайдлайны                                                                                                                                 |
|                                          | - STL                                                                                                                                                         |
|                                          |                                                                                                                                                               |
|                                          | Видеокурсы:                                                                                                                                                   |
|                                          | - A modern formatting library for C++                                                                                                                         |
|                                          | - Design Patterns in CPP                                                                                                                                      |
|                                          | - Advanced C++ Programming                                                                                                                                    |
|                                          | - O'Reilly - Intermediate C Plus Plus Programming                                                                                                             |
|                                          | - O'Reilly - Learning CPP Best Practices                                                                                                                      |
|                                          | - Packt - CPP 17 STL Solutions                                                                                                                                |
|                                          | - Pluralsight - Beautiful CPP - STL Algorithms                                                                                                                |
|                                          |                                                                                                                                                               |
|                                          | Статьи:                                                                                                                                                       |
|                                          | - A modern formatting library for C++                                                                                                                         |
|                                          |                                                                                                                                                               |
|                                          | Ссылки:                                                                                                                                                       |
|                                          | - https://ravesli.com/                                                                                                                                        |
|                                          | - (Chrome Guidelines) https://vk.cc/a7DIQe                                                                                                                    |
|                                          | - (Hi-Perf Allocator) https://vk.cc/a7DJw6                                                                                                                    |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| МАТЕМАТИКА                               | Разделы математики:                                                                                                                                           |
|                                          | - Математический анализ                                                                                                                                       |
|                                          | - Тригонометрия                                                                                                                                               |
|                                          | - Топология                                                                                                                                                   |
|                                          | - Дифференциальная геометрия                                                                                                                                  |
|                                          | - Аналитическая геометрия                                                                                                                                     |
|                                          | - Линейная алгебра                                                                                                                                            |
|                                          | - Оптимизация                                                                                                                                                 |
|                                          | - Теория вероятностей                                                                                                                                         |
|                                          | - Математическая статистика                                                                                                                                   |
|                                          |                                                                                                                                                               |
|                                          | Книги:                                                                                                                                                        |
|                                          | - J. Vince - Mathematics for Computer Graphics                                                                                                                |
|                                          | - E. Lengyel - Mathematics for 3D Game Programming and Computer Graphics                                                                                      |
|                                          | - D. Kothari - Mathematics for Computer Graphics and Game Programming: A Self-Teaching Introduction                                                           |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ИГРОВОЙ ДВИЖОК                           | Книги:                                                                                                                                                        |
|                                          | - J. Gregory - Game Engine Architecture                                                                                                                       |
|                                          | - E. Lengyel - Game Engine Gems. Volume 1                                                                                                                     |
|                                          | - E. Lengyel - Game Engine Gems. Volume 2                                                                                                                     |
|                                          | - E. Lengyel - Game Engine Gems. Volume 3                                                                                                                     |
|                                          | - R. Nystrom - Game Programming Patterns                                                                                                                      |
|                                          | - K. O'Conor - Multithreading for Gamedev Students                                                                                                            |
|                                          |                                                                                                                                                               |
|                                          | Статьи:                                                                                                                                                       |
|                                          | - C. Gyrling - Parallelizing the Naughty Dog engine using fibers                                                                                              |
|                                          | - C. Gyrling - Cache Coherency and Multi-Core Programming                                                                                                     |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| АЛГОРИТМЫ И СТРУКТУРЫ ДАННЫХ             | Книги:                                                                                                                                                        |
|                                          | - Р. Стивенс - Алгоритмы                                                                                                                                      |
|                                          | - Г. Уоррен - Алгоритмические трюки для программистов                                                                                                         |
|                                          | - (по структурам см. C++)                                                                                                                                     |
|                                          |                                                                                                                                                               |
|                                          | Ссылки:                                                                                                                                                       |
|                                          | - https://graphics.stanford.edu/~seander/bithacks.html                                                                                                        |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ПРОЕКТИРОВАНИЕ ПО                        | Книги:                                                                                                                                                        |
|                                          | - С. Макконнелл - Совершенный код                                                                                                                             |
|                                          | - S. Maguire - Writing Solid Code                                                                                                                             |
|                                          | - S. Freeman - Growing Object-Oriented Software Guided by Tests                                                                                               |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| РЕНДЕРИНГ                                | Книги:                                                                                                                                                        |
|                                          | - P. Shirley - Fundamentals of Computer Graphics                                                                                                              |
|                                          | - J. Hughes - Computer Graphics Principles and Practice                                                                                                       |
|                                          | - T. Akenine-Moller - Real-Time Rendering                                                                                                                     |
|                                          | - M. Pharr - Physically Based Rendering From Theory To Implementation                                                                                         |
|                                          | - E. Haines, T. Akenine-Möller - Ray Tracing Gems High-Quality and Real-Time Rendering with DXR and Other APIs                                                |
|                                          | - E. Eisemann - Real-Time Shadows                                                                                                                             |
|                                          | - F. Luna - Introduction to 3D Game Programming with Directx 12                                                                                               |
|                                          | - A. Overvoorde - Vulkan Introduction Tutorial                                                                                                                |
|                                          | - J. Vries - Learn OpenGL (learnopengl.com)                                                                                                                   |
|                                          |                                                                                                                                                               |
|                                          | Статьи:                                                                                                                                                       |
|                                          | - Real-Time Ray Tracing                                                                                                                                       |
|                                          | - X. Xiao - Fast, High-Quality Rendering of Liquids Generated Using Large-scale SPH Simulation                                                                |
|                                          | - M. Drobot - Hybrid Reconstruction Anti Aliasing                                                                                                             |
|                                          | - E. Hammon - PBR Diffuse Lighting for GGX+Smith Microsurfaces                                                                                                |
|                                          | - Z. Majercik - Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields                                                                         |
|                                          | - V. Chlumsky - Shape Decomposition for Multi-channel Distance Fields                                                                                         |
|                                          | - E. Lengyel - Voxel-Based Terrain for Real-Time Virtual Simulations                                                                                          |
|                                          | - E. Lengyel - GPU-Centered Font Rendering Directly from Glyph Outlines                                                                                       |
|                                          | - E. Lengyel - Slug 2.0 Manual                                                                                                                                |
|                                          | - Precomputed Atmospheric Scattering                                                                                                                          |
|                                          | - Moving Frostbite to Physically Based Rendering 3.0                                                                                                          |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| СТОЛКНОВЕНИЯ, ФИЗИКА И СИМУЛЯЦИЯ         | Книги:                                                                                                                                                        |
|                                          | - C. Ericson - Real-Time Collision Detection                                                                                                                  |
|                                          | - D. Bourg - Physics For Game Developers                                                                                                                      |
|                                          | - I. Millington - Game Physics Engine Development                                                                                                             |
|                                          |                                                                                                                                                               |
|                                          | Статьи:                                                                                                                                                       |
|                                          | - X. Xiao - Fast, High-Quality Rendering of Liquids Generated Using Large-scale SPH Simulation                                                                |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| КРИПТОГРАФИЯ, СЖАТИЕ И КОДИРОВАНИЕ       | Книги:                                                                                                                                                        |
|                                          | - J. Aumasson - Serious Cryptography A Practical Introduction to Modern Encryption                                                                            |
|                                          | - L. Houtven - Crypto101                                                                                                                                      |
|                                          | - K. Sayood - Introduction To Data Compression                                                                                                                |
|                                          |                                                                                                                                                               |
|                                          | Заметки:                                                                                                                                                      |
|                                          | - Использовать zStd или LZ4 (https://facebook.github.io/zstd)                                                                                                 |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| АССЕМБЛЕР                                | Книги:                                                                                                                                                        |
|                                          | - D. Kusswurm - Modern x86 Assembly Language Programming x86-64, AVX, AVX2 and AVX-512                                                                        |
|                                          |                                                                                                                                                               |
|                                          | Видеокурсы:                                                                                                                                                   |
|                                          | - Pluralsight - High-Performance Computing in C Plus Plus                                                                                                     |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| АНИМАЦИЯ                                 | Книги:                                                                                                                                                        |
|                                          | - R. Parent - Computer Animation Complete                                                                                                                     |
|                                          |                                                                                                                                                               |
|                                          | Ссылки:                                                                                                                                                       |
|                                          | - http://nfrechette.github.io/2016/10/21/anim_compression_toc/                                                                                                |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| МУЗЫКА И САУНДДИЗАЙН                     | Книги:                                                                                                                                                        |
|                                          | - W. Phillips - A Composer's Guide to Game Music                                                                                                              |
|                                          | - M. Sweet - Writing Interactive Music for Video Games                                                                                                        |
|                                          | - W. Pirkle - Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory                                                              |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ОПЕРАЦИОННЫЕ СИСТЕМЫ                     | Книги:                                                                                                                                                        |
|                                          | - М. Руссинович - Внутреннее устройство Microsoft Windows                                                                                                     |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ИСКУССТВЕННЫЙ ИНТЕЛЛЕКТ                  | Книги:                                                                                                                                                        |
|                                          | - G. Yannakakis - Artificial Intelligence and Games                                                                                                           |
+------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+

// ------------------------------

RTX:
-
PhysX:
- 
SIMD:
- 
Рендеринг:
- 
Рендеринг шрифтов:
- 
Параллелизм:
- 
DirectX 12:
-
Vulkan:
- 
GLSL:
- 
HLSL:
- 
Анимация:
- S. Zerbst - 3D Game Engine Programming (Chapter 8)
Игровой движок:
- 
Менеджер памяти:
- 
Свой язык шейдеров:
- Nystrom - Crafting Interpeters

// ------------------------------

Resource Management:
- Game Engine Architecture
- Game Engine Gems. Volume 1 (Ch 11)
- R. Vaya - Open World Streaming
- Game Programming Gems 1 (Ch 1.7)
- Game Engine Gems 2 (Ch 26)
- Game Coding Complete
- Streaming Tech in Sunset Overdrive
- https://www.gamedev.net/forums/topic/663222-resource-manager-for-open-world-game/
- https://gist.github.com/jmakitalo/93102107bb44d66f83d5
- https://www.gamasutra.com/blogs/MichaelKissner/20151104/258271/Writing_a_Game_Engine_from_Scratch__Part_2_Memory.php
- https://gamasutra.com/blogs/MichaelKissner/20151120/259561/Writing_a_Game_Engine_from_Scratch__Part_3_Data__Cache.php
- http://www.swedishcoding.com/2008/08/31/are-we-out-of-memory/

- Game Engine Architecture
- 3.3 (131)
- 3.5 (181)
- 6.2 (426) + 
- 7 (481) (513 - !!!)
- 15 (1015)
- 16 (1039)
- !!! Game Coding Complete (ch 8)


Resource manager работает с файловой системой и висит в отдельном потоке.
World Streamer определяет, какие entites должны быть загружены, а какие выгружены.
Graphics System должна рендерить entites, загруженные World Streamer.
Physics System на каждом тике должна отправлять в World Streamer о новом положении игрока.
Сначала ресурс загружается в RAM, затем RAM -> VRAM (всё это в главном потоке), а затем удаляется из RAM (в любом потоке).
Resource Manager принимает запрос на загрузку ресурса, в любом случае создаёт хендлер с адресом ресурса в RAM и увеличивает кол-во ссылок на ресурс.
Затем проверяет, загружен ли ресурс. Если нет, то загружает его. Когда Resource Manager принимает запрос на освобождение ресурса, то смотрит
на кол-во ссылок на этот ресурс. Если оно равно 0, то удаляет ресурс из памяти.


Memory pool
Memory arena
Поддержка сжатия
Выравниваение по определённой границе
Ресурсы, используемые на уровне близко друг к другу должны так же близко располагаться в архивах
Запоминание положения объектов
Совместимость с сохранениями

Как и где хранятся ресурсы (RAM/VRAM), как с этим соотносится Memory Pool/Memory Arena?

rmolla@dsic.upv.es

// ПАМЯТЬ
// ------------------------------

Особенности ресурсов:
- Некоторые рес-ы находятся всегда в памяти
- Некоторые ресурсы уникальны
- некоторые связаны с другими ресурсами или чанками мира

Ресурсы:
- Текст
- Материалы:
  - Текстуры
  - 
- Модели:
  - Мэши
- Материалы
  - Текстуры
- Скелеты
- Анимации
- Звук
- Модели коллизий
- Физические модели



- StackAllocator - выделяет память для целого уроовня, по окончании уровня выгружает все эти данные.
  Используется в в случае, когда весь уровень загружается целиком, игрок смотрит на экраны загрузки.
  Сначала в стек грузятся глобальные ресурсы, а затем ресурсы уровня. Когда уровень пройден, он выгружается, и загружается новый.
- DoubleEndedStackAllocator - два стека в одном большом блоке памяти. Один направлен вниз, другой вверх.
- Pool Allocators: часто нужно выделять много блоков одинакового размера.
  PoolAllocator выделяет один большой блок памяти, размер которого кратен размеру одного базового блока.
  Связаный список содержит столько элементов, сколько базовых блоков помещается в этом большом блоке памяти.
  Во время инициализации все элементы списка свободны. При запросе на выделение берётся ближайший свободный
  элемент, а при освобождении, высвобождается.
  НО! Вместо связанного списка лучше использовать сами эти свободные элементы для хранения next-указателя.
  !!! Каждый ресурс, загружаемый в такой пул, должен быть кратен размеру одного чанка.
- Aligned Allocations: все данные в памяти требуют выравнивания по определённой границе (3.3.7.1).
  Например, 128-bit SIMD-вектор должен быть выравнен по 16-байтовой границе. 
  ! Все аллокаторы должны иметь возможность выделять выравненные блоки памяти.
- Single-Frame Allocators - это частный случай StackAllocator, в нём будет храниться инфа, только для текущего фрейма game-loop'а.
- Double-Buffered Allocators - похож на Single-Frame Allocators, но имеет два буффера, которые свопаются на каждом тике.
  Это необходимо для того, чтобы сохранить инфу текущего фрейма для следующего фрейма.
- Чтобы избежать фрагментации памяти, нужно использовать StackAllocator или PoolAllocator.
- PoolAllocator - имеет проблему - не все чанки заполнены полность. Чтобы решить эту проблему, нужно использовать
  ChunkyAllocator, который хранит связанный список всех не до конца заполненных чанков и заполняет их, когда нужно.
  Есть проблема: если главная информация в чанке больше не нужна, он освобождается, поэтому теряются и второстепенные данные.
  Чтобы такого не происходило, в чанк нужно дописывать только те данные, жизненный цикл которых заканчивается вместе с основными данными.
  Хороший размер чанка 0.5-1Мб. И делать размер чанка кратными размеру I/O буффера.

CPU работает быстрее с маленькими смежными блоками памяти, чем с расбросанными по отдалённым адресам.
Если все ассеты лежат на носителе в виде отдельных файлов, то они могут быть разбросаны по разным секторам нсителя, что увеличивает время доступа к ним.
Если упаковать их в один архив, то на носителе они тоже будут храниться в виде одного файла.

- Поддержка патчинга
- Сильно сжимать
  Быстро расжимать
  Не требовать для расжатия много памяти
- Многие ресурсы должны находиться в VRAM (вершины, текстуры, шейдеры и тд.), а другие должны быть в RAM.
  Пр этом ресурсы в RAM тоже загружаются не куда попало (persistent-ресурсы и level-ресурсы должны быть в разных местах)
- Ресурсы могут быть загружены на протяжении всей работы игры.
- Могут быть загружены только для уровня.
- Ресурс из текущего уровня может быть нужен в следующем уровне.
- В каждый момент времени может быть нужна лишь часть ресурса (окружающий звук)
- ! Декомпрессия должна быть целостная (для большинства ресурсов) и последовательная (для видео и аудио)
- ! Для каждого ресурса подходят разные типы сжатия.
- ! Memory Alloc-s сильно используются в менеджере ресурсов.
  Иногда аллокаторы пишутся под нужды менеджера ресурсов, а иногда наоборот. 
- !!! Упаковывать соседние ресурсы как можно ближе друг к другу, чтобы читать их разом.
  Seek - медленная операция, т.к. требует от HDD изменения скорости расрутки диска, а это очень медленно.
  ! Использовать seek, если SSD, и read, если HDD.

Минимальные требования к стримингу:
- FileSystem
- Компрессия/декомпрессия ассетов
- Разбиение карты на сегменты
- Рендер
- Collision Detection?
- LODs
- Эффективные аллокаторы и менеджеры ресурсов
- Многопоточность

Что учесть при стриминге:
- Скорость чтения с SSD и HDD
- Как работают шины памяти
- Какие ресурсы и как хранятся в RAM/VRAM
- Не выгружать ненужные ресурсы, а лишь помечать их ненужными и добавлять дату последнего использования
- Игрок может телепортироваться
- Должна быть возможность подгружать отедельные локации, не выгружая основную (интерьер)
- Могут быть расшаренные на всю игру объекты (транспорт)

Требования к аллокатору:
- Выделять память быстро
- Использовать минимум мета-информации о выделенной памяти
- Не допускать фрагментации
- В случае чанков, использовать весь чанк
- Некоторые ресурсы в памяти должны шариться между уровнями
- Поддержка выравнивания

Сжатие текстур:
- 1/2/3D-текстуры
- Поддержка мип-мапов (сгенерированные при компиляции?) (можно ли располагать произвольно?)
- Упаковка в наиболее подходящий формат битности (чтобы в рантайме сохранять память)
  https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml#id-1.6.15.1
  https://www.khronos.org/registry/vulkan/specs/1.0/html/chap32.html#formats-compatibility
  https://docs.microsoft.com/en-us/windows/win32/direct3ddxgi/hardware-support-for-direct3d-12-1-formats
- Сжатие (возможно, после упаковки). 
- Индексное сжатие (например, для metallic map)
- Если граф. API не поддерживает формат, то конвертировать на лету в подходящий формат битности
- Найти общие форматы битности для OpenGL, Vulkan и DirectX
- Что с sRGB?
- Посмотреть, как работают DXTn и прочие алгоритмы, поддерживаются ли они аппаратно?
- Компилятор должен учитывать следующие факторы:
  - Поддерживаемые форматы битности графическими API
  - Баланс между размером в архиве, размером в конечном распакованном виде и скоростью распаковки

- LZ4 > zStd

Идеи стриминга:
- Мир - огромный куб. Во время разработки разделить его на одинаковые вертикальные прямоугольные кубы определённой ширины, глубины и высоты (глубина == ширине). 
  Игроку присовить ещё один вертикальный прямоугольный куб определённой ширины, глубины и высоты (глубина == ширине). 
  Игрок всегда находится в центре этого куба.
  Регулируемые параметры:
  - Ширина/глубина куба карты
  - Высота куба карты
  - Ширина/глубина куба игрока
  - Высота куба игрока
  Диаметр и высоту подобрать из компромисса память - скорость стриминга. Если высота будет слишком 
    низкая, то понадобится чаще загружать/выгружать ресурсы, но будет более плавный переход от лода к лоду по вертикали.
  Разделить этот куб на высокие 3D-шестиугольники. По высоте должно помещаться (формула) шестиугольников.
    Цилиндр, находящийся на уровне земли моря должен быть вертикально выравнен по уровню этой земли. 
    (Должны пересекаться?) Должен подгружаться центральный цилиндр и окружающие его.
    Как в Sunset Overdrive весь low LOD должен быть всегда в памяти.
    Если игрок слишком высоко над землёй или глубоко под ней, то показывать только low LOD.
    (многоуровневые уровни?) (помещения?)
- Разбить мир на одинаковые пересекающиеся сферы. Любой ассет, который хотя бы частично попадает в сферу, прикрепляется к этой сфере.
  В скомпилированные данные попадает уже не сфера, а координата центра этой сферы.
  Игроку присваивается вертикальная капсула. Все центры сфер (точки), которые на данном кадре попали в капсулу, загружаются,
  а те, что вышли из капсулы, выгружаются.


// ------------------------------

Собственная реализация:
- GLFW, GLEW, GLM
Рендер: 
- С/без RTX
- Графика (FOV, DOF, LOD/теселляция, bloom, motion-blur, anti-aliasing, слои (3D, 2D-HUD), ткани, вода, волосы, шерсть, взрывы и разрушения, хром. абб.)
- Шрифты (с хинтингом и без)
- GLSL -> HLSL
- Смешивание полупрозрачных поверхностей (alpha blending): https://developer.nvidia.com/content/transparency-or-translucency-rendering
- Комбинации техник:
-- OpenGL, 
-- SVOGI (modern version of Voxel Cone Tracing), Voxel Cone Tracing (2009 techoloby from Cryengine), 
   https://www.reddit.com/r/Amd/comments/b1woch/about_the_recent_crytek_voxel_based_raytracing/
   https://docs.aws.amazon.com/lumberyard/latest/userguide/rendering-graphics-svogi.html
-- Vulkan with/without VK_KHR_ray_tracing,
-- DirectX 12 with/without DXR
- GI-технологии:
-- SVOGI - GI на основе вокселей (https://www.youtube.com/watch?v=kGxqiw8UWns)
-- DDGI - GI-технология 2019 года (https://morgan3d.github.io/articles/2019-04-01-ddgi/)
Модели:
- Правильная топология
Математика:
- CPU (SIMD)
- GPU (Compute Shader)
Физика: 
- коллизии, физика тел, физика транспорта, кинематографичная физика (Unreal Engine's Chaos, Remedy's Northlight)
- Собственный движок на CPU (SIMD) и GPU (PhysX), PhysX
С++:
- concurrency, lambda, pointers, oop, memory layout
Анимация: 
- анимация с учётом физики, 
- анимация катсцен
- Анимация и лицевая анмация основанная на нейронных сетях
Звук: 
- Объёмный звук, зависящий от материалов, музыка, звуки, сведение, синтез
- Морфинг голоса за счёт нейросетей
Управление:
- Нативная поддержка Dualshock и Xbox Controller
Сохранение:
- Быстрое сохранение и загрузка (сериализация объектов?)
Память и ресурсы:
- Разные менеджеры памяти (загрузка всего уровня целиком, assets streaming)
- Упаковка и шифрование ресурсов (чтобы можно было последовательно и отдельно распаковывать, зашифровать index архивов на VM)
Искусственный интеллект:
- 
Языки:
- Система субтитров
- Поддержка быстрой смены локализации
- Поддержка юникода
C++: 
- memory layout,
- параллельное программирование
- лямбды
- видимость переменных
- шаблоны
- STL
- Best practices


- Рендер
- Анимация
- Физика
- Звук
- Текст, локализация, субтитры
- Язык шейдеров
- Язык скриптинга 

// ---------------------------

What is GI: https://morgan3d.github.io/articles/2019-04-01-ddgi/intro-to-gi.html
DDGI: https://morgan3d.github.io/articles/2019-04-01-ddgi/
GI tech-s: https://www.gamedev.net/forums/topic/702924-what-gi-is-usable-right-now/
Fast recalc-s of light in PBR: https://research.activision.com/publications/archives/fast-filtering-of-reflection-probes

https://habr.com/ru/company/mailru/blog/353740/
https://www.cryengine.com/news/view/how-we-made-neon-noir-ray-traced-reflections-in-cryengine-and-more
Learn OpenGL
Real-Time Rendering
Ray-Tracing Gems (DXR)
https://docs.cryengine.com/pages/viewpage.action?pageId=25535599
https://developer.nvidia.com/rtx/raytracing/vkray
https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_ray_tracing.html

Is power of 2: https://www.includehelp.com/cpp-programs/check-if-a-number-is-power-of-2-or-not.aspx


// ---------------------------


Референсы:
- GTA graphics study
- Ray tracing in weekends
- laught_engine


Tessellation
Ray Tracing
Ray Path
Normal mapping (Bump mapping)
Animation
Simulation
Particles
[Cascaded] Shadow Mapping
Ray Casting
Deferred Shading/Rendering
Stencil Buffer
Anisotropy Filtering
Motion Blur
Ambient Occlusion 
Fog
Blending
Face Culling
Anti Aliasing
Gamma Correction
Bloom
Depth of Field
Level of Details
Post processing tricks

// ------------------------------

projection matrix:
- https://www.learnopengles.com/tag/perspective-divide/
- http://www.songho.ca/opengl/gl_projectionmatrix.html

1. V_view = M_view * M_model * V_local - перевод локальных координат в сис. коорд. модели, а затем в сис. коорд. камеры (изменяются x, y и z, а w на протяжении всех этих операций равно 1.0)
2. Определённым образом вычисляется M_projection.
3. V_clip = V_view * M_projection - на этом этапе x, y и z не изменяются, для каждой вершины лишь вычилсяется w (чем объект дальше по оси z от объектива камеры, тем w больше)
4. V_NDC = vec4(V_clip.x / V_clip.w, V_clip.y / V_clip.w, V_clip.z / V_clip.w, 1.0) - перевод в NDC за счёт деления z, y и z на w, при этом w снова становится равно 1.0, а x, y и z теперь расположены в интервале [-1, 1]
   Важно, что OpenGL - right-handed, а NDC - left-handed.
5. OpenGL выполняет маппинг V_NDC к пикселям вьюпорта (glViewport), то есть, например, ((-1, -1), (1, 1)) -> ((0, 0), (800, 600))
* деление перспективы можно выолнить самому в v-шейдере, или оставить эту работу OpenGL 

// -------------------------------

camera:
- position in world space
- the direction it's looking at
- vector pointing to the right 
- vector pointing upwards

- Координаты камеры находтся в мировых координатах

cameraPos = vec3(0.0, 0.0, 3.0) - позиция камеры в мировых координатах (сдвинута на 3 по z)
cameraTarget = vec3(0.0, 0.0, 0.0) - точка в мировых координатах, куда направлена камера (направлена на начало координат)
cameraDirection = normalize(cameraPos - cameraTarget) - единичный вектор, который направлен вперёд из объектива (в OpenGL направлен в противоположную сторону - внутрь камеры)
cameraRight = normalize(cross(vec3(0.0, 1.0, 0.0), cameraDirection)) - вектор, выходящий из камеры вправо (вычисляется посредством векторного произведения единичного вектора вверх и вектора cameraDirection)
cameraUp = cross(cameraDirection, cameraRight) - вектор, выходящий из камеры вверх (вычисляется посредством векторного произведения вектора cameraDirection и вектора cameraRight)

lookAt - view-матрица (M_view), которая трансформирует все вершины объектов так, чтобы при взгляде из камеры казалось будто бы камера переместилась в пространстве. 


// -------------------------------------------------


PBR считает, что любая поверхность состоит из микро-граней (microfacets), каждая из которых имеет свою нормаль.
То, насколько хаотично друг относительно друга расположены микро-грани одного материала зависит от шероховатости (roughness = [0, 1]).
На основе roughness мы можем статичстически вычислить долю микро-граней материала, которые перпендикулярны определённому вектору h.
Чем меньше roughness тем больше концентрация перпендикулярных вектору h микро-граней, и тем более яркое и кучное отражение будет.
h - halfway-вектор, вектор-биссектриса угла между вектором падающего луча (l) и вектором взгляда (v).
h = l - v
n - вектор нормали
a = dot(n, h)
a - коэфф., который зависит от угла b между n и h: 
- a -> 0 при b -> 90deg (то есть n и h перпендикулярны)
- a -> 1 при b -> 0deg (то есть n и h параллельны/совпадают)
при этом b = [0deb, 90deg], a = [0, 1]



https://wiki.jmonkeyengine.org/jme3/advanced/pbr_part1.html
https://wiki.jmonkeyengine.org/jme3/advanced/pbr_part2.html
https://wiki.jmonkeyengine.org/jme3/advanced/pbr_part3.html
http://www.polygonpi.com/?tag=halfway-vector

ВОПРОСЫ
------------------------

1. Как работает рендеринг когда недостаточно геометрии
2. Как рендер зависит от LOD
3. Как рендер сочетается со шрифтами, обводкой интерактивных объектов и тд...
4. Как свет сцены зависит от скайбокса

РЕСУРСЫ
------------------------

PBR:
- В целом: PBR in UE4 (2013).pdf
- Подробно о переезде на PBR: Moving Frostbite to Physically Based Rendering 3.0.pdf
- Теория и реализация PBR: PBR Workflow Implementation for Game Environments.pdf
- Ориг. статья Дисней о PBR: Physically-Based Shading at Disney (2012).pdf
- GGX: E. Hammon - PBR Diffuse Lighting for GGX+Smith Microsurfaces.pdf
- Оптимизация отражений cubemaps: Fast Filtering of Reflection Probes.pdf
- О недостатках Lambert: Generalization of Lambert's Reflectance Model.pdf
- О мат. и физике PBR: Physics and Math of Shading.pdf
- Самозатенение поверхностей: Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.pdf

Материалы:
- Bungie - Translating Art Into Technology.pdf

Математика:
- Основная математика
- Матан
- Тригонометрия
- Аналитическая геометрия
- Статистика
- Теория вероятностей
- Топология

-------------------------------------


ЗАДАЧИ ДЛЯ РЕНДЕРА
-------------------------------------

- forward/forward+/deferred rendering
- Variable Rate Shading
- sRGB, Gamma
- HDR
- Global Illumination
- Depth of Field
- Lens Flares
- LOD, теселляция
- Bloom
- Тени
- Motion Blur
- Сглаживание
- Анизотопная фильтрация
- Вертикальная синхронизация
- Ненатуральные объекты в сцене (текст, выделение объектов...)
- Слои (3D, 2D-HUD)
- Полупрозрачные поверхности
- Хроматическая абберация
- Растения
- Дождь
- Молния
- Динамические облака
- Облака + atmospheric scattering
- Облака + молния
- Дым и туман
- Ткани
- Вода
- Волосы
- Шерсть
- Взрывы
- Разрушения
- Ray Tracing
- Технологии: DXR, VulkanRT, PhysX


ЗАМЕТКИ
-------------------------------------

- В модели Local Illumination учитываются только лучи, упавшие в определённую точку поверхности напрямую из источника свет, и отразившиеся прямо в глаз (direct light). 
  В модели Global Illumination учитываются многократно отражённые влучи (indirect light).
- Point Light - бескоечно малая точка в пространстве, которая излучает один луч на одну точку пространства. В реальности такой источник света невозможен.
- Для вычисления света в одном пикселе может использоваться много семплов, чем больше семплов, тем точнее конечный цвет пикселя.
- Чем более неоднородная среда, тем сильнее она поглощает свет.
- Scattering: фотон (частица света) сталкивается с частицей среды и меняет своё направление, сохраняя при этом всю свою энергию.
  Absorbtion: фотон сталкивается с частицей среды, которая поглощает его энергию (затем она может её выпустить в виде тепла).
- Roughness влияет только на площадь отражения, а не на кол-во отражённого света (это константа).
- Проводники имеют свободные носители заряда, поэтому они поглощают весь refracted-свет.
  Диэлектрики не имеют носителей заряда, поэтому большую часть refracted-света они отражают.
- Refracted-луч если и выходит снова на поверхность, то примерно из той же точки, в которую входит.
  Если такой луч, перемещаясь внутри материала, достаточно сильно отклонился от точки входа в материал, то он будет полностью поглощён.
  По этой причине мы считаем, что diffuse-свет (рассеянный во все стороны отражённый свет) отражается от той же точки, в которую входил.
  BRDF учитывает это допущение. Но если мы имеем дело со слабым абсорбентом, но с сильным scatter-свойством (воск, молоко, кожа), то 
  refracted-луч, блуждая внутри материала, может выйти далеко от точки входа. Для таких материалов нужно использовать более дорогую
  функцию BSSRDF, вместо BRDF. Это называется подповерхностное рассеивание (subsurface scattering).
- Radiance - сколько энегрии/света приходит в точку из конкретного направления, точнее сколько волн падает в точку.
  Irradiance - сколько энегрии/света приходит в точку из всех направлений. Irradiance = radiance1 + radiance2 + ... + radianceN.
  В PBR вместо подсчёта кол-ва волн в radiance просто берут RGB-вектор, представляющий собой цвет падающего света и по совместительству кол-во энергии.
- Сначала нужно вычислить сколько всего света падает в точку со всех направлений (irradiance), сложив все radiance.
  Далее, в зависимости от материала, нухно определать сколько света reflected, а сколько refracted.
- Shadowed-лучи (лучи, многократно отражающиеся от соседних микро-граней) в конечном итоге тоже могут отразиться в глаз (interreflection), 
  но это происходит так редко, что в real-time PBR ими пренебрегают.
- Эффект Френеля - чем меньше угол между вектором взгляда и поверхностью, тем сильнее отражение.
  Отражение Френеля рассчитывается с учётом индекса отражения материала (IOR), существуют таблицы с IOR.
  ! Уравнение Френеля (приближение Френеля-Шлика) определено только для диэлектриков, но чтобы его можно было использовать и для металлов,
    задействуем такой хак: F0 = mix(vec3(0.04), surfaceColor.rgb, metalness); таким образом, если это не металл (metalness ~= 0.0), 
    то F0 будет равно 0.04 (усреднённое значение base reflectivity для диэлектриков), в противном случае - F0 будет равно цвету с текстуры металла.
    Важно помнить, металлы, как и диэлектрики, поглощают часть света, но в отличие от вторых, они поглощают его окончательно и никакого diffuse-света 
    на поверхность не выходит. Так как diffuse-свет выносит на поверхность цвет объекта, то и цвета у металлов нет (поэтому мы видим только specular).
    По этой причине для металлов в качестве base reflectivity мы будем использовать его цвет.
  IOR (Index of Reflectance) материала - это отношение скорости света в вакууме к скорости света в этом материале.
  У некоторых материалов reflectance разный для всего видимого спектра, то ROI для них указывается в виде RGB-вектора, а не числа.
  Тот канал (R, G или B), который превалирует над остальными двумя, будет придавать материалу свой оттенок.
- В реальности свет линеен, но на компьютер монитора выводится изображение, цветовое пространство которого переведено 
  из линейного в sRGB (gamma corrected), чтобы компенсировать недостатки мониторов. По этой причине все текстуры игры
  уже имеют гамма-коррекцию. Но все PBR-вычисления необходмо проводить в линейном цветовом пространсте.
  Поэтому в шейдере перед рассчётом света необходимо перевести текстуры из sRGB в линейное пространсто, выполнить
  вычисления и обратно перевести в sRGB.
- l - вектор падающего света
  v - вектор взгляда
  h - halfway-вектор между l и v (биссектриса угла между l и v)
  Чем больше микро-граней перпендикулярны h, тем ярче и чётче будет specular-отражение.
  Чем больше roughness, тем меньше микро-граней перпендикулярны h, в конкретной точке p,
  но на всей поверхности появляется больше случайных граней, перпендикулярных h, поэтому 
  при увеличении roughness specular-отражение становится тусклее, но распространяется по большей поверхности.
- Используем metallic workflow.
- Закон сохранения энергии: для неизлучающих поверхностей, отражённый свет должен быть <= падающему свету.
- Reflected-свет - это specular-свет (отражается напрямую от поверхности).
  Refracetd-свет проникает внутрь поверхности, часть его может поглощаться, но та часть, которая снова выходит на поверхность - это diffuse-свет.
- ! Именно diffuse-свет проявляет цвет поверхности.
- refracted = 1.0 - reflected 
- reflectance equation - более специализированныя версия render equation, используемая в PBR
  L считает сколько всего света падает в точку p со всех сторон.
  BRDF на основе свойств материала рассчитывает какая часть этого света становится reflected, а какая - refracted.
- metallic по большому счёту двоичное свойство: либо 1.0 либо 0.0 (поверхность либо металлическая, либо нет).
  Но иногда используются и промежуточные значения, которые могут обозначать грязь или пыль на поверхности металла.
- Albedo - текстура, содержащая цвет или base reflectivity, если это металл
  Normal - карта нормалей
  Metallic - карта металличности
  Roughness - карта шероховатости
  AO - карта затенённых областей объекта


IBL: w_i - это вектор представляющий один cubemap-texel, таких лучей должно падать много
По идее, на каждую точку p поверхности, для которой нужно вычислить свет, нужно опустить 
световые лучи w_i со всех направлений от cubemap (заполнить всю получферу с центром в точке p).
Но это слишком дорого.  

BUFFERS
------------------------

Color Buffer   |
Depth Buffer   | => Frame Buffer
Stencil Buffer |

По умолчанию, всё рендерится в default framebuffer.
на экран выводистся изображение только из default framebuffer.
Можно создавать свои фрейм-буфферы.
В основном они используются для offscreen-рендеринга.
Только что созданный буффер является незавершённым, поэтому его нельзя использовать сразу.
Чтобы сделать его завершённым, необходимо выполнить условия:
- К фрейм-буфферу нужно прикрепить как минимум один буфер (color, depth или stencil)
- Должен быть как минимум один color attachment
- Все аттачменты тоже должны быть завершёнными (для них должна быть выделена память)
- Все прикреплённые буфферы должны иметь одинаковое кол-во семплов.
Аттачменты - это области памяти, которые можно представить как изображения.
Есть два типа аттачментов: текстуры и renderbuffer.
Если прикрепить текстуру, то это прикрепление будет вести себя как color, depth или stencil-буффер.
Текстура для фрейм-буффера создаётся как обычная текстура.
Вместо текстуры можно прикрепить render buffer, почти то же самое, только работает быстрее.



SPECULAR & DIFFUSE
------------------------

Ссылки:
- http://olympus.magnet.fsu.edu/primer/java/reflection/specular/index.html

Допустим, на поверхность падает луч. В зависимости от параметра roughness этой поверхности, 
будет поглощено (refracted) и отражено (reflected) разное количество света.
При этом refracted + refracted = 1.0. Если roughness = 1.0 (макс. шероховатая поверхность),
то поверхность вообще не отразит свет напрямую (reflected = 0), вместо этого, она поглотит
весь свет (refracted = 1.0), а затем часть этого света, отразившись от частиц метериала,
снова выйдет наружу в разные стороны.

specular light == reflected light - отражённый свет
diffuse light == refracted light - впитываемый свет

Луч теряет энергию от столкновений.
Refracted-свет теряет энергию от столкновения с частицами материала, из-за чего энергия преобразуется в тепло.
Луч не всегда теряет энергию от первого же столкновения, поэтому он продолжает сталкваться с другими поверхностями, рассеиваясь (scatter) при этом.
Впитанные в поверхность лучи, которые снова выходят на поверхность, создают эффект рассеивания (diffuse).
В PBR этот эффект упрощён: считается, что свет не выходит снова из поверхности.
В металлах, в отличие от не-металлов (диэлектриков), весь впитанный свет не рассеивается вообще, поэтому они не излучают diffuse-свет.

Сначала вычиляется отражённый свет, а затем поглощённый (1.0 - specularLight)

Закон: energy(incomingLight) >= energy(reflectedLight) + energy(refractedLight)

L - radiance (радиометрия) используется для определния кол-ва света, пришедшего из какого-то напрвления
Ф - radiant flux - transmitted energy of a light source measured in Watts
Свет - совместная сумма энергий нескольких волн разной длины, волны разной длины представляют разные цвета.
Поэтому энергию света, которую излучает свет можно рассматривать как функцию всех его волн различной длины.
Считается, что видимая часть спектра - волны, длина которых от 390nm до 700nm.
Функция radiant flux из-за своей непрактичности в CG часто заменяется vec3(R, G, B), в котором закодирована хоть и неточная, но достаточная для рендера информация (по сути это цвет света).

ω - solid angle - размер фигуры, спроецированной на единичную сферу.

_i - ingoing (падающий луч)
_o - outgoing (отражённый луч)

p - точка в сцене, которая сответсвует фрагменту
n - вектор нормали в точке p
Ω - полусфера, выровненная по центу относительно вектора нормали
ω_i - луч, падающий в точку p
ω_o - отражённый луч в глаз смотрящему (irradiance, то есть сумма radiance всех возможных ω_i)
dω_i - все возможные ω_i, подставляемые по очереди
L - яркость (radiance) точки p когда на неё падает луч ω_i
ω_i·n ИЛИ cosθ - коэффициент, который скейлит яркость в зависимости от угла θ между вектором ω_i и вектором нормали n. (скалярное произведение векторов равно косинусу угла между ними)


radiance - освещённность ОДНИМ падающим лучём в току p, отражённая по направлению вектора ω_o.
irradiance - суммарная освещённость точки p ВСЕМИ падающими на неё лучами, отражённая по направлению вектора ω_o. Зависит не только от падающий лучей, но от позиция смотрящего.
irradiance = radiance1 + radiance2 + ... + radianceN

http://www.codinglabs.net/article_physically_based_rendering.aspx
https://web.archive.org/web/20161104192609/https://marmoset.co/toolbag/learn/pbr-theory
http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx
!! http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html

// -------------------------------
// -------------------------------

lambert (albedo) {
    return albedo / PI;
}


// Macrofacet Models
// --------------------------------

MFM_cookTorrance (w_i, w_o, n) {
    float D = NDF_TrowbridgeReitz(n, halfway, roughness);    
    float F =                                                // Fresnel Reflectance factor
    float G = GF_Schlick();                                  // Masking & Shadowing factor

    float nominator = D * F * G;
    float denominator = 4 * dot(w_o, n) * dot(w_i, n);

    return nominator / denominator;
}

// BRDF по сути берёт radiance, а зетем расщепляет его на reflected и refracted 
// в зависимости от материала, и скейлит отражённый diffuse-свет (refracted)
// и отражённый specular-свет (reflected).
BRDF (albedo) {
    // reflected + refracted = 1.0
    reflected = ?;
    refracted = vec3(1.0) - reflected;
    deffuse = refracted * lambert(albedo);  // Lambertian diffuse scaled by refracted ratio
    specular = reflected * cookTorrance();  // Cook-Torrance specular scaled by reflected ratio 
    return deffuse + specular;
}

// Normal Distribution Function (NDF) - статистически подсчитывает кол-во микро-граней, перпендикулярных какому-то (halfway) вектору.
// При вычислении учитывает roughness-показатель поверхности.
// При высоком показателе roughness (близком к 1.0) большое кол-во перпендикулярных микро-граней будет расположено в маленьком радиусе от нормали.
// При низком показателе roughness (близком к 0.1) перпендикулярные микро-грани будут расположены реже и в огромном радиусе от нормали.
float NDF_TrowbridgeReitz (vec3 normal, vec3 halfway, float roughness) {
    float squaredRoughness = roughness * roughness;
    float reflectionFactor = max(dot(normal, halfway), 0.0);
    float denominator = ((reflectionFactor * reflectionFactor) * (squaredRoughness - 1.0) + 1.0);
    return squaredRoughness / (PI * denominator * denominator);
}

// Возвращает self-shadowing-множитель, зависящий от roughness 
// roughness = [0, 1] --> k = [0.125, 0.5]
float GF_Schlick (vec3 NoV, float roughness) {
    float k = roughness + 1.0;
    k = (k * k) / 8.0;
    return NoV / (NoV * (1.0 - k) + k);
}

// -------------------------------------------------


Разные интеграторы имеют разную точность.
WhittedIntegrator - основанный на Whitted’s ray-tracing алгоритме.
WhittedIntegrator accurately computes reflected and transmitted light from 
specular surfaces like glass,  mirrors, and water, although it doesn’t account 
for other types of indirect lighting effects like light bouncing off a wall and 
illuminating a room.

class Light {
    // shape of light
    // light params
}

// each object in scene represented by instance of Primitive
class Primitive {
    shape : Shape;         // geomerty of the object
    material : Material;   // material of the object
}

// created in RenderOptions::MakeScene()
class Scene {  
    lights : Light[];       // all light in the scene
    aggregate : Primitive;  // all of the geometric primitives are collected into a single aggregate of type Primitive

    worldBound : Bounds3f;  // calc-ed in c-tor bounding of the scene

    constructor () {
        this.worldBound = this.aggregate->WorldBound();

        // when scene is ready, but before render, do some init work of scene's lights
        for (light of this.lights)
            light->Preprocess(this);
    }

    // traces the given ray into the scene and returns a boolean value indicating whether the ray intersected any of the primitives.
    // If so, it fills in the provided SurfaceInteraction structure with information about the closest intersection point along the ray.
    Intersect (ray : Ray, isect : SurfaceInteraction) : boolean { // SurfaceInteraction defined in Section 4.1
        return aggregate->Intersect(ray, isect);
    }

    // checks for the existence of ANY intersections along the ray but does not return any information about those intersections. 
    // it is generally more efficient than Scene::Intersect(). This routine is used for shadow rays.
    IntersectP (ray : Ray) : boolean {
        return aggregate->IntersectP(ray);
    }
}

// Abstract class or interface.
// Integrator-inherited classes do all the render work.
class Integrator {
    abstract Render (scene : Scene);  // must be implemented
}

// The name of the Sampler Integrator derives from the fact that its rendering process is driven by a stream of
// samples from a Sampler; each such sample identifies a point on the image at which the
// integrator should compute the arriving light to form the image.
// Created in RenderOptions::MakeIntegrator() (called in pbrtWorldEnd())
class SamplerIntegrator extends Integrator {
    sampler : Sampler;
    camera : Camera;

    constructor (camera : Camera, sampler : Sampler) {
        this.sampler = sampler;
        this.camera = camera;
    }

    Render (scene : Scene) {
        // at each of a series of positions on the image plane, the method uses the Camera and the Sampler to
        // generate a ray into the scene and then uses the Li() method to determine the amount of
        // light arriving at the image plane along that ray.  This value is passed to the Film, which records the light’s contribution

        // image is decomposed into small tiles of pixels.
        // Each tile can be processed independently and in parallel.
        // The ParallelFor() implements a parallel for loop, where multiple iterations may run in parallel

        // pseudocode:

        for (tile of tiles) {  // ParallelFor2D
            async {
                seed = uniqueId();
                tileSampler = this.sampler->Clone(seed);
                sample = tileSampler.getSample();
                ray = camera.getRay(sample);
                radiance = this.Li(ray);
                camera.film.draw(sample, radiance);
            }
        }
    }
}

class WhittedIntegrator extends SamplerIntegrator {

}

// First, the sampler is responsible for choosing the points on the image plane from which rays are traced.
// Second, it is responsible for supplying the sample positions used by integrators for estimating the value of the light transport integral.
// For example, some integrators need to choose random points on light sources to compute illumination from area lights. (Chapter 7)
class Sampler {

}

// The Camera object controls the viewing and lens parameters such as position, orientation, focus, and field of view. (Chapter 6)
class Camera {
    film : Film;  // handles image storage
}

// A Film member variable inside the Camera class handles image storage (Section 7.9)
// The Film is responsible for writing the final image to a file and possibly displaying it on the screen as it is being computed.
class Film {

}



/* ---------------------------------------- */
/* --------------- ФИЗИКА ------------------*/
/* ---------------------------------------- */

Поступательное движение (translation) - все точки тела движутся одинаково, любая прямая проведённая в теле остаётся параллельной самой себе.
Вращательное движение (rotation) - все точки тела движутся по окружностям с центрами лежащими на одной прямой - оси вращения.
Материальная точка - тело, размерами которого в данной задаче можно пренебречь.
Point mass/point particle - материальная точка с ненулевой массой.
Linear motion - линейное движение без вращения.
Angular motion - угловое движение, то есть движение с вращением (при этом оно может быть линейным).
Mass properties: mass, center of mass, moment of inertia.
Линейное и угловое движение - это функция от mass properties.
Чем больше масса тела, тем сложнее привести его в движение или изменить его движение.
В механике центр масс - это точка, через которую любая сила может воздействовать на тело, не приводя к вращению тела.
! Масса тела - это мера сопротивения тела линейному движению.
  Момент инерции - это мера сопротивения тела движению поворота.
Масса тела - сумма масс всех его элементарных частиц, а масса каждой элементарной частицы = ρV (ρ - плотность, V - объём частицы).
Если тело однородное, то его масса: m = ∫ρ*dV = ρ∫dV
На практике большинство объектов не однородны, поэтому их нужно разбивать на составные части, вычислять их массу и суммировать.
First moment - статический момент 
Second moment - момент инерции

S - вектор перемещения (вектор из точки A в точку B)
Траектория - способ, которым точка A попала в точку B.
L - путь, длина траектории.


m = 
V =         // V - объём (volume)
ρ = m / V   // ρ - плотность (density)
P = mg      // P - вес (weight)
v = S / t   // v - скорость (velocity)

-------------------------------------------

Первый закон: тело движется неизменно до тех пор, пока на него не действуют силы.
Второй закон: сила, вляющая на объект, придаёт ускорение, пропорциональное массе объекта.

Сила меняет ускорение (ускорение, это скорость изменения скорости; производная скорости).
Мы не можем напрямую изменить скорость или положение предмета, мы можем только применить силу к объекту и ждать пока он изменит скорость или положение.

(менять напрямую только ускорение, а не скорость или положение)

Ускорение может быть отрицательным (торможение), положительным (разгон) или нулевым.

-------------------------------------------


int main () {
    bool isRunning = true;

    while (isRunning) {
        updateCamera();

        updateSceneElements(); // physics

        renderScene();

        swapBuffers();
    }
}

------------------------------------------------------------------------------------------------

АРХИТЕКТУРА CORTEX ENGINE

- Рендеринг
- Шейдеры
- Физика
- Анимация
- Звук
- Искусственный интеллект
- Редактор
- Сохранения


DX12
-----------------------------------------------------------------------------------------------------------------

ID3D12CommandList::ClearRenderTargetView - пример команды.
Component Object Model (COM) - технология, которая позволяет быть DX12 независимым от языка.
COM-объект - это интерфейс, который нужно понимать как класс.
COM-объекты нельзя создавать и удалять напрямую через new/delete, вместо этого нужно использовать спец. функции.
У COM-объектов есть счётчик ссылок и метод Release, который декрементит этот счётчик. Когда счётчик ссылок равен нулю, объект удаляется из памяти.
Можно вызывать этот метод вручную, но лучше использовать умный указатель Microsoft::WRL::ComPtr<ComInterface> (#include <wrl.h>).
При создании, он сам увеличивает кол-во ссылок у COM-объекта, а когда выходит за переделы видимости, вызывает метод Release у содержащегося COM-объекта.
Часто используемые методы ComPtr [I3DGPDX12, p.155]:
- Get - возвращает указатель на COM-объект.
  ComPtr<ID3D12RootSignature> mRootSignature;
  mRootSignature.Get();
- GetAddressOf - возвращает адрес указателя на COM-объект.
  ComPtr<ID3D12CommandAllocator> mDirectCmdListAlloc;
  mDirectCmdListAlloc.GetAddressOf();
- Reset - сбрасывает указатель в положение nullptr.
  mRootSignature.Reset();
Все COM-объекты префикснуты I.
Виды форматов данных:
- Типизированные: DXGI_FORMAT_*_FLOAT/UNORM/SNORM/UINT/SINT
- Бестиповые (typeless): DXGI_FORMAT_*_TYPELESS, такие данные можно интерпретировать по-разному.
! Лучше использовать типизированные форматы, т.к. они позволяют DX понять и оптимизировать ресурсы перед рендером.
! IDXGISwapChain (Swap Chain) текстуры Front/Back Buffer и методы для работы с ними.
Depth Buffer (Z-Buffer) хранит значения от 0.0 (ближе всего к переднему плану) до 1.0 (ближе всего к заднему плану).
! Разрешение Depth Buffer всегда такое же, как и у Back Buffer.
! Depth Buffer - тоже текстура, поэтому у него должен быть формат DXGI_FORMAT_*_*.
Если приложение имеет Stencil Buffer, то он обязательно приаттачен к Depth Buffer.
Во время рендеринга DX пишет в ресурсы (Back/Depth/Stencil Buffer) и читает ресурсы (текстуры, вертексы).
Перед тем как делать Draw Call нужно забиндить к Rendering Pipeline нужные ресурсы. Некоторые нужно перебиндивать при каждом Draw Call, а некоторые иногда.
Все ресурсы имеют свой дескриптор (небольшая структура). Дескриптор может описывать как весь ресурс, так и отдельную его часть.
Биндить ресурсы к Rendering Pipeline нужно с помощью их дескрипторов. 
Ресурсам нужны дескрипторы для того, чтобы по-разному описывать эти ресурсы на разных этапах рендера.
Например, на одном этапе текстуру можно описать как Rendering Target, а на другом - как input-текстуру для шейдера. 
В этом примере нужно создать два дескриптора для этой текстуры: RTV и SRV.
! Дескрипторы иначе называются View, это название использовалось в предыдущих версиях DX.
Дескриптор может быть бестиповый, а модет иметь тип:
- CBV/SRV/UAV
- Sampler descriptors
- RTV 
- DSV
Descriptor Heap - это массив дескрипторов, который объединён по типу дескриптора.
Дескрипторы лучше создавать на этапе Init Time, а не в Runtime.
Supersampling (SSAA) дороже Multisampling (MSAA) сглаживания.
О мультисемплиге [I3DGPDX12, p.166].
Структура DXGI_SAMPLE_DESC должна быть создана для Swap Chain и для Depth Buffer.
Back Buffer и Depth Buffer должны быть созданы с одинаковой DXGI_SAMPLE_DESC.
У DX есть Feature Levels - D3D_FEATURE_LEVEL.
! DXGI Best Practices - https://docs.microsoft.com/ru-ru/windows/win32/direct3darticles/dxgi-best-practices?redirectedfrom=MSDN
! Для эффективного менеджмента ресурсов есть ID3D12Device::MakeResident/Evict [I3DGPDX12, p.175].
В DX есть Command Queue - CPU кладёт туда команды для GPU, а GPU ПОСТЕПЕННО их выполняет.
Две нежелательные ситуации: Command Queue переполнена (простаивает CPU), Command Queue полностью пуста (простаивает GPU).
! Важно, чтобы GPU и CPU не простаивали.
Нужно создать Command Queue (ID3D12CommandQueue), а когда необходимо оправить список команд в Command Queue
В Command Queue отправляются не команды, а списки команд (Comand Lists), каждый из которых имеет свой тип, наследующий ID3D12CommandList.
Например, ID3D12GraphicsCommandList может содержать команды, связанные с графикой.
Нужно создать интсанс Command List, вызвать у этого инстанса методы нужных команд, и отправить этот Command List в Command Queue. [I3DGPDX12, p.176]
! Важно не забыть закрыть CL после добавления всех команд.
Command List можно создать:
- ComPtr<ID3D12GraphicsCommandList> mCommandList;
- HRESULT ID3D12Device::CreateCommandList(..., mCommandList);

ComPtr<ID3D12CommandQueue> mCommandQueue;
D3D12_COMMAND_QUEUE_DESC queueDesc{};
queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
...
md3dDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&mCommandQueue))
<...>
ComPtr<ID3D12GraphicsCommandList> mCommandList;
mCommandList->RSSetViewports(1, &mScreenViewport);
...
mCommandList->Close();
mCommandQueue->ExecuteCommandLists(1, mCommandList);

К каждому Command List прикреплён Command Allocator, который управляет памятью для команд внутри Command List.
Все команды, записываемые в Command List, хранятся в Command Allocator, а после ExecuteCommandLists,
Command Queue будет ссылаться на команды в этом Command Allocator.
Command Allocator может иметь один из этих типов:
- D3D12_COMMAND_LIST_TYPE_DIRECT - хранит список команд, которые напрямую будут выполнены GPU. Просто использовать, но есть CPU-overhead.
- D3D12_COMMAND_LIST_TYPE_BUNDLE - записывает команды в бандлы, которые драйвер может оптимизировать перед запуском. Этот подход более
  эффективен, и должен рассматриваться как оптимизация. Кроме того, его нужно использовать во время инициалзации, а не на каждой итерации.

Несколько Command List можно прикрепить к одному Command Allocator, но нельзя одновременно писать в него из нескольких Command List.
! После ExecuteCommandList(сommandList) можно очистить память сommandList (а точнее память связанного Command Allocator), вызвав метод сommandList->Reset, 
  и начать записывать новые команды. На самом деле, Command Allocator продолжит содержать команды, на которые ссылается Command Queue, но этого будет не видно.
  https://www.gamedev.net/forums/topic/674945-d3d12-command-allocator-command-list-usage/

!!! Если при инициализщации есть какие-то команды для GPU, то их нужно выполнить с ожиданием fence.
!!! У ресурсов есть состояние и есть переходы (transition) между состояниями. Разные состояния позволяют выполнять разные операции с ресурсами.
    D3D12_RESOURCE_STATE_COMMON == D3D12_RESOURCE_STATE_PRESENT == 0
!!! Построение CommandList'ов для больших сцен с кучей объекто может требовать производительности, поэтому можно раскидать построение CL на N потоков,
    каждый из которых будет строить CL только для 1/N ресурсов. [Luna, 187]
    - CL и CA у каждого потока должны быть свои, они НЕ thread-safe
    - CQ может быть расшарена между потоками, она thread-safe
    - Для производительности на инициализации нужно указать максимум CL, которые будут построены параллельно.
    (D3D12Multithreading Sample) 
!!! Функция для создания Swap Chain должна быть задизайнена так, чтобы её можно было вызывать много раз, и новый инстанс заменял бы старый. 

- Debug Layer - слой для дебага:
  Когда создавать: при инициализации, ПЕРЕД созданием Device
  Сколько экземпляров: 1
- Device - представление дисплея:
  Когда создавать: при инициализации
  Сколько экземпляров: 1
- Сommand Queue - очередь команд для GPU
  Когда создавать: при инициализации
  Сколько экземпляров: >=1
- Command List - последовательность команд.
  Когда создавать: при инициализации
  Сколько экземпляров: >=1
  Типы:
    - Direct CL Level - означает, что команды в данном CL запускаются в том виде, в котором они записаны в этот CL, обычно используется при наполнении CL командами внутри каждой итерации.
    - Bundle CL Level - означает, что данный CL оптимизирован после записи в него команд, нужно использовать только для CL, которые формируются на этапе инициализации, а не внутри итераций.
  Заметки: 
    - Direct-CL обычно запускается один раз, но можно запускать несколько раз, убедившись, что предыдущее выполнение этого CL завершено.
    - Bundle-CL можно запускать много раз внутри многих разных CL, НО Bundle-CL НЕЛЬЗЯ ОТПРАВЛЯТЬ НАПРЯМУЮ В Command List.
    - Любой поток в любое время может отправить CL в любую очередь, а порядок выполнения команд автомитически учитывается.
    - При создании CL остаётся открытым для записи.
    - Можно CL->Reset() сразу после CQ->ExecuteCommandList, поскольку этот метод копирует данные из CL в CQ. Поэтому CL можно переиспользовать сразу. 
      При новом открытии CL для записи, этот CL будет связан с новой областью памяти внутри CA.
    - https://github.com/Microsoft/DirectX-Graphics-Samples/issues/270#issuecomment-323807683
- Command Allocator
  Когда создавать: при инициализации
  Сколько экземпляров: >=1
  Заметки: 
    - CA можно ассоциировать с несколькими CL, но в каждый момент времени для записи может быть открыт только один CL, ассоциированный с данным CA.
    - Можно CA->Reset() только после выполнения команд GPU.
- Pipeline State Object - определяет множество настроек для рендера (тип примитивов, шейдеры и тд.)
- Descriptor Heap - позволяет CL привязывать ресурсы к graphics pipeline.
  Заметки: 
    - Direct-CL при создании обязан указать DH, на затем может сменить её.
    - Bundle-CL при создании не обязан указать DH. Если к Bundle-CL привязана DH, то она должна совпадать с DH родительского CL.


Ресурс в режиме записи может быть ассоциирован только с одной CQ.
CL синхронизируются с помощью Fence, а ресурсы с помощью 
Pipelinestate overview [80]

-------------------------
Как проверять feature level?
Когда происходит ресайз, что делать?
Есть несколько видеокарт и несколько нод, в чём разница?
Как DX12 API должен соотноситься с многопоточностью?
С DXR и без.
Как использовать VRS?
https://coremission.net/gamedev/urok-directx12-1/
https://www.braynzarsoft.net/viewtutorial/q16390-04-directx-12-braynzar-soft-tutorials
https://www.3dgep.com/category/graphics-programming/directx/  (много диаграм)
https://docs.microsoft.com/ru-ru/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi?redirectedfrom=MSDN#handling-window-resizing
https://alain.xyz/blog/comparison-of-modern-graphics-apis
---------------------------


СВЯЗИ:
- CommandList и CommandAllocator:
    - CL имеет ссылку на связанный CA, у них должны совпадать type [Luna, 180]
    - С каждыйм CA может быть связано несколько CL.
- CommandList и PipelineState 
    - PS указывается при создании и сбросе CL [Luna, 180]



-----------------------------------------------

================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================