<h1>Ассемблер</h1>

<ul>
    <li><a href="https://docs.microsoft.com/ru-ru/cpp/assembler/inline/using-and-preserving-registers-in-inline-assembly?view=vs-2019" target="_blank">VS Inline Asm</a></li>
</ul>


MMX - коммерческое название SIMD.
SIMD - 64-битные регистры.
SSE (Streaming SIMD) (1999) - добавляет 8 128-битных регистра для float-чисел и новые инструкции для работы с этими регистрами.
SSE2 (2000) - добавляет в SSE поддержку double-чисел и новые инструкции.
SSE3 (2004) - новые инструкции для SSE.
SSSE3 и SSE4.1 (2006) - новые инструкции.
SSE4.2 (2008) - новые инструкции, в том числе для более эффективной обработки строк.
AVX (2011) - новый виток развития SIMD. Добавляет новые 256-битные регистры и инструкции с тремя операндами.
AVX2 (2013) - улучшения для AVX.
FMA (2013) - технология для более быстрого вычисления скалярного произведения
AVX-512 (2017) - добавляет новые 512-битные регистры.
CUDA


БАЗОВЫЕ ТИПЫ
==============================================================================

------------------------------------------------------------------------------
Базовый тип       Размер             Служит основой для
------------------------------------------------------------------------------
Byte              1 байт  (8 бит)    Characters, small integers
Word              2 байта (16 бит)   Characters, integers
Doubleword        4 байта (32 бита)  Integers, single-precision floating-point
Quadword          8 байт  (64 бита)  Integers, double-precision floating-point
Double Quadword   16 байт (128 бит)  Packed integers, packed floating-point
------------------------------------------------------------------------------

Базовый тип считается выровненным, если его адрес в памяти делится на количество байт в нём.
То есть, Quadword выровнен, если его адрес делится на 8.
x86 не требует выравнивания, но лучше всегда выравнивать для повышения производительности.


ЧИСЛОВЫЕ ТИПЫ
==============================================================================

Все числовые типы представляются в компьютере на основе базовых типов.

-------------------------------------------------------------
Базовый тип   Размер   Тип С/С++                     cstdint
-------------------------------------------------------------
Byte          8        char                          int8_t
Word          16       short                         int16_t
Doubleword    32       int, long                     int32_t
Quadword      64       long long                     int64_t
Byte          8        unsigned char                 uint8_t
Word          16       unsigned short                uint16_t
Doubleword    32       unsigned int, unsigned long   uint32_t
Quadword      64       unsigned long long            uint64_t
Doubleword    32       float                         -
Quadword      64       double                        -
-------------------------------------------------------------


ПОРЯДОК БАЙТ
==============================================================================

x86 - little-endian архитектура:

 31    24 23    16 15     8 7      0      <- Порядок бит в байте
+-----------------------------------+
|        |        |        |        | 12  ^- Вверх адреса памяти возрастают
|--------|--------|--------|--------|
|        |        |        |        | 8
|--------|--------|--------|--------|
|        |        |        |        | 4
|--------|--------|--------|--------|
| Byte 3 | Byte 2 | Byte 1 | Byte 0 | 0   <- Самый младший адрес памяти
+-----------------------------------+


SIMD-ТИПЫ
==============================================================================

SIMD-типы можно рассматривать как контейнер, в котором последовательно разположены несколько одинаковых базовых типов, поэтому SIMD-типы называются packed.
Например, 16-байтовый SIMD-тип xmmword может вместить 16 базовых типов Byte, которые имеют размер 1 байт.
После того, как SIMD-тип упакован, программист может выполнить одну инструкцию сразу над всеми упакованными базовыми типами.

SIMD-тип   Размер
-------------------
xmmword    16 байт
ymmword    32 байта
zmmword    64 байта

Сколько числовых типов вмещается в один SIMD-тип:

-----------------------------------------------
Числовой тип        xmmword   ymmword   zmmword
-----------------------------------------------
8-битовый int       16        32        64
16-битовый int      8         16        32
32-битовый int      4         8         16
64-битовый int      2         4         8
32-битовый float    4         8         16
64-битовый double   2         4         8
-----------------------------------------------


ДРУГИЕ ТИПЫ ДАНЫХ
==============================================================================

- Строка - тип, реализованный на основе определённого числа последовательных базовых типов
- Битовое поле (bit fields) - последовательность бит, которая используется в качестве маски некоторыми инструкциями.
  Битовое поле может начинаться с любого бита внутри байта и содержать до 32 бит.
- Битовая строка (bit strings) - последовательность бит, которая может содержать до 2^32-1 (4 294 967 295‬) бит.
  В x86 есть инструкции, которые позволяют clear, set, scan и test отдельные биты в битовых строках.


РЕГИСТРЫ x86_64
==============================================================================

x86_64 делится на следующие компоненты:
- Регистры общего назначения (РОН)
- Регистр флагов RFLAGS
- Instruction Pointer регистр RIP
- XMM-регистры
- MXCSR (SIMD Floating-Point Control/Status Register)

Для минимально работающей программы достаточно РОН, RFLAGS и RIP. Остальные регистры (XMM, YMM, ZMM, MXCSR и тд.) - опциональны.

Любой процессор на x86_64 обязательно поддерживает как минимум SSE2 и 16 128-битных XMM-регистра.
Эти регистры также можно использовать для выполнения SIMD-инструкций над упакованными (packed) типами данных.

128-битные SIMD-регистры (XMM0-XMM15) расширены (в 2011) до 256-битных AVX-регистров (YMM0-YMM15),
причём SIMD-XMM-регистры являются младшими 128 битами AVX-YMM-регистров. Для работы с AVX-YMM-регистрами
добавлены специальные инструкции. 256-битные AVX-YMM-регистры расширены (в 2015) до 512-битных AVX-512-регистров (ZMM0-ZMM15),
причём YMM-регистры являются младшими 256 битами ZMM-регистров.

EFLAGS/RFLAGS - регистр флагов
EIP/RIP - регистр с адресом следующей инструкции
CS, DS, SS, ES, FS, GS - сегментные регистры, которые отсутствуют (отключены) в архитектуре x86-64. В x86 они использовались для адресации памяти и поддержки 4 кольца в ОС.

-------------------------------------------------------------------------------------
64б   мл32б   мл16б   мл8б   Назначение           Подробнее*
-------------------------------------------------------------------------------------
RAX   EAX     AX      AL     Accumulator          Хранит значение возврата
RBX   EBX     BX      BL     Base
RCX   ECX     CX      CL     Counter
RDX   EDX     DX      DL     Data
RSI   ESI     SI      SIL    Source
RDI   EDI     DI      DIL    Destination
RBP   EBP     BP      BPL    Stack Base Pointer   Указывает на основание стека
RSP   ESP     SP      SPL    Stack Pointer        Указывает на вершину стека
R8    R8D     R8W     R8B
R9    R9D     R9W     R9B
R10   R10D    R10W    R10B
R11   R11D    R11W    R11B
R12   R12D    R12W    R12B
R13   R13D    R13W    R13B
R14   R14D    R14W    R14B
R15   R15D    R15W    R15B
-------------------------------------------------------------------------------------
* Не смотря на то, что эти регистры называются регистрами общего назначения, 
  некоторые из них имеют конкретные назначения. Многие инструкции либо обязывают
  использовать конкретные регистры в качестве опрендов, либо они это делают сами неявно.

<img src="images/asm/x86_64_arch.png" class="figure-img img-fluid">
<img src="images/asm/x86_64_gen_purp_regs.png" class="figure-img img-fluid">


РЕГИСТР EFLAGS/RFLAGS
==============================================================================

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Бит     Название                    Обозначение   Использование   Назначение
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
0       Carry Flag                  CF *          Статус          Флаг переполнения, который устанавливается для обозначения переполнения при операциях с unsigned int
1       -                                         1
2       Parity Flag                 PF *          Статус          Флаг устанавливается, если младший байт результата арифметической, логической или сравнительной операции содержит чётное число битов в положении 1
3       -                                         0
4       Auxiliary Carry Flag        AF            Статус
5       -                                         0
6       Zero Flag                   ZF *          Статус          Используется для обозначения того, является ли результат арифметической или логической операции нулём
7       Sign Flag                   SF *          Статус          Используется для обозначения знака у результата арифметической или логической операции
8       Trap Flag                   TF            Система
9       Interrupt Enable Flag       IF            Система
10      Direction Flag              DF            Управление      Обозначает направление авто-инкремента регистров RDI и RSI при выполнении операций над строками 
11      Overflow Flag               OF *          Статус          Флаг переполнения, который устанавливается для обозначения слишком большого/маленького результата при операциях с signed int
12      I/O Privilege Level Bit 0   IOPL          Система
13      I/O Privilege Level Bit 1   IOPL          Система
14      Nested Task                 NT            Система
15      -                                         0
16      Resume Flag                 RF            Система
17      Virtual 8086 Mode           VM            Система
18      Alignment Check             AC            Система
19      Virtual Interrupt Flag      VIF           Система
20      Virtual Interrupt Pending   VIP           Система
21      ID Flag                     ID            Система
22-63   -                                         0
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
* Наиболее важные флаги для прикладного программирования


ОПЕРАНДЫ
==============================================================================

Инструкции требуют один или более операндов-источников (source) и один операнд назначения (destination).
Многие инструкции требуют явно указывать src/dest операнды, а некоторые неявно используют соответствующие регистры.

Типы операндов:
- Непосредственное значение (immediate) - обычная константа. Только операнд-источник может быть непосредственным значением.
- Регист - само значение такого операнда находится в GP или SIMD регистре.
- Память - само значение такого операнда находится в памяти процесса в виде одного из базовых типов.
  Такой тип может иметь операнд-источник или операнд назначения, но не оба сразу.

<img src="images/asm/operands_examples.png" class="figure-img img-fluid">

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Ассемблер               C/C++
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
mov rax,[r13]           rax = *r13              [r13] - разадресовывает указатель r13

sub qword ptr [r8],17   *(long long*)r8 -= 17   [r8] - берёт значение из памяти по адресу, который лежит в r8 (подразумевается, что r8 - указатель) (эквивалентно разадресовыванию указателя в C/C++)
                                                Но сколько операция [r8] даёт только адрес памяти, но нужен ещё размер блока памяти по этому адресу. 
                                                Эту проблему и решает qword ptr: указывает, что по адресу [r8] нужно взять размер блока равный qword (8 байт)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


АДРЕСАЦИЯ ПАМЯТИ
==============================================================================

Эффективный адрес (effective address) - это адрес в памяти процесса.
Он используется для того, чтобы задействовать операд типа "память".
Эффективный адрес имеет размер 64 бита.
Эффективный адрес вычисляется на основе четырёх компонентов.
Все компоненты эффективного адреса опциональны.

EffectiveAddress = BaseReg + IndexReg * ScaleFactor + Disp
1. BaseReg - любой GP-регистр, который содержит адрес, относительно которого будут выполняться дальнейшие рассчёты эффективного адреса.
2. IndexReg - любой GP-регистр, кроме RSP.
3. ScaleFactor - коэффициент масштабирования в байтах, котороый может быть равен 2, 4 или 8.
4. Disp - 8/16/32-битная константа смещения, она кодируется в машинном коде вместе с инструкцией.

Примеры в таблице ниже показывают, как получить доступ к различным структурам данных программы в памяти.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Форма адресации                  Пример                   Пример использования 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RIP + Disp                       mov rax,[Val]            Используется для получения доступа к глобальным и статическим переменным. (Disp в этом случае 32-битный signed int)
BaseReg                          mov rax,[rbx]            Эквивалент указателя в C/C++
BaseReg + Disp                   mov rax,[rbx+16]         Служит для получения доступа к отдельным членам структуры данных
IndexReg * SF + Disp             mov rax,[r15*8+48]       Служит для получения доступа к отдельным элементам массива
BaseReg + IndexReg               mov rax,[rbx+r15]        \
BaseReg + IndexReg + Disp        mov rax,[rbx+r15+32]      | Эти формы служат для получения доступа к членам более сложных структур
BaseReg + IndexReg * SF          mov rax,[rbx+r15*8]       |
BaseReg + IndexReg * SF + Disp   mov rax,[rbx+r15*8+64]   / 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------