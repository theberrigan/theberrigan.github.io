<h1>Vulkan</h1>
В вулкане все объекты создаются с помощью vkCreateXXX или vkAllocateXXX.
После того, как объект стал не нужен, его нужно удалить через vkDestroyXXX или vkFreeXXX.
Все эти функции имеют один обший необязательный параметр pAllocator, который позваляет передать кастомный аллокатор.

Создать VkInstance с Extensions и Layers.
Выбрать VkPhysicalDevice.
Создать логический девайс VkDevice, который является абстракцией над VkPhysicalDevice.
Выбрать Queue Families, из которых будут создаваться разные VkQueue, в них будут
отправляться команды по работе с памятью или ренерингу. VkQueue из разных Queue Families
поддерживают различные команды, например, рендеринг, операции с памятью или вычисления.
Наличие определённых QF должно быть одним из факторов при выборе подходящего VkPhysicalDevice.
Создать окно приложения (это делается через API ОС или фреймворки типа GLFW, т.к. Vulkan 
ничего не знает об окнах). Создать поверхность для рендеринга VkSurfaceKHR, которая является 
кросплатформенной абстракцией над окном приложения.
Создать VkSwapchainKHR, которая предоставляет холсты для рисования кадров и меняет их местами,
когда новый кадр готов. От present mode'а, в котором работает Swapchain зависит кол-во холстов
и условия вывода кадра на экран. Основные present mode'ы: double buffering (vsync) и triple buffering.
Для того, чтобы рисовать на холсте, полученном из Swapchain, нужно обернуть его в разны VkImageView, 
каждый из которых позволяет модифицировать разные части холста (color, depth, stencil). 
Эти VkImageView нужно обернуть в VkFramebuffer. Для каждого холста из Swapchain будем создавать свои
VkImageView и VkFramebuffer, а в момент рисования будем выбирать нужные.
Render pass представляет собой слот, который может содержать изображения разного типа, 
в зависимости от которого будет интерпретироваться содержимое этого изображения. VkFramebuffer биндит 
определённые изображения из Swapchain в эти слоты. 
VkPipeline содержит определённую конфигурацию видеокарты и программу рендеринга VkShaderModule.
Если понадобится сменить шейдер или изменить лейаут вертексов, то будет необходимо заново создавать 
пайплайн рендеринга. Очень немногие операции можно выполнять без пересоздания пайплайн рендеринга.
Для того, чтобы Vulkan выполнял команды, их нужно отправить в VkCommandBuffer, который необходимо
выделить в VkCommandPool, который находится внутри одной из ранее созданных VkQueue.
Поскольку то, какое изображение находится в VkFramebuffer, завист от Swapchain, для каждого 
изображения нужно создать свой VkCommandBuffer (создавать новый VkCommandBuffer на каждом кадре
не эффективно).
В main loop нам нужно захватить изображение из swapchain с помощью vkAcquireNextImageKHR,
выбрать заранее созданный VkCommandBuffer, соответствующий этому изображению, 
рисовать на изображении и вернуть его обратно с помощью vkQueuePresentKHR.
Команды в буфферах выполняются асинхронно, поэтому нужно использовать примитивы синхронизации.

Physical Device - видеокарта
Device - логическое представление физического устройства (видеокарты)
Command - задача для выполнения, условно могут быть разделены на 3 типа:
- Action commands
- Set state commands
- Synchronization commands
Command buffer - набор команд
Queue - очередь задач, берёт задачи (command buffers) и отправляет их видеокарте для выполнения
Два самых часто используемых типов памяти - host и device

Совместимая с вулканом система может выдавать кол-во видеокарт.
Каждая видеокарта поддерживает одину или больше queues.
Queues бывают разных типов, каждый из которых имеет специфичное назначение.
Среди этих назначений может быть менеджмент графики, вычислений, пересылки данных и памяти.

1. VkInstance
2. VkPhysicalDevices
3. VkDevice
4. VkPhysicalDeviceFeatures