<h1>Архитектура компьютера</h1>
<p>
    <strong>Сегментированная организация памяти</strong> используется в реальном и защищённом режимах. В этом случае вся память делится на сегменты фиксированной или разной длины. Для доступа к сегментированной памяти используется <strong>логический адрес</strong>, который в общем случае имеет вид <code>сегмент + смещение</code>.
</p>
Режимы:
<ul>
    <li>
        <strong>Реальный режим</strong> / <strong>Real-address mode</strong> / <strong>16-битный режим</strong> – режим, в котором компьютер работает во время запуска или после загрузки.<br>
        В этом режиме процессор может использовать только одна программа в монопольном режиме.<br>
        Сегментация: каждый сегмент имеет фиксированный размер 65536 байт (64Кб).<br>
        Стандартный размер данных: WORD (16 бит).<br>
    </li>
</ul>
<p>
Логический/виртуальный адрес
Линейный адрес
Физический адрес
Эффективный адрес - в некоторых системах полностью совпадает с логическим адресом, а в некоторых является смещением в логическом адресе (<сегмент> + <смещение>).

В реальном режиме логический/виртуальный адрес, состоящий из <сегмент> + <смещение>, 
преобразуется в линейный адрес, который полностью совпадает с физическим адресом.

В защищённом режиме логический/виртуальный адрес, состоящий из <селектор_сегмента> + <смещение>,
преобразуется в линейный адрес. Если страничный механизм отсутствует или отключен, то линейный
адрес полностью совпадает с физическим, как в реальном режиме. В противном случае, линейный
адрес преобразуется в физический определённым способом.

В длинном режиме логический/виртуальный адрес совпадает с линейным адресом, поскольку сегментация
в этом режиме не используется. Линейный адрес преобразуется в физический через механизм страничной
организации памяти.

Разрядность физического адреса зависит от модели процессора. 
Процессоры 8086 и 80186 использовали 20-разрядный физический адрес.
Процессор 80286 использовал 24-разрядный физический адрес.
Процессор 80386 и ряд последующих 32-разрядных процессоров использовали 32-разрядный физический адрес.
С выпуском 64-разрядных микропроцессоров (технологии AMD64 и Intel EM64T) теоретическая разрядность 
физического адреса возросла до 64 бит, однако на практике используются более узкие физические адреса, 
но не меньше, чем 36 бит.

! Виртуальное адресное пространство - песочница/контейнер/изолированный область памяти, в которой работает каждый процесс.
В каждом виртуальном адресном пространстве адресация начинается с нуля.

Память делится на сегменты, то есть на виртуальные адресные пространства.
Внутри каждого виртуального адресного пространства может быть включен механизм страничной организации.
Чаще всего сегменты имеют разную длину. Длина сегмента может изменяться во время выполнения программы.
В C/C++ логической памятью можно назвать указатель.
Каждый сегмент представляет собой логический объект, который содержит стек или код, или данные и тд.
Обычно, в сегменте одноврмененно не могут находиться процедура и стек.
Поскольку каждый сегмент представляет собой логический объект, содержащий что-то одно (код, данные или стек),
то каждый такой сегмент имеет защиту, характерную только для этого типа сегмента.
Каждая программа, выполняющаяся на компьютере, работает с фальшивой (виртуальной) памятью.
Преобразованием виртуального адреса в физический выполняет блок управлления памятью (MMU), который расположен в процессоре.
Использование физических адресов памяти допускается только на уровне ОС и аппаратных драйверов.

Страничная организация используется для имитации памяти большого размера.
Сегментация памяти используется для представления нескольких адресных пространств.

Размер страниц фиксирован, а размер сегментов - нет.

Не все физические адреса соответствуют физической памяти. Некоторые адреса могу соответствовать каким-то
устройствам, видеобуферу или вообще каким-то дырам.

LDT и GDT находятся в виртуальной памяти.
GDT - глобальная таблица дескрипторов. Существует только одна GDT для всей ОС. Эта таблица описывает системные сегменты.
LDT - локальная таблица дескрипторов. Каждый процесс имеет свою LDT. Эта таблица описывает локальные сегменты каждого процесса (код, данные, стек и тд.)

Логическая память одного процесса полностью изолирована от логической памяти другого. 

--------------------------------

Модели памяти:
- Плоская (flat) модель памяти
- Сегментированная (segmented) модель памяти
- Страничная (paged) модель памяти

Процессоры Intel являются little-endian, то есть байты нумеруются с наименее значимого.
Адресное пространство - последовательность байт, на которую наложены адреса.
Сегменты - изолированное адресеное пространство, в котором находится какая-то одна часть процесса (например, стек, данные или код).
Адрес данных внутри сегмента имеет следующий формат: <сегментный_регистр>:<адрес_байта_внутри_сегмента>
Например:
- DS:FF79H - адрес FF79H внутри сегмента данных, на который указывает регистр DS.
- CS:EIP - адрес текущей инструкции (CS - регистр, указывающий на сегмент кода процесса, а EIP - регистр, указывающий на адрес инструкции в сегменте)

Инструкции в ассемблере Intel имеют следующий формат:
<метка>: <инструкция>, <операнд1>, <операнд2>, <операнд3>
Операндов может быть от одного до трёх.
В логических и арифметических операциях <операнд1> служит ещё и местом назначения результата.

Архитектуре IA-32 предшествовали 16-битные процессоры 8086 (16-битные регистры, 16-битная шина данных, 20-битная шина адреса, адресное пространство 1Мб) 
и 8088 (то же, что и 8086, только шина данных была 8-битная). 8086 мог адресовать 1Мб памяти, благодаря 20-битной шине адреса.
Сегментация пришла в архитектуру IA-32 из процессоров 8086 и 8088: сегментные регистры (CS/DS/ES/SS) были размером 16 бит и хранили в себе указатель 
на соответствующий сегмент данных размером до 64Кб. Эти 4 регистра вместе могли адресовать 256Кб памяти.
В архитектуре IA-32 были обавлены ещё 2 сегментных регистра: FS и GS. Разрядность сегоментных регистров так и осталась 16-битной.

С появлением процессора 80286 в архитектуру IA-32 добавился защищённый режим. Этот режим использует сегментные регистры для хранения селектора 
дескриптора – 8-байтовой структуры, которая описывает блоки данных в памяти.

80386 стал первым 32-битным процессором Intel. Регистры общего назначения были расширены до 32 бит, но имели обратную совместимость с 16 битами.
Регистры адресации 32-битные. Кроме того, этот процессор имеет дополнительный режим "виртуального 8086" для более эффективной работы программ,
скомпилированных под 8086 и 8088. Адресная шина была расширена до 32 бит, что позволяло адресовать 4Гб памяти. Процессор поддерживал сегментную,
плоскую модели памяти и страничную модели памяти (страницы были фиксированной ширины 4Кб).
</p>

<p>IA-32 поддерживает следующие режимы:</p>
<ul>
    <li><strong>Защищённый режим (protected mode)</strong> — стандартный режим работы процессора. Процессор можно переключить в этот режим только из режима реальных адресов. Имеет подрежим <strong>виртуального 8086</strong>, который позволяет запускать 16-битные программы (этот подрежим активируется отдельно для каждого 16-битного процесса).</li>
    <li><strong>Режим реальных адресов (real-address mode)</strong> — это режим, который был стандартным для 16-битных процессоров 8086/8088. В этом режиме компьютер работает при включении и перезагрузке. Из него можно переклчиться в защищённый режим. Максимальный объём физической памяти, который может адресовать компьютер в этом режиме, – 2<sup>20</sup> байт (1Мб). <u>Программы имеют доступ к любой части оперативной памяти.</u> Этот режим не предоставляет защиту памяти, многозадачность и уровни привелегий. В этом режиме используется "Модель памяти режима реальных адресов". В этом режиме работает MS-DOS.</li>
    <li><strong>Режим управления системой (system management mode)</strong> — режим управления системным функционалом (управление энергопотреблением или системной безопаснойстью). Процессор переходит  этот режим, когда получает прерывание SMI#.</li>
</ul>
<p>Архитектура Intel 64 добавляет режим IA-32e, который имеет следующие подрежимы:</p>
<ul>
    <li><strong>Режим совместимости (compatibility mode)</strong> — режим, позволяющий 16- и 32-битным приложениям работать на 64-битной ОС. Этот режим очень похож на 32-битный защищённый режим: приложения получают доступ только к первым 4Гб адресного пространства. Этот режим использует 16- и 32-битные адреса и операнды.</li>
    <li><strong>64-битный режим</strong> — режим, позволяющий запускать 64-битные приложения. В этом режиме увеличено количество регистров общего назначения и SIMD-регистров с 8 до 16 штук. регистры общего назначения расширены до 64 бит. Стандартный размер адреса 64 бита, а размер операнда – 32 бита. Размер операнда может быть изменён посредством опкода REX.</li>
</ul>
<img src="images/arch/processor_modes.png" style="max-width: 400px; display: block;">  
<img src="images/arch/ia32_32bit_scheme.png" style="max-width: 100%; display: block;">
<h2>Организация памяти</h2>
<p><strong>Физическая память</strong> — это настоящая память, расположенная на материнской плате. Эта память состоит из последовательности байт. Каждый байт имеет свой постоянный адрес в виде обычного числа. Этот адрес называется физическим. Программы не имеют прямого доступа к физической памяти. Для них память представлена в виде специальных абстракций (моделей) со своей адресацией и особенностями. В основе этих моделей лежат такие алгоритмы как сегментация, страничная организация и тд. В 32-битной архитектуре IA-32 есть следующие модели памяти:</p>
<ul>
    <li>
        __поддерживается с процессора 80386__
        <strong>Плоская модель памяти (flat memory model)</strong> — память предоставляется программе в виде одного последовательного адресного пространства, которое называется <strong>линейным адресным пространством</strong>, а отдельный адрес в нём называется <strong>линейным адресом</strong>. Стек, код и данные программы расположены вместе в этом адресном пространстве. В 32-битной архитектуре линейное адресное пространство может иметь до 2<sup>32</sup> адресов.
    </li>
    <li>
        __является стандартной для 32-битной архитектуры IA-32, но её можно отключить__
        <strong>Сегментная модель памяти (segmented memory model)</strong> — память предоставляется программе в виде нескольких независимых адресных пространств – сегментов. Для каждого компонента программы (код, стек, данные) выделен свой <u>отдельный</u> сегмент. Для получения доступа к отдельному байту внутри сегмента, программа использует <strong>логический адрес</strong>, который состоит из двух компонентов: <strong>селектор сегмента</strong> и <strong>сдвиг внутри сегмента</strong>. Внутри сегмента адресация начинается с нуля. Логический адрес часто называется дальним указателем (far pointer). В 32-битной архитектуре программы могут адресовать до 16383 сегментов разных типов и размеров, а размер сегмента может достигать 2<sup>32</sup> байт (4Гб). Внутри системы все логические адреса отображены на физические, поэтому для доступа к данным в физической памяти процессор преобразовывает логический адрес в физический.
    </li>
    <li>
        __использовалась в 16-битном 8086 и в режиме "виртуальный 8086"__
        <strong>Модель памяти режима реальных адресов (Real-address mode memory model)</strong> — это модель памяти, которая используется в процессорах IA-32 для совместимости с 16-битовыми программами, написанными для процессора 8086. Эта модель представляет собой отдельный вариант сегментной модели, в которой всё линейное пространство памяти разделено на сегменты размером до 64Кб. Т. к. процессор 8086 использует 20-битную адресацию, максимальный размер линейного физического адресного пространства ограничен 2<sup>20</sup> байтами (1Мб).
    </li>
</ul>
<img src="images/arch/addresses_types.png" style="max-width: 100%; display: block;">
<img src="images/arch/flat_memory_model_of_program.png" style="max-width: 100%; display: block;">
<img src="images/arch/segs_paging.png" style="max-width: 100%; display: block;">
<img src="images/arch/segments_to_physical_memory.jpg" style="max-width: 100%; display: block;">
<img src="images/arch/Endians.png">
<img src="images/arch/os_abstractions.png">
<img src="images/arch/unix_virtual_address_space.png">
<img src="images/arch/memory_hierarchy.png">
<img src="images/arch/computer_as_layers.png">
<img src="images/arch/multicore_cpu.png">
<img src="images/arch/context_switch.png">
<img src="images/arch/little-endian_IA-32.png">
<img src="images/arch/general_purpose_registers.png">
---------<br>
Процессеор, не поддерживающий Intel 64, может адресовать 64Гб (2 ^ 36 - 1 байт).

Процессы не имеют прямого доступа к физической памяти, они работают с виртуальной памятью – абстракцией, созданной с помощью 
механизмов сегментации и/или разделения на страницы.

- Современные операционные системы используют плоскую модель памяти вместо сегментной.
  В плоской модели памяти во все сегментные регистры ОС записывает один и тот же адрес, указывающий на базу адресного пространства.
  В совсременных ОС используется страничная организация памяти.
- Линейный адрес с физическим соотносит ОС.
- сегментация используется в 16-битном режиме и в режиме виртуального 8086 (Модель памяти режима реальных адресов)
- В плоской модели памяти сегмент всего один - вся память. Поскольку код, данные и стек программы хранится в этом одном сегменте, значение в сегментных регистрах никогда не нужно изменять. 
- в защищённом режиме сегментация другая (Сегментная модель памяти)
- 1985: 80386 - первый 32-битный процессор архитектуры IA-32
  32-битная шина адреса => адресное пространство 2 ^ 32 байт (4Гб)
  32-битная шина данных
  введены страницы, виртуальная память и плоская модель памяти
- 1993: Pentium/80586
  32-битная шина адреса
  64-битная шина данных
- 1995: Pentium Pro
  36-битная шина адреса => адресное пространство 2 ^ 36 байт (64Гб)
- 2004: EM64T/AMD64/Intel 64 - 64-битная архитектура-надстройка над IA-32.
  Количество регистров общего назначения увеличено до 16
  Сами регистры общего назначения расширены до 64 бит
  64-битные указатели (виртуальные адреса) 
  Плоское виртуальное адресное пространство
  Физическое адресное пространство расширено до 2 ^ 40 байт (1Тб)
- Для 16-битных процессоров плоская модель памяти позволяет адресовать 64 кБ оперативной памяти; для 32-битных процессоров 4 ГБ, для 64-битных — до 16 эксабайт (для amd64 размер ограничен 256 ТБ [1] ).
- Линейный адрес совпадает с физическим, когда отключен механизм страничной организации памяти.
  Если механизм страничной организации включен, то линейный адрес преобразуется в физический посредством специального устройства MMU.
- Segmentation and paging can be combined so that a virtual address space consists of multiple segments, and each segment consists of multiple pages. (Memory.pdf)
- Различные ОС могут выбирать разные модели памяти, а также включать и отклчать сегментирование и страничный механизм.
- В 64-битовом режиме сегментация почти полностью отключена, что образует одно плоское линейное 64-битное адресное пространство.
  В этом режиме процессор указывает 0 в качестве базы сегментов (регистры CS, SS, DS, ES), что делает эффективный адрес равным линейному.


https://slideplayer.com/slide/4929795/
https://ru.wikipedia.org/wiki/Плоская_модель_памяти

--------------

- Чтобы поменьше задействовать стек (иными словами, поменьше обращаться к кэшу и внешней памяти), уже давно имелся довольно популярный метод передачи аргументов функции через регистры (fastcall)

<pre>
    Hyper Threading
    Параллелизм на уровне команд
    Параллелизм на уровне процессов
    Параллелизм на уровне потоков
    Параллелизм на уровне задач
    Параллелизм на уровне битов
    Порты ввода-вывода
    Анатомия программы в памяти на Linux/Windows/Xbox/PS4

    Стек:
    - https://www.youtube.com/watch?v=Q2sFmqvpBe0
    - https://ru.wikipedia.org/wiki/Стек_вызовов
    - https://habr.com/company/smart_soft/blog/234239/ 

    В памяти:
    - Сегменты data, text (код программы), constants (CPP), BSS (not inited static vars)

    Эмуляторы:
    - MINIX 3
    - NachOS 3/4
    - IJVM



    // -------------------

    Слово - WORD - фундаментальный параметр системы.
    Сначала "слова" были 16-битными.
    Затем стали 32-битными с появлением процессоров IA32.
    А затем они стали 64-битными в архитектуре x86-64.
    Слова состоят из последовательности байт, байты состоят из последовательности бит. 
    Большинство систем испольуют 4-байтовые или 8-байтовые слова. 

    Каждое внешнее устройство подключено к шине ввода/вывода (I/O Bus) посредством
    контроллера или адаптера. Контроллер - это набор чипов на сомом устройстве или 
    материнской плате, а адаптер - это плата, которая вставляется в слот на материнской
    плате. Контроллеры и адаптеры используются для обмена данными между шиной ввода-вывода
    и самим устройством.

    The main    memory  is  a   temporary   storage device  that    holds   both    a
    program and the data    it  manipulates while   the processor   is  executing   the
    program. Physically, main    memory  consists    of  a   collection  of  dynamic
    random  access  memory(DRAM)    chips. Logically,    memory  is  organized   as
    a   linear  array   of  bytes,  each    with    its own unique  address (array  index)
    starting    at  zero.

    At  CPU's core    is
    a   word-size   storage device  (or register)   called  the program counter (PC).
    At  any point   in  time,   the PC  points  at  (contains   the address of) some
    machine-language    instruction in  main    memory. Processor   repeatedly  executes    
    the instruction pointed at  by  the program counter and updates the program counter to  
    point   to the next    instruction.    
    Instructions    execute in  strict  sequence,   and
    executing   a   single  instruction involves    performing  a   series  of  steps.  The
    processor   reads   the instruction from    memory  pointed at  by  the program
    counter (PC),   interprets  the bits    in  the instruction,    performs    some    simple
    operation   dictated    by  the instruction,    and then    updates the PC  to  point   to
    the next    instruction,    which   may or  may not be  contiguous  in  memory  to
    the instruction that    was just    executed.
    There   are only    a   few of  these   simple  operations, and they    revolve around
    main    memory, the register    file,   and the arithmetic/logic    unit    (ALU).  The
    register    file    is  a   small   storage device  that    consists    of  a   collection  of  word-
    size    registers,  each    with    its own unique  name.   The ALU computes    new
    data    and address values. Here are some    examples    of  the simple
    operations  that    the CPU might   carry   out at  the request of  an  instruction:
    - Load:   Copy    a   byte    or  a   word    from    main    memory  into    a   register,
    overwriting the previous    contents    of  the register.
    - Store:  Copy    a   byte    or  a   word    from    a   register    to  a   location    in  main
    memory, overwriting the previous    contents    of  that    location.
    - Operate:    Copy    the contents    of  two registers   to  the ALU,    perform an
    arithmetic  operation   on  the two words,  and store   the result  in  a
    register,   overwriting the previous    contents    of  that    register.
    - Jump:   Extract a   word    from    the instruction itself  and copy    that    word
    into    the program counter (PC),   overwriting the previous    value   of  the
    PC.

    Using   a   technique   known   as  direct  memory  access  (DMA),    
    the data    travel  directly    from    disk    to  main    memory, without
    passing through the processor.  


    ! Чем больше память, тем медленее доступ к ней.
    Кэш процессора хранит данные, которые понадобятся в ближайшем будущем.
    Кэши ЦП - static  random  access  memory  (SRAM)
    Оперативная память - collection  of  dynamic random  access  memory(DRAM)
    Как правило, процессор имеет 3 уровня кэшей: L1, L2 и L3. Чем больше цифра,
    тем больше память и быстрее доступ от данного уровня к RAM, но медленее к 
    процессору.


    Иерархия памяти (чем выше, тем паять быстрее, меньше и дороже):
    L0: Регистры                          - содержат слова, принятые из кэша
    L1: SRAM-кэш                          - содержит данные, принятые из L2-кэша
    L2: SRAM-кэш                          - содержит данные, принятые из L3-кэша
    L3: SRAM-кэш                          - содержит данные, принятые из оперативной памяти
    L4: DRAM-память (оперативная память)  - содержит данные, принятые с I/O-устройств
    L5: Локальные диски (HDD/SSD)
    L6: Удалённые хранилища


    ОС - это ПО, которое лежит между прикладным ПО и аппаратным обеспечением. 
    Таким образом, ОС существует для двух целей:
    1. Защитить оборудование от неправильного использования прикладным ПО.
    2. Предоставить прикладному ПО простой API для взаимодействия с оборудованием.

    +-------------------------++----------
    |      Applications       ||
    +-------------------------||  SOFTWARE
    |           OS            ||
    +-----+-----+-------------||----------
    | CPU | RAM | I/O Devices ||  HARDWARE
    +-----+-----+-------------++----------


    ОС представляет физические устройства в виде следующих виртуальных/программных абстракций:
    - Файлы представляют собой программное представление физических I/O-устройств.
      Файл - это последовательность байт.
      Каждое I/O-устройство (клавиатура, мышь, монитор, диск и тд.) представлены в системе в виде файлов.
      Другие устройста и ОС, подключённое к данной ОС по сети, тоже являются I/O-устройствами.
    - Виртуальная память представляет собой совокупность I/O-устройств и RAM.
    - Процессы представляют собой совокупность I/O-устройств, RAM и CPU.

            Processes          
    +-------------------------+
    |        Virtual Memory   |
    |     +-------------------+
    |     |          Files    |
    |     |     +-------------+
    |     |     |             |
    |-----|-----|-------------|
    | CPU | RAM | I/O Devices |
    +-----+-----+-------------+


    Процесс - это контейнер, который изолирует одну программу и её данные от других.
    Инструкции в каждом процессе выполняются последовательно одна за другой, но сами процессы
    выполняются параллельно: ЦП быстро переключается между процессами и в каждый момент времени 
    даёт доступ ко всем устройствам компьютера только активному процессу. Даже одноядерный 
    процессор это может. Это называется "переключением контекста". Контекст включает в себя
    содержимое регистра PC, регистров процессора и данные этого процесса в оперативной памяти.

    ИЛИ: когда в командной строке мы запускаем какой-то процесс, то ОС сохраняет контекст 
    командной строки, создаёт новый процесс с контекстом для вызванной программы и выполняет её.
    Когда эта программа завершится, ОС переключится обратно на контекст командной строки и вернёт 
    управление ей.

    За переключение контекста и за некоторые другие задачи отвечает часть операционной системы,
    которая называется "ядро" (kernel), оно всегда присутствует в памяти. Чтобы запросить что-то
    у ядра, приложение должно сделать системный вызов (system call).
    Пример: APP --(read)--> KERNEL(reading) --(data)--> APP

    Самый простой процесс может иметь только один поток выполнения, но многие имеют несколько.
    Потоки одного процесса выполняются в контексте данного процесса.
    Обычно многопоточность более эффективна, чем многопроцессность.

    Виртуальная память создаёт для каждого процесса своё однородное "виртуальное адресное пространство".

    --

    Закон Амдала: чтобы значительно увеличить производительность системы, нужно увеличить 
    производительность значительной части системы.
    Формула по которой определяется увеличение производительность всей системы:
    S = 1 / ((1 - a) + a / k)
    a - это часть времени, которую занимает выполнение какой-то функции (например, 0.6 (60 % от всей системы))
    k - это во сколько раз увеличена производительность этой функции (например, в 3 раза)

    Сравнить производительность можно двумя способами:
    - Коэффициентом: Told / Tnew
    - Процентами: 100 * (Told - Tnew) / Tnew
    Коэффициентом выражать удобнее, потому что он более очевидный.
    Пример:
    20 / 9 = 122             (производительность выросла на 122 процента)
    100 * (20 - 9) / 9 = 2.2 (производительность выросла в 2.2 раза)

    --

    Concurrency - способность вполнять несколько задач одновременно.
    Parallelism - способ реализации Concurrency.

    Многопроцессорные системы бывают двух видов:
    - Multicore - имеют несколько ядер (CPU)
    - Hyper-threaded

    Многоядерный процессор состояит из нескольких физических ядер (CPU).
    Гипертрединг - техника, позволяющая каждому CPU иметь несколько управлений потока:
    каждый CPU при этом может иметь по несколько PC и register files, но одно устройство
    для вычислений с правающей точкой.

    -- 

    Если x = 2 ^ n, то число x в двоичном представлении выглядит как 1 с n нулями справа.
    Если n представить в виде i + 4j, то число x в hex-виде будет представлять собой 1, 2, 4 или 8 (если i = 0, 1, 2 или 3 соответственно), с j нулями справа.
    Например: x = 2 ^ 7 = 128(10) = 10000000(2) = 0x80 (т. к. 3 + 4 * 1)

    --

    Адрес в виртуальном адресном пространстве выражаются одним словом (WORD), соответственно
    максимальный адрес памяти в виртуальном адресном пространстве 2 ^ n, где n - количество 
    бит в слове.
    В последние годы основным размером слова в новых системах становтся 64-битные свлова
    в замен 32-битных.
    32-битное слово позволяет адресовать лишь 4Gb виртуальной памяти.
    64-битное слово позволяет адресовать 16Eb виртуальной памяти.
    64-битные системы имеют обратную совместимость с 32-битными.

    Тип char не обязательно может быть signed, поэтому нужно использовать signed char.
    int32_t/uint32_t всегда имеет одинаковую ширину 4 байта.
    int64_t/uint64_t всегда имеет одинаковую ширину 8 байт.
    ? указатели имеют ширину слова, соответствующую системе и режиму компилирования (32/64 бит)
    В стандарте C указаны лишь нижние граница размера типа.

    Big Endian - порядок байт, как в математике.
    Little Endian - обратный порядок байт.
    Пример: 
    Адреса:        0  1  2  3
                   ---------->
    Original Data: A0 5B 33 FF
                   ---------->
    Big Endian:    A0 5B 33 FF (например, в сетях TCP/IP)
                   <----------
    Little Endian: FF 33 5B A0 (например, в архитектуре x86)
    Little Endian эффективнее, потому что память считывается с младших разрядов и не нужно тратить ресурсы на чтение лишних старших нулей.
    Большинство архитектура Intel (x86) используют порядок Little Endian.

    --

    Обмен значениями двух переменных:
    y = x ^ y;
    x = x ^ y;
    y = x ^ y;

    --

    Функции кодирования чисел:
    - B2U (Binary to unsigned) - биективная функция (взаимно-однозначное отображение), которая ставит 
      в соответствие каждой последовательности бит уникальное целочиесленное значение. 
      По сути, просто интерперетирует последовательность бит как целое беззнаковое число.
    - B2T (Two's-Complement/Дополнительный код) - биективная функция (взаимно-однозначное отображение).
      Наиболее распространённый способ представления отрицательных целых чисел.
      Позволяет заменить операцию вычитания на операцию сложения и сделать операции сложения и вычитания одинаковыми для знаковых и беззнаковых чисел, чем упрощает архитектуру ЭВМ.
      Представляет самый значимый бит как знак числа (знаковый бит).
      Единственный способ, у которого ноль не имеет знака.
      ? Устаревший способ кодирования чисел.
    - B2O (Ones' complement/Обратный код) - альтернатива для B2T.
      Сложение и вычитание выполняются по-разному.
      В этой кодировке есть -0 и +0.
    - B2S (Sign-magnitude/Прямой код) - альтернатива для B2T.
      Сложение и вычитание выполняются по-разному.
      В этой кодировке есть -0 и +0.
    - T2U (Two's-Complement -> Unsigned).
      T2U(x) = | x        , если x >= 0 
               | x + 2 ^ w, если x < 0
      (w - количество бит)
    - U2T (Unsigned -> Two's-Complement).
      U2T(x) = | u        , если u <= 0 
               | u - 2 ^ w, если u > 0

    Прямой код - базовое представление числа: неотрицательные числа выводятся как есть, а положительные в знаковом бите имеют 1.
    Обратный код - инвертируются все биты прямого кода, кроме знакового бита.
    Дополнительный код - к обратному коду добавляется единица.

    Положительные числа в двоичном коде вне зависимости от способа представления (прямой, обратный или дополнительный коды) имеют одинаковый вид.
    - Прямой код: чаще всего используется для представления неотрицательных чисел.
      В signed-режиме самый старший бит означает знак: 0 - это +, а 1 - это -.
      Минусы:
      - Сложности с арифметикой
      - Два нуля: +0 и -0
    - Обратный код: 
      В signed-режиме самый старший бит означает знак: 0 - это +, а 1 - это -.
      Когда число отрицательное (знаковый бит равен 1), значимые бмты инвертируются. 
      То есть, чтобы сменить знак числа в обратном коде, достаточно инвертировать все биты.
      Сложение: сложить биты столбиком. Если образовался лишний (9й) разряд числа, нужно его прибавить к полученному результату.

    ! C/C++ использует дополнительный код на большинстве машин, хотя стандарт не говорит какой код использовать.
    При преобразовании signed <-> unsigned биты не меняются, меняется лишь их интерпретация.

    ? Сравнение заковых с беззнаковыми.

    При расширении дополнительного кода (например, short -> int), в модуль нисла дублируется знаковый разряд.

    В Java:
    - Числа только со знаком.
    - Они реализованы посредством дополнительного кода.
    - >> - арифметический сдвиг, >>> - логический сдвиг.

    --

    - Регистр PC ещё называется %rip. он указывает на адрес следующей инструкции.
    - Файл регистров состоит из 16 именованных 64-битных регистров общего назначения для хранения целых чисел и указателей.
    - Регистры условного кода хранят состояние последних выполненных инструкций.
    - Набор векторных регистров хранит один или более целочисленных или дробных значений.

    Архитектура Intel под WORD подразумевает 16 бит, под DWORD 32 бита, а под QWORD 64 бита.
    Указатели хранятся в QWORD.

    Суффиксы команд:
    - -w - WORD (16 бит)
    - -l - DWORD (32 бита)
    - -q - QWORD (64 бита)

    Регистр IP/EIP/RIP указывает на адрес следующей инструкции. READ ONLY!
    Когда приходит время выполнения следующей инструкции, процессор обращается по адресу,
    хранящемуся в RIP, получает новую команду, определяет её размер в байтах и увеличивает
    значение в RIP на это количество байт.

    Процессор работает в трёх режимах:
    - Реальный режим - режим, в котором компьютер работает во время запуска.
      В этом режиме нет виртуального адресного пространства и все адреса памяти являются физическими.
      Стандартным размером данных в этом режиме является WORD (16 бит).
    - Защищённый режим/Protected/Legacy mode/IA-32 - 32-битный режим. Стандартный режим для x86.
      В этом режиме физическое адресное пространство ограничено 4Гб.
      Стандартным размером данных в этом режиме является DWORD (32 бита).
      В этот режим можно перейти только из реального режима.
      Включает в себя режим обратной совместимости с 16-битовым режимом.
    - long Mode/AMD64/IA-32e - 64-битный режим. Похож на защищённый режим.
      В этом режиме физическое адресное пространство ограничено 2 ^ 52 байтами.
      Виртуальное адресное пространство ограничено 2 ^ 48 байтами.
      Адрес памяти всегда 8-байтовый.
      В этот режим можно перейти только из защищённого режима.
      Включает в себя режим обратной совместимости с 32-битовым режимом.

    В  защищённом  режиме,  в  режиме  реальных  адресов  и  режиме  совместимости 
    доступны следующие регистры:
     ● регистры  общего  назначения:  32-разрядные  EAX,  EBX,  ECX,  EDX,  ESI, 
    EDI, ESP, EBP; 16-разрядные AX, BX, CX, DX, SI, DI, SP, BP (они являются 
    младшими  частями  32-разрядных  регистров);  8-битные  регистры  AH,  BH, 
    CH, DH и AL, BL, CL, DL (старшие и младшие части 16-битных регистров 
    соответственно);
     ● 32-разрядный EIP (IP в реальном режиме) - указатель инструкции;
     ● 16-разрядные сегментные регистры: CS, DS, SS, ES, FS, GS;
     ● 32-разрядный регистр флагов - EFLAGS;
     ● 80-битные регистры математического сопроцессора ST0-ST7 и др.;
     ● 64-битные MMX-регистры - MM0 - MM7;
     ● 128-разрядные XMM-регистры - XMM0 - XMM7 и 32-битный MXCSR;
     ● 32-разрядные регистры управления CR0 - CR4; регистры-указатели систем-
    ных таблиц GDTR, LDTR, IDTR и регистр задачи TR;
     ● 32-разрядные регистры отладки - DR0 - DR3, DR6, DR7;
     ● MSR-регистры.

    В режиме реальных адресов доступны не все вышеуказанные регистры, но реги-
    стры  управления  доступны  в  любом  случае.  В  режиме  реальных  адресов  нельзя 
    использовать некоторые регистры размером более 16 бит.
    При переключении процессора в 64-разрядный режим программе доступны сле-
    дующие регистры:
     ● Регистры общего назначения: 64-разрядные RAX, RBX, RCX, RDX, RSI, RDI, 
    RSP, RBP и R8, R9,R15; 32-разрядные EAX, EBX, ECX, EDX, ESI, EDI, ESP, 
    EBP,  R8D  -  R15D  (являются  младшими  частями  64-разрядных  регистров); 
    16-разрядные AX, BX, CX, DX, SI, DI, SP, BP, R8W - R15W (являются млад-
    шими частями 32-разрядных регистров); 8-битаые регистры AH, BH, CH, DH 
    и AL, BL, CL, DL, SIL, DIL, SPL, BPL, R8L - R15L (старшие и младшие части 
    16-битных регистров соответственно);
     ● 64-разрядный RIP - указатель инструкции;
     ● 16-разрядные сегментные регистры: CS, DS, SS, ES, FS, GS;
     ● 64-разрядный регистр флагов - RFLAGS;
     ● 80-битные регистры математического сопроцессора ST0 - ST7;
     ● 64-битные MMX-регистры (MM0 - MM7);
     ● 128-разрядные XMM-регистры - XMM0 - XMM15 и 32-битный MXCSR;
     ● 64-разрядные  регистры  управления  CR0  -  CR4  и  CR8;  регистры-указатели 
    системных таблиц GDTR, LDTR, IDTR и регистр задачи TR;
     ● 64-разрядные регистры отладки - DR0 - DR3, DR6, DR7;
     ● MSR-регистры.

    --

    В 70х года вся память адресовалась 16 битами, благодаря чему можно было адресовать лишь 64К памяти.
    С увеличением памяти понадобилось улучшить механизм адресации, для этого память разделили на сегменты 
    по 64К, добавили 16-битовые сегментные регистры, которые содержали номер сегмента, а адресация памяти
    стала составной: <номер_сегмента>:<смещение_внутри_сегмента>. Затем с появлением процессора 80386 в свет
    вышла полноценная 32-битовая архитетура, которая позволяла линейным способом адресовать до 4Гб памяти
    без необходимости делить память на сегменты. Поэтому основной ролью сегментных регистров вместо адресации 
    стала защита доступа к определённым сегинтам памяти. А с появлением 64-битной архитектуры (long mode) 
    роль сегментных регистров вообще была сведена к минимуму. Тем не менее, для обратной совсместимости
    адресация памяти по-прежнему имеет вид <сегмент>:<смещение>.

    Адресация памяти бывает трёх типов:
    - Физические адреса - реальный "железный" адрес памяти, который выставляется на шину памяти.
    - Логические адреса - это адрес вида <сегмент>:<смещение_внутри_сегмента>. Сегмент всегда 16-битный.
    - Линейные/виртуальные адреса - это адрес, который получается в резултате преобразования логического адреса (<сегмент> + <смещение_внутри_сегмента>) в число.
      Способ преобразования зависит от режима, в котором работает процессор:
      - В режиме ральных адресов этот адрес сразу выставляется на шину адреса.
      - В режимах 32 и 64:
        - Если включен режим трансляции страниц, то этот адрес называется виртуальным и определённым образом,
          зависящем от ОС, он транслируется в физический адрес и выставляется на шину памяти.
        - Если режим трансляции страниц не включен, то этот адрес становится физическим и выставляется на шину памяти.

    Команды:
    - MOV <куда>, <отуда> - положить данные
    - ADD <куда>, <отуда> - сложить <куда> с <отуда> и положить результат в <куда>
    - SUB <куда>, <отуда> - вычесть <куда> из <отуда> и положить результат в <куда>
    - AND <куда>, <отуда> - побитовое AND <куда> с <отуда> и положить результат в <куда>
    - OR <куда>, <отуда> - побитовое OR <куда> с <отуда> и положить результат в <куда>
    - NOT <куда> - инверсия битов и положить результат в <куда>
    - XOR <куда>, <отуда> - побитовое XOR <куда> с <отуда> и положить результат в <куда>
    - SHL <куда>, <количество_битов> - логический сдвиг влево
    - SHR <куда>, <количество_битов> - логический сдвиг вправо
    - SAL <куда>, <количество_битов> - арифметический сдвиг влево
    - SAR <куда>, <количество_битов> - арифметический сдвиг вправо
    - ROL <куда>, <количество_битов> - циклический сдвиг влево
    - ROR <куда>, <количество_битов> - циклический сдвиг вправо
    - RCL <куда>, <количество_битов> - циклический сдвиг влево через флаг CE
    - RCR <куда>, <количество_битов> - циклический сдвиг вправо через флаг CF
    - CLC - сброс флага переноса (CF=0)
    - CLD - сброс флага направления (DF=0)
    - CLI - сброс флага разрешения прерываний (IF=0)
    - LAHF - сохранение в регистре AH содержимого первого байта регистра флагов (флаги SF, ZF, AF, PF, CF)
    - SAHF - сохранение регистра AH в первый байт регистра флагов (флаги SF, ZF, AF, PF, CF); биты с зарезервированными значениями игнорируются.
    - STC - установка флага переноса в единицу (CF-1)
    - STD - установка флага направления в единицу (DF-1)
    - STI - разрешения прерываний (IF=1)
    - PUSH <операнд> - затолкнуть значение <операнд> на вершину стека и вычесть из регистра ESP количество бит, равное размеру <операнд>
    - POP <операнд> - вытолкнуть со стека значение и записать его в <операнд>, увеличить значение в регистре ESP на количество бит, равное размеру <операнд>
    - JMP <адрес> - безусловный переход по адресу (просто изменяет адрес следующей команды в регистре IP/EIP/RIP)
    - CALL <адрес> - кладёт на верхушку стека адрес следующей строки, переходит к выполнение кода по адресу <адрес>
    - RET - берёт с верхушки стека адрес и переходит к нему (удобно использовать в паре с CALL)
    - RETN <сколько_байт_вытолкнуть_перед_возвратом>
    - RETF - межсегментный (дальний) возврат. Может принимать такой же аргумент, как RETN
      Если передача (возврат) управления осуществляется на другой уровень привилегий, то происходит переключение стека.
    - Команды  условного  перехода  чаще  всего  используются  вместе  с  инструкциями 
      сравнения. Чаще всего используемая инструкция сравнения - это команда CMP. Она 
      сравнивает операнды и изменяет регистр флагов.
      CMP <операнд1>, <операнд2> - сравнивает 2 операнда
      В качестве первого операнда может выступать регистр или значение памяти любого 
      размера (1, 2, 4, 8 байт). В качестве второго операнда может выступать регистр, зна-
      чение памяти или непосредственное значение. Значение не может быть 64-битным. 
      Одновременно двух значений памяти быть не может. Если 32-битное значение срав-
      нивается с 64-битным, то оно расширяется нулями.
      Условные переходы после выполнения команды CMP x, y:
      - JA                    X > Y    CF = 0 & ZF = 0
      - JAE                   X >= Y   CF = 0
      - JB                    X < Y    CF = 1
      - JBE                   X < Y    CF = 1 or ZF = 1
      - JC                             CF = 1
      - JCXZ                           CX = 0
      - JE (то же, что и JZ)  X = Y    ZF = 1
      - JG                    X > Y    ZF = 0 & SF = OF
      - JGE                   X >= Y   SF = OF
      - JL                    X < Y    SF! = OF
      - JLE                   X <= Y   ZF = 1 or SF! = OF
      - JNA                   X <= Y   CF= 1 or ZF = 1
      - JNAE                  X < Y    CF= 1
      - JNB                   X >= Y   CF = 0
      - JNBE                  X > Y    CF=1 & ZF = 0
      - JNC                            CF = 0
      - JNE                   X! = Y   ZF = 0
      - JNG                   X <= Y   ZF = 1 or SF! = OF
      - JNGE                  X < Y    SF! = OF
      - JNL                   X >= Y   SF = OF
      - JNLE                  X > Y    ZF = 0 & SF = OF
      - JNO                            OF = 0
      - JNP                            PF = 0
      - JNS                            SF = 0
      - JNZ                   X! = Y   ZF = 0
      - JO                             OF = 1
      - JP                             PF = 1
      - JPE                            PF = 1
      - JPO                            PF = 0
      - JS                             SF = 1
      - JZ                    X = Y    ZF= 1
    - BT <операнд>, <номер_бита> - заносит значение указанного бита во флаг CF в регистре флагов
    - BTC <операнд>, <номер_бита> - заносит значение указанного бита во флаг CF и производит его инвертирование в операнде
    - BTR <операнд>, <номер_бита> - заносит значение указанного бита во флаг CF и обнуляет его в операнде
    - BTS <операнд>, <номер_бита> - заносит значение указанного бита во флаг CF и заносит в указанный бит в операнде единицу
    - IN <регистр>, <номер_порта> - копирование значения из I/O-порта в регистр
    - OUT <номер_порта>, <регистр> - копирование значения из регистра в I/O-порт

    Создание переменной:
    - DB (1 бит)
    - DW, DU (2 бита)
    - DD (4 бита)
    - DF, DP (6 бит)
    - DQ (8 бит)
    - DT (10 бит)

    Примеры:
    db 67h
    db 5dh, 0f6h
    db "z"
    db "w", "k", "y"
    dw 8a34h, 0c51h, 8bh
    du 9e3ah, 07deh
    dw "WE"
    dd 01F243D5Eh
    dd "WEGa"
    dq 1122334455667788h

    dup - дублирует значение переменной несколько раз

    Примеры:
    db 7 dup (1Ah)
    db 6 dup (45h, 0A3h, 90h)
    dd 13 dup (0A713E445h)
    dd 9 dup (0A713E445h, 0F8D3E412h)
    dw 5 dup (?)

    ? - означает, что выделенная память не инициализируется значением

    Метка - способ дать имя какой-то области кода или данным
    Способы создания меток:
    - <имя_метки>: <инструкция_или_данные>
      Обычно используется для пометки кода.
      Пример: metka1: dd "hello"
    - <имя_метки> <директива_объявления_данных>
      Используется для пометки данных.
      Пример: metka1 dd "hello"
    - label <имя_метки> <размер_оператора> at <память_на_которую_ссылается_метка>
      Пример: label metka3 dword at metka_pamyati

    $ - метка текущей строки

    globmetka - глобальная метка
        .locmetka - локальная метка
        mov word [globmetka.locmetka], cx - обращение к локальной метке

    param dd ? - метка param
    virtual at param - начало разделения 4-байтовой метки
        LowPart dw ? - младшие 2 байта метки
        HighPart dw ? - старшие 2 байта метки
    end virtual - конец разделения метки
    Обрщение к метке: param.LowPart / param.HighPart

    Метки бывают ближние (не дальше 127 байт от текущего места) и дальние.

    Метки бывают безымянными: @@:
    К таким меткам можно выполнять переход:
    Ja @f - переход к ближайшей безымянной метке выше
    Jz @b - переход к ближайшей безымянной метке ниже

    --

    В реальном режиме память делится на сегменты по 64К.
    физический_адрес = сегмент * 10h + смещение

    В защищённом режиме память делится на сегменты от 0 до 4Гб.
    логический_адрес = описание_сегмента + адрес_в_сегменте
    описание_сегмента представляется селектором (в отличие от реального режима, где сегмент указывается 16-битным числом)
    Селектор сегмента имеет размер 16 бит, но в отличие от 16-битового номера сегмента в реальном режиме, здесь он означает совсем дургое.
    Структура селектора:
    15         3  2   1   0
     +--------------------+   TI - какую таблицу дескрипторов использовать (1 - глобальную, 0 - локальную)
     | Index    | TI | RPL|   Index - индекс дескриптора в таблице дескрипторов
     +--------------------+   RPL - уровень привелегий
    Селектор указывает на дескриптор сегмента в таблице дескрипторов.
    Дескриптор - это 8-байтовая (64-битовая) структура данных, которая описывает сегмент.
    Все объекты в памяти, которыми оперирует ЦП, описываются дескрипторами.
    Сегменты памяти описываются сегментными регистрами.
    GDT - глобальная дескрипторная таблица

    ----

    1. Реальный режим / Real-address mode / 16-битный режим
       В этом режиме компьютер работает во время запуска или после загрузки.
       В этом режиме процессор использует только одна программа в монопольном режиме.
       Стандартный размер данных: WORD (16 бит).
    2. Защищённый режим / Protected mode / Legacy mode / IA-32 / 32-битный режим
       В этом режиме физическое адресное пространство ограничено 4Гб.
       Стандартный размер данных: DWORD (32 бита).
       В этот режим можно перейти только из реального режима.
       Включает в себя режим обратной совместимости с 16-битовым режимом.
    3. Long mode / AMD64 / IA-32e / 64-битный режим. Похож на защищённый режим.
       В этом режиме физическое адресное пространство ограничено 2 ^ 52 байтами.
       Виртуальное адресное пространство ограничено 2 ^ 48 байтами.
       Адрес памяти всегда 8-байтовый.
       В этот режим можно перейти только из защищённого режима.
       Включает в себя режим обратной совместимости с 32-битовым режимом.

    ----------------------------------------

    variety, different, various
    Note that...


    /////////////////////////////////////////
    /////////////////////////////////////////
    /////////////////////////////////////////
    /////////////////////////////////////////
    /////////////////////////////////////////


    Организация памяти архитектуры x86 в защищённом режиме.

    Т.к. архитектура 32-битная, адресное пространство защищённого режима будет состоять из 2^32 байт (4 Гб) пронумерованных от 0 и до 2^32 - 1.

    Эта архтектура поддерживает СТЕК - непрерывный блок памяти, который растёт в обратную сторону (справа налево/сверху вниз), то есть чем больше стек, тем меньше (младше) адрес его верхушки.
    В языке ассемблера есть команды push и pop для внесения и извлечения данных из стека.

    РИС. 1

    У процессора есть регистры.

    Регистры можно разбить на три группы по типу данных, с которыми они работают:
    - Basic program registers (Основные программные регистры) Эти регистры используются всеми программами с их помощью выполняется обработка целочисленных данных.
      a) Регистры общего назначения (8 шт. по 32 бита):  
         - EAX, EBX, ECX, EDX, EBP, ESI, EDI
         - ESP - адрес вешины стека (адрес последнего добавленного в стек элемента)
      b) Сегментные регистры (6 шт. по 16 бит): 
         - DS, ES, FS, GS - селекторы дескрипторов сегментов данных (как видно, у каждого процесса их может быть от 1 до 4)
         - CS - селектор дескриптора сегмента кода (-> EIP)
         - SS - селектор дескриптора сегмента стека (-> ESP)
      c) Регистры состояния и управления (2 шт. по 32 бита):
         - EFLAGS - содержит флаги, отображающие состояние процессора и результат выполнения последней команды
         - EIP - адрес следующей команды. процессор извлекает адрес след. команды и увеличивает значение в этом регистре на размер этой команды

    - Floating Point Unit registers (FPU) Эти регистры работают с данными представленными в формате с плавающей точкой.
    - Еще есть MMX и XMM registers эти регистры используются тогда, когда вам надо выполнить одну инструкцию над большим количеством операндов. 

    РИС. 3

    Структура селектора дескриптора (16 бит):
    - RPL - (биты №0 и №1, 2 крайних справа бита) - используется для контроля прав доступа программы к сегменту. Частным случаем RPL является текущий уровень привилегий — CPL, чьё значение в любой момент времени находится в сегментном регистре CS.
    - TI - (бит №2) - указывает на тип таблицы дескрипторов, в которой нужно искать дескриптор (значение 0 - глобальная таблица дескрипторов (GDT), 1 - локальная таблица дескрипторов (LDT)).
    - INDEX - (биты №3-15, 13 крайних слева битов) - индекс дескриптора в таблице дескрипторов (всего дескрипторов в таблице может быть 2^13 = 8192).

    Таблицы дескрипторов:
    - GDT - глобальная таблица дескрипторов - она одна во всей ОС и содержит дескрипторы для сегментов, которые являются общедоступными для всех процессов в системе. Каждый дескриптор этой таблиц
      Её расположение в физической памяти и размер определяются системным 48-битным регистром GDTR.
    - LDT - локальная таблица дескрипторов - таблица, специфичная для процесса. 
      Каждый дескриптор указывает на сегмент в памяти. 
      Их может быть несколько, но используется та, адрес которой лежит в регистре LDTR.
    (https://www.wikiwand.com/ru/GDT)

    РИС. 4

    Цепочка адресов выглядит так:
    Логический адрес --> Линейный/виртуальный адрес --> Физический адрес

    Всё линейное адресное пространство разбито на сегменты.

    Адресное пространство каждого процесса имеет по крайней мере три сегмента: 
    - Сегмент кода - содержит команды самой программы. Всегда 1 у процесса. (CS -> EIP)
    - Сегмент данных - хранит данные (переменные) программы. Может быть от 1 до 4 (DS, ES, FS, GS) 
      По дефолту используется сегмент на который указывает регистр DS. 
    - Сегмент стека. Всегда 1 у процесса. (SS -> ESP)

    РИС. 2

    Линейный адрес данных в памяти: базовый адрес сегмента (адрес начала сегмента) + смещение внутри сегмента

    --------------

    виртуальный адрес преобразуется в физический процессором

    --------------
    защищённый режим

    адрес памяти 32-битный
    можно адресовать 4 гб
    память делится на сегменты (не зависимо от режима)
    каждый сегмент может быть от 0 до 4 гб
    для доступа к сегменту используется логический адрес
    логический адрес = селектор сегмента + адрес в сегменте (смещение в сегменте)
    сегмент описывается дескриптором

    сегмент указывается селектором (идентификатором сегмента)
    селектор 16-битный
    селектор находится в сегментном регистре CS, DS, ES, FS, GS, SS
    структура селектора:
    - RPL (2 бита) - используется для контроля прав доступа программы к сегменту.
    - TI (1 бит) - указывает на тип таблицы дескрипторов, в которой нужно искать дескриптор (0 - глобальная таблица дескрипторов (GDT), 1 - локальная таблица дескрипторов (LDT)).
    - INDEX (13 бит) - индекс дескриптора в таблице дескрипторов (всего дескрипторов в таблице может быть 2^13 = 8192).
    +----------------------------------+
    |           INDEX          |TI|RPL |
    +----------------------------------+
    15                         3  2    0

    достать селектор -> 
    извлечь инедкс дескриптора и тип таблицы дескрипторов -> 
    обратиться к таблице дескрипторов (GDT или LDT) -> 
    извлечь базовый адрес сегмента и его лимит (размер - 1)

    дескриптор имеет размер 8 байт (два двойных слова по 4 байта):
    +------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------+
    |                                            DWORD 2                                             |                                            DWORD 1                                             | - Разделение дескриптора на два двойных слова
    |------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
    |     8     |  1  |  1  |  1  |  1  |     4     |  1  |    2    |  1  |       4       |                            24                            |                       16                       | - размер поля в битах
    |31       24| 23  | 22  | 21  | 20  |19       16| 15  |14     13| 12  |11            8|7        0|31                                           16|15                                             0| - номера битов в рамках слова
    |63       56| 55  | 54  | 53  | 52  |51       48| 47  |46     45| 44  |43           40|39      32|31                                           16|15                                             0| - номера битов в рамках всего дескриптора
    |=================================================================================================================================================================================================|
    |  Базовый  |  G  | D/B |  L  | AVL |   Лимит   |  P  |   DPL   |  S  |      Тип      |                          Базовый                         |                      Лимит                     | 
    |   адрес   |     |     |     |     | (часть 2) |     |         |     |   сегмента    |                           адрес                          |                    (часть 1)                   | - поля селектора (данные, которыми наполнен селектор)
    | (часть 2) |     |     |     |     |           |     |         |     |               |                         (часть 1)                        |                                                |
    |=================================================================================================================================================================================================|

    1. Лимит (16 бит): максимальное смещение внутри сегмента в байтах или страницах (размер сегмента - 1) 
    2. Базовый адрес (32 бита): линейный адрес памяти начала сегмента
    3. Тип сегмента (4 бита):
       - Если дескриптор описывает сегмент памяти:
         1) Бит 43: 0 - сегмент данных, 1 - сегмент кода
         2) Бит 42: 
            a. Если сегмент кода: подчинённость сегмента 
            b. Если сегмент данных: в какую сторону растёт сегмент при добавилении данных в него: 0 - вверх, 1 - вниз (как в стеке)
         3) Бит 41 (x - выполнение, r - чтение, w - запись):
            a. Если сегмент кода: 0 - x, 1 - rx
            b. Если сегмент данных: 0 - r, 1 - rw
         4) Бит 40 - осуществлялся ли доступ к сегменту:
            a. Если были операции rwx, процессор ставит 1
            b. Если дескриптор только создан и с сегментом не выполнялись операции rwx - 0
            (1 ставит только ЦП, 0 ставит только ОС)
        - Если дескриптор описывает системный объект:
          ...
    4. S (system) (1 бит):
       a. 1 - дескриптор описывает сегмент памяти (сегмент кода или данных)
       b. 0 - дескриптор описывает системный объект
    5. DPL (Descriptor Privilege Level) (2 бита): уровень привилегий, число от 0 до 3 (от 00b до 11b)
    6. P (Present) (1 бит):
       a. 1 - сегмент присутствует в памяти
       b. 0 - сегмент отсутствует в памяти
    7. AVL (1 бит) - бит не используется процессором
    8. L (1 бит) - в защищённом режиме этот бит зарезервирован и сброшен. Используется только в 64-битном режиме:
       a. 1 - бит D должен быть сброшен
       b. 0 - процессор работает в режиме совместимости
    9. D (Default size):
       a. 1 - процессор использует объект, описанный этим дескриптором, как 32-битный
       b. 0 - процессор использует объект, описанный этим дескриптором, как 16-битный
    10. G (Granularity):
       a. 1 - сегмент разбит на страницы по 4 Кб
       b. 0 - сегмент разбит на байты

    -------

    О COM-ПРОГРАММАХ

    COM-программа является просто куском памяти в файле.
    Когда она запускается, процессор ищет пустой сегмент памяти и просто копирует в него содержимое COM-файла.
    COM-программа не может занимать более одного сегмента, поэтому максимальный размер такой прогрммы - 64 Кб.
    У каждой COM-программы в самом начале должен быть отступ в 256 байт (100h) для служебной информации. (ORG 100h)

    ------

    ПЕРЕКЛЮЧЕНИЕ ПРОЦЕССОРА ИЗ РЕАЛЬНОГО РЕЖИМА в ЗАЩИЩЁННЫЙ

    1. Внести в память GDT (глобальную таблицу дескрипторов).
       Её размер не должен превышать 64 Кб.
       Её необходимо выровнять по границе 8 байт для увеличения производительности процессора.
       Изначально таблица будет содержать следующие дескрипторы:
       - Дескриптор для сегмента кода
       - Дескриптор для сегмента данных
       - Дескриптор для сегмента видеопамяти
    2. 




    /////////////////////////////////////////
    /////////////////////////////////////////
    /////////////////////////////////////////
    /////////////////////////////////////////
    /////////////////////////////////////////




    Порядок битов в байте идёт справа налево, начиная с 0
    LSB - самый правый бит в числе (Least Significant Bit — наименее значимый бит)
    MSB - самый левый бит в числе (Most Significant Bit — наиболее значимый бит)
    nibble (полубайт) - группа из четрёх битов

    - 1 byte = 8 bit = 256 (2^8) различных символов
    - 1 word = 2 byte = 16 bit = 65 536 (2^16) различных символов
    - 1 dword = 4 byte = 32 bit = 4 294 967 295 (2^32) различных символов

    1 байт - минимально считываемое кол-во данных из памяти.
    Каждый байт в памяти имеет свой индекс.

    Для представления одного символа таблицы ASCII используется байт, а для представления строки — группа последовательных байтов.

    Таблица ASCII:
    0xD = CR = возврат каретки
    0xA = LF = перевод строки
    \n = CRLF (Windows/DOS) = LF (UNIX)
    CP866 в DOS, CP1251 в Windows

    ----------------------------------------------------------------------------

    стр. 21 - концепция фон Неймана
    стр. 24 - структура микропроцессора

    Регистр - временное хранилище данных и инструкций внутри процессора, объёмом в несколько байт.

    В процессоре регистры трёх типов:
    1. Регистры общего назначения - содержат данные, полученные из памяти.
       Кроме названий, они ничем не отличаются.
       Основные регистры общего назначения (32-битные):
         - EAX - Accumulator (Аккумулятор):
         ---------------------------------------------------------------------------------------------------   Пример расположения числа 0x12345678 в регистрах общего назначения:
           | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |   ---------------------------------------------
         |                                           EAX 32 bit                                            |   |                 0x12345678                |
         |-------------------------------------------------------------------------------------------------|   |-------------------------------------------|
         |                     16 bit                     |                  AX 16 bit                     |   |        0x1234       |        0x5678       |
         |-------------------------------------------------------------------------------------------------|   |-------------------------------------------|
         |                                                |       AH 8 bit        |        AL 8 bit        |   |        0x1234       |   0x56   |   0x78   |
         ---------------------------------------------------------------------------------------------------   ---------------------------------------------
         - EBX - Base (База):
         ---------------------------------------------------------------------------------------------------
           | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
         |                                           EBX 32 bit                                            |
         |-------------------------------------------------------------------------------------------------|
         |                     16 bit                     |                  BX 16 bit                     |
         |-------------------------------------------------------------------------------------------------|
         |                                                |       BH 8 bit        |        BL 8 bit        |
         ---------------------------------------------------------------------------------------------------
         - ECX - Counter (Счётчик):
         ---------------------------------------------------------------------------------------------------
           | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
         |                                           ECX 32 bit                                            |
         |-------------------------------------------------------------------------------------------------|
         |                     16 bit                     |                  CX 16 bit                     |
         |-------------------------------------------------------------------------------------------------|
         |                                                |       CH 8 bit        |        CL 8 bit        |
         ---------------------------------------------------------------------------------------------------
         - EDX - Data (Данные):
         ---------------------------------------------------------------------------------------------------
           | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
         |                                           EDX 32 bit                                            |
         |-------------------------------------------------------------------------------------------------|
         |                     16 bit                     |                  DX 16 bit                     |
         |-------------------------------------------------------------------------------------------------|
         |                                                |       DH 8 bit        |        DL 8 bit        |
         ---------------------------------------------------------------------------------------------------
       Индексные регистры (обычно используются для адресации памяти, но можно использовать для хранения любых данных) (32-битные и 16-битные):
           - ESI - Source Index (индекс источника):
         ---------------------------------------------------------------------------------------------------
           | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
         |                                           ESI 32 bit                                            |
         |-------------------------------------------------------------------------------------------------|
         |                     16 bit                     |                  SI 16 bit                     |
         ---------------------------------------------------------------------------------------------------
           - EDI - Destination Index (индекс приемника)
         ---------------------------------------------------------------------------------------------------
           | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
         |                                           EDI 32 bit                                            |
         |-------------------------------------------------------------------------------------------------|
         |                     16 bit                     |                  DI 16 bit                     |
         ---------------------------------------------------------------------------------------------------
           - EBP - Base Pointer (указатель базы)
         ---------------------------------------------------------------------------------------------------
           | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
         |                                           EBP 32 bit                                            |
         |-------------------------------------------------------------------------------------------------|
         |                     16 bit                     |                  BP 16 bit                     |
         ---------------------------------------------------------------------------------------------------
    2. Регистры состояния - содержат текущее состояние ЦП и АЛУ
       Сегментные регистры - используются при вычислении реального адреса (адреса, который будет передан на шину адреса) (16-битные):
           - CS - Code Segment (сегмент кода) - определяет адрес памяти, откуда нужно прочитать следующую инструкцию
           - EIP (IP) - Instruction Pointer (указатель команд) - определяет адрес памяти, откуда нужно прочитать следующую инструкцию
           - SS - Stack Segment (сегмент стека) - указывает на вершину стека
           - ESP (SS:SP) - Stack Pointer (указатель стека) - указывает на вершину стека
           - DS - Data Segment - используется для адресации данных в памяти
           - ES - Extra Segment - используется для адресации данных в памяти
           - FS - F Segment - используется для адресации данных в памяти
           - GS - G Segment - используется для адресации данных в памяти
           - EFLAGS - регистр флагов (регистр признаков) (32-битный) - регистр, состоящий из 32 одноразрядных флагов, отображающих в основном текущее состояние АЛУ
             Список 32 флагов:
             - Признак нуля ZF (Zero Flag) - 1, если результат предыдущей операции равен нулю
         - Признак знака SF (Sign Flag) - 1, если результат предыдуидей операции отрицательный
         - Признак переполнения OF (Overflow Flag) - 1, если при выполнении предыдущей операции произошло переполнение (overflow), то есть результат операции больше, чем зарезервированная для него память
         - Признак переноса CF (Carry Flag) - 1, если бит был «перенесен» и стал битом более высокого порядка
         - Признак прерывания IF (Interrupt Flag) - 1, если прерывания процессора разрешены
         - Признак направления DF (Direction Flag) - используется для обработки строк
    3. Регистры-счётчики. Должен быть минимум один - счётчик команд, содержащийадрес следующей инструкции.

    Прерывания - остановка выполнения одной программы для выполнения другой.
    Во время прерывания сохраняется контекст прерванной программы.
    Процессоры x86 способны порождать до 256 прерываний.
    Адреса всех 256 функций обработки прерываний (так называемые векторы прерываний) хранятся в специальной таблице векторов прерываний.
    Два вида прерываний:
    - Аппаратное прерывание - происходят по запросу периферийных устройств и называются IRQ (Interrupt Requests). Архитектура шины ISA ограничивает их число до 16 (IRQO — IRQ15).
      Так же используется для прерывания самим процессором, когда в программе происходит ошибка.
      Две группы аппаратны прерываний:
      - маскируемыми (maskable)
      - немаскируемыми (non-maskable)
      Аппаратное прерывание можно отключить, установив флаг IF регистра EFLAGS в 0.
      NMI - единственное неотключаемое (немаскируемое) прерывание прерывание, генерирующееся при сбое памяти, сбое в питании процессора и подобных форсмажорных обстоятельствах.
    - Программное прерываение - используется программистом в коде программы. Например, для общения с ОС.

    ----------------------------------------------------------------------------

    Две основные архитектуры процессоров:
    - RISC (Reduced Instruction Set Computer) — компьютер с уменьшенным набором команд. Меньше команд, быстрее работает.
    - CISC (Complex Instruction Set Computer) — компьютер со сложной системой команд.

    Все х86-совместимые процессоры принадлежат к архитектуре CISC.

    стр. 32 - описание выполнения команды процессором
</pre>
