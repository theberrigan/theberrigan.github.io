<h1>OpenGL</h1>
http://jcgt.org/
https://paroj.github.io/gltut/
http://foundationsofgameenginedev.com/

Начало координат в OpenGL находится в левом нижнем углу.
2D-координаты во вьюпорте OpenGL всегда выражаются не в пикселях, а в коээфициентах от -1 до 1.
Например, если ширина вьюпорта 800 пикселей, то коодината -0.5 соответствует 200px, 0 – 400px, 1 – 800px и тп.

В OpenGL всё в 3D.
Графический пайплайн в OpenGL в основном занимается двумя процессами:
- Преобразование 3D в 2D.
- Преобразование получившихся 2D-коодинат в пиксели на экране.
  2D-координаты, в отличие от пикселей, – очень точное расположение точки в 2D-пространстве.

Шейдеры – маленькие, работающие параллельно, программы, которые запускаются на специальных ядрах видеокарты (их тысячи).
Шейдеры занимаются графическими преобразованиями. OpenGL имеет цепочку своих стандартных шейдеров, каждый из которых на вход
принимает то, что вышло из предыдущего шейдера. Получается конвейер. Разработчик имеет возможность изменять (писать свои) 
шейдеры некоторых типов. Первый шейдер в этом конвейере – Vertex Shader – принимает на вход одну 3D-вершину (3D-координаты + произвольные данные).

Vertex - вершина - это набор данных, который может включать в себя различные параметры: координаты самой вершины, координаты текстуры, нормали, цвета и тд.
Vertex Attributes - атрибуты вершины - так называются параметры, из которых состоит вершина. Каждый атрибут имеет свой индекс (index).
Object - объект - объект какого-то внутреннего для OpenGL типа. Чтобы использовать объекты в OpenGL, их нужно включить в контекст.
----------------------
VBO хранит разные данные: вершины, цвета и тд.
Каждая единица данных в VBO называется атрибутом, поэтому добавляется в VBO через функцию glVertexAttribPointer, а активируется с помощью glEnableVertexAttribArray.

Поскольку один VBO может хранить кучу разной информации, которая используется на одним шаге отрисовки и не используется на другом,
нужен способ быстро и просто переключаться между разными состояниями VBO. Для этого есть VAO - это буффер, который отслеживает все модификации VBO, 
а именно: glEnableVertexAttribArray, glDisableVertexAttribArray, glVertexAttribPointer. Для того, чтобы сопоставить VAO и VBO нужно:
1. Создать VAO и VBO, назначить их на роли (targets):
   glBindVertexArray(VAO);
   glBindBuffer(GL_ARRAY_BUFFER, VBO);
   (здесь, после того, как VAO и VBO назначены, они сопоставлены друг с другом)
2. Загружать данные в VBO, вызывать glEnableVertexAttribArray, glDisableVertexAttribArray, glVertexAttribPointer.
   (назначенный VAO будет запоминать эти модификации)
3. Опционально: отбиндить VAO и VBO.
   glBindBuffer(GL_ARRAY_BUFFER, 0);
   glBindVertexArray(0);

Так как смежные полигоны могут иметь вершины с одинаковыми координатами, рисовать их несколько раз неэффективно.
Легче по одному разу определить каждую вершину, и указать в каком порядке их отрисовывать.
Для этого существует EBO.
Он ассоациируется с VAO так же как и VBO (если VAO и EBO назначены на свои роли одновременно, то они считаются ассоциированными)
EBO, по сути, является подобъектом (subtree) VBO, их необходимо использовать вместе И НИ В КОЕМ СЛУЧАЕ НЕ ОТБИНЖИВАТЬ EBO ДО АНБИНДА VAO.
------------
glBindVertexArray(VAO);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);

in - входящая переменная шейдера (входит из C++ кода или из предыдущего шейдера на конвейере)
out - исходящая переменная (выходит из шейдера и передаётся следующему шейдеру на конвейере)
uniform - альтернатива in/out - создаёт глобальную переменную в рамках одной шейдерной программы (то есть переменная доступна в любом шейдере программы, за которой закреплена uniform-переменная)
          В отличие от in/out, uniform никогда не меняет своё значение самостоятельно. Если она получила значение, 
          то переменная будет жить до тех пор, пока шейдерная программа не будет удалена или пока не будет измененено значение вручную.
int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");  // отыскать в шейдерной программе положение переменной ourColor
glUseProgram(shaderProgram);  // перед тем, как модифицировать переменную необходимо активировать шейдерную программу
glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);  // установить новое значение переменной

-----------------

По ходу рендера координаты вершин рассчитываются последовательно в разных системах координат:
<ol>
    <li>local space (local coordinates) - координаты вершин объекта относительно его начала (origin) (обычно 0, 0, 0).</li>
    <li>world coordinates - глобальные координаты объекта относительно всего виртуального мира, в котором находятся и другие объекты (в том числе и камера). local space координаты объекта преобразуются в эту систему посредством model-матрицы.</li>
    <li>view coordinates - координатная система наблюдателя/камеры. world coordinates каждого объекта в сцене конвертируются во view coordinates посредством view-матрицы. То есть при взгляде из камеры координаты всех элементов сцены рассчитываются относительно положения камеры (camera origin).</li>
    <li>clip coordinates - нормализованная координатрая система (от -1 до 1 по осям), в которую преобразуются view coordinates посредством projection-матрицы. На этом этапе создаётся перспектива сцены.</li>
    <li>screen coordinates - система координат, которая задаётся функцией glViewport. Координаты clip coordinates преобразуются в эту систему (viewport transform), а затем отправляются в растерайзер для преобразования в фрагменты.</li>
</ol>
<img src="images/opengl/coords_pipeline.png" class="figure-img img-fluid">

Для того, чтобы определить камеру, нужно:
1. Определить её позицию в сцене, то есть world coordinates.
   glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
   Таким образом, определна камера, котора имет координаты (0, 0, 3) в глобальной системе координат.
   В OpenGL ось z направлена В глаза зрителя, поэтому если по оси z камера сдвинута на положительное число, то это значит, что она отодвинута назад.
2. Вектор направления взгляда камеры (look at).
   glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
   glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
   Камера будет смотреть в начало координат (cameraTarget == (0, 0, 0)).
   Направление камеры (look at) вычисляется путём вычитания координат наблюдаемой точки из положения камеры.
3. Вектор, направленный из камеры вправо.
   glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
   glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
   Сначала нужно определить обычный вектор, направленный вверх, затем вычислить его векторное произведение с cameraDirection.
   В результате получится третий вектор, перпендикулярный этим двум. Это и будет right-вектор. Не забыть нормализовать.
4. Вектор, направленный из камеры вверх.
   glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
   Up-вектор вычисляется подобно right-вектору - через векторное произведение cameraDirection и right-вектоора.

Таким образом будет создана координатная система, с тремя unit-векторами и началом (origin) в camera position.
На основе этих четырёх компонентов 

<img src="images/opengl/pitch_yaw_roll.png" class="figure-img img-fluid">

sin(a) = y/r
cos(a) = x/r
a - угол в радианах
r - радиус и по совместительству гипотенуза прямоугольного треугольника, вписанного в окружность
x - горизонтальный катет прямоугольного треугольника, вписанного в окружность
y - вертикальный катет прямоугольного треугольника, вписанного в окружность

Vx = 
Vy = sin(p)
Vz = 

-----------------------------

Scale:
I have found the following 'scale' info....
Character height 180cm.
Wall height 300cm
Door height: 210-230cm , width: 110-140cm
Stairs step height 15cm depth 30cm. 

-----------------------------

Phong Lighting Model - приближённая (approximated) модель освещения, состоящая из трёх основных компонентов:
1. Ambient Light - самое слабое освещение предмета со всех сторон. Сильно упрощённая версия offline-алгоритма Global Illumination.
   vec3 ambient = lightColor * 0.1;      // нужно взять цвет источника света и сократить его до 10 процентов 
   vec3 result = ambient * objectColor;  // затем полученный тусклый свет домножить на цвет фрагмента
2. Diffuse Light - основная и самая главная часть света.
   Луч падает на объект под определённым углом. 
   Чем этот угол ближе к 90 градусам к поверхности объекта, тем ярче свет, чем острее - тем тусклее.
   Угол между лучом и поверхностью объекта измеряется посредством вектора-нормали.
   Этот угол можно найти посредством скалярного произведения (dot product) вектора нормали и вектора луча.
   (0 градусов: СП = 1; 90 градусов: СП = 0)
   Оба вектора должны быть нормализованы (до юнит-вектора)
   Далее нужно получить вектор луча света. 
3. Specular Light - блик разной степени размытости

Рассчитывать свет эффективнее во view-координатах, а не в world-координатах (стр. 121)

Солнечный свет имеет белый цвет. Этот белый цвет состоит из огромного количества других цветов и их оттенков. 
Смешиваясь, эти цвета дают белый. Когда солнечный свет падает на предмет синего цвета, то этот предмет поглощает 
почти все цвета (весь спектр), кроме тех, которые смешиваются в синий, этот синий цвет попадает в глаза человеку. 
Поэтому мы видим этот предмет синим.

Конечный цвет объекта - это количество каждого цвета (красного, зелёного, синего), которое отражает предмет.
vec3 lightColor(1.0f, 1.0f, 1.0f);  // цвет света - белый
vec3 itemColor(1.0f, 0.5f, 0.31f);  // цвет объекта
result = lightColor * toyColor;     // (== itemColor) конечный цвет пикселя - это цвет, отражённый от этого пикселя (покомпонентное перемножение векторов)

Цвета, которые излучает объект при контакте со светом, описываются в структуре Material.
Интенсивность излучения этих цветов (отражения света) описыватся в структуре Light.

Материал представляет из себя структуру:
struct Material {
    vec3 ambient;     // это цвет, отражаемый в Ambient Light. По сути, это цвет самого объекта
    vec3 diffuse;     // цвет, отражаемый в Diffuse Light. Обычно соответствует ambient-цвету, то есть цвету самого объекта 
    vec3 specular;    // цвет блика
    float shininess;  // указывает размер пятна блика (..., 16, 32, 64, 128, 256, ...)
}; 

struct Light {
    vec3 position;
    vec3 ambient;    // вектор ambient-цвета, умноженный на коэффициент итенсивности (~0.1-0.2)
    vec3 diffuse;    // вектор diffuse-цвета, умноженный на интенсивность (обычно, это "родной" цвет объекта)
    vec3 specular;   // вектор цвета блика, обычно имеет максимальную интенсивность (1.0)
};

Light Caster - источник света:
1. Directional light - это источник света, который отбрасывает параллельные лучи света так, если бы этот источник света был бесконечно далеко.
2. Point light - это основной способ осветить сцену. Такой источник света светит во все стороны, а его лучи по мере удаления от источника теряют свою яркость. (Аналог лампы накаливания)
3. Spotlights

Сложные модели могут состоять из отдельных частей, каждая из которых называется mesh.
Mash должен содержать как минимум:
- Набор vertices, каждая из которых должна содержать position-вектор, вектор нормали и вектор с координатами текстур.
- Индексы для индексной отрисовки.
- Данные о материалах в виде текстур (defuse/specular maps)

У Assimp каждый мэш состоит из примитивов, каждый примитив - это полигон, или face (обычно, треугольный).
Каждый меш содержит только индекс материала, который лежит в общем массиве материалов в объекте scene.
Каждый материал содержит путь к текстуре.

! Stencil Test удаляет часть фрагментов, оставшиеся фрагменты идут в Depth Test и часть из них так же удаляется.

Stencil Test - использует буфер из байтов, каждый из которых соответствует фрагменту. Каждому байту можно назначить одной из 256 значений,
а затем убрать из рендера фрагменты с определёнными значениями.

В OpenGL Depth Buffer (z-buffer), как и color buffer, уникален для каждого фрагмента и содержит информацю о глубине этого фрагмента относительно других.
gl_FragCoord хранит координаты фрагмента в системе screen space (Screen space == glViewport, (0, 0) находится в левом нижнем углу).
x и y переменной gl_FragCoord содержат координаты фрагмента в экранной плоскости, а z содержит depth-значение фрагмента. Именно z-компонента gl_FragCoord
сравнивается с содержимым Depth Buffer'а. Если включить Depth Testing (glEnable(GL_DEPTH_TEST);), то OpenGL автоматически будет записывать z в gl_FragCoord.
На каждом кадре нужно не забывать чистить Depth Buffer glClear(GL_DEPTH_BUFFER_BIT);
! Чем z-компонента фрагмента меньше, тем фрагмент ближе к камере
! Depth Test пройден фрагментом, когда его z-компонента оказалась меньше соответствующего значения в Depth Buffer. В противном случае фрагмент не отрисовывается.
Depth Buffer хранит значения в виде float в интервале [0.0, 1.0]. В то время как z-компонента gl_FragCoord находится в view-координатах и может иметь значение 
от ближнего (near) плана до дальнего (far) плана усечённой пирамиды камеры (frustum). Для того, чтобы сравнить z-комп. фрагмента со значением из Depth Buffer'а,
необходимо как-то сконвертировать z-комп. фрагмента в значение от 0.0 до 1.0. Есть несколько способов это сделать:
- Линейная интерполяция (lerp): Depth = (z - near) / (far - near). Здесь far и near - дальний и ближний планы из projection-матрицы.
  Этот метод называется linear depth buffer и практически никогда не используется. Дело в том, что у чисел с плавающей точкой точность
  дробной части ограничена. Если линейно распределить точность для очень близких и очень отдалённых объектов, то возможно, точности не хватит.
  Гораздо лучше отдать большую часть точности близким объектам и меньшую - дальним. Это делаеть следующий способ.
- Depth = (1 / z - 1 / near) / (1 / far - 1 / near)
Важно: то что у фрагмента gl_FragCoord.z = 0.5, не значит, что во view-системе он будет в середине frustum'а. 

1. Как можно использовать множественную генерацию объектов в glGen*(?, &objId)?
2. Как расфасовывать данные (вершины, координаты текстур, цвета и тд) по VBO/VAO/EBO?

Framebuffer создаётся так же как и другие буфферы: создание -> бинд -> наполнение/использование -> анбинд.
Во время бинда FB можно выбрать роли, на которые биндится FB: read или draw:
- GL_FRAMEBUFFER - чтение и отрисовка
- GL_READ_FRAMEBUFFER - чтение. Буфер с этой ролью будет использоваться для всех операций чтения, как glReadPixels
- GL_DRAW_FRAMEBUFFER - отрисовка. Буффер с этой ролью будет использоваться для всех draw-операций.
Как только буффер создан и забинжен, он не может быть использован, потому что он не complete.
Для того, чтобы FB стал complete, нужно:
- Прикрепить к нему как минимум один буффер типа color, depth или stencil.
- Как минимум одно color-прикрепление. Это холст для FB, на котором будет отрисовываться цветовая информация.
- Все прикрепления тоже должны быть complete (для них должна быть выделена память).
- Каждый буффер должен иметь одинаковое кол-во сэмплов (пикселей).
Затем нужно проверить завершённость буффера glCheckFramebufferStatus.
Важно отметить, что до тех пор, пока забинжен не-default FB, все операции рендера будут изменять забинженый 
буффер и на экране ничего не будет изменяться. Чтобы снова забиндить default-FB, нужно glBindFramebuffer(GL_FRAMEBUFFER, 0).
Attachment - это область памяти, хранилище, в которое FB будет складывать (отрисовывать) информацию о цвете, глубине или трафарете.
Два типа аттачментов на выбор:
- Texture - по сути это холст, на котом FB будет рисовать. Кроме того, такой тип аттачмента ведёт себя как обычная текстура, поэтому
  её можно использовать, например, в шейдерах. Создаётся как обычная текстура, только в функции glTexImage2D на месте параметра data
  должен быть nullptr.
- Renderbuffer - этот тип появился позже типа texture и подобен ему. Но он лучше оптимизирован для offscreen-рендеринга. В отличие от
  типа texture, при рендеринге в renderbuffer нет необходимости конфертировать данные в формат понятный типу texture, поэтому renderbuffer
  работает быстрее. Тем не менее, renderbuffer - write-only.
Если нужно отрендериь то, что происходит на экране в не-default FB, то нужно вызвать glViewport и укзать размер текстуры не-default FB.
То есть glViewport работает с текущим активным FB.

! При хранении и загрузке вершин, текстур, нормалей и тд. чередовать их так: ВВВВТТТТНННН, а не так: ВТНВТНВТНВТН,
  так как в пермов случае их легче и быстрее загрузить в память через glBufferSubData, и назначить атрибуты через glVertexAttribPointer.

==================================

- Model
- Mesh
- Texture
- Color Buffer
- Face Culling - отсечение полигонов, которые повёрнуты к камере задом (back face)
- Stencil Test - позволяет убирать отдельные фрагменты из рендера, на основе соответствующих им байтов в Stencil Buffer'е.
- Stencil Buffer - состоит из байтов (по одному на фрагмент), определённые значения которых позволят убрать соответствующие фрагменты.
- Depth Buffer - содержит информацию о z-глубине каждого фрагмента.
- Depth Testing - вычисление самого ближнего к камере фрагмента. Он отрисовывается, а все фрагменты под ним - удаляются.
- Early Depth Testing - более современный и быстрый алгоритм Depth Testing'а, который позволяет проверить 
  глубину фрагмента ДО запуска fragment-шейдера (или вообще не его запускать, если тест не пройден).
  Чтобы EDT был возможен, нельзя записывать своё значение в z-компоненту gl_FragCoord, потому что тогда 
  EDT не сможет определить глубину фрагмента до запуска fragment-шейдера. Используется, например, для скайбокса.
- Z-fighting - когда несколько фрагментов расположены настолько близко, что точности чисел с плавающей точкой,
  которые использует Depth Buffer, становится недостаточно, чтобы однозначно определить наложение фрагментов.
  Способы предотвращения:
  - Никогда не располагать объекты так близко
  - Отодвинуть ближний план как можно дальше
  - Использовать Depth buffer повышенной точности
- Depth of Field
- Motion Blur
- LOD, LOD bias
- Tesselation
- Triangulation
- SSAO
- Shadow volumes - техника отрисовки теней на основе Stencil буффера.
- order independent transparency


<div style="overflow: auto; max-height: 450px;">
    <img src="images/gamedev/roadmap.png">
</div>
