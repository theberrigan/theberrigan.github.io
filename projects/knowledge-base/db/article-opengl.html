<h1>OpenGL</h1>
http://jcgt.org/
https://paroj.github.io/gltut/
http://foundationsofgameenginedev.com/

Начало координат в OpenGL находится в левом нижнем углу.
2D-координаты во вьюпорте OpenGL всегда выражаются не в пикселях, а в коээфициентах от -1 до 1.
Например, если ширина вьюпорта 800 пикселей, то коодината -0.5 соответствует 200px, 0 – 400px, 1 – 800px и тп.

В OpenGL всё в 3D.
Графический пайплайн в OpenGL в основном занимается двумя процессами:
- Преобразование 3D в 2D.
- Преобразование получившихся 2D-коодинат в пиксели на экране.
  2D-координаты, в отличие от пикселей, – очень точное расположение точки в 2D-пространстве.

Шейдеры – маленькие, работающие параллельно, программы, которые запускаются на специальных ядрах видеокарты (их тысячи).
Шейдеры занимаются графическими преобразованиями. OpenGL имеет цепочку своих стандартных шейдеров, каждый из которых на вход
принимает то, что вышло из предыдущего шейдера. Получается конвейер. Разработчик имеет возможность изменять (писать свои) 
шейдеры некоторых типов. Первый шейдер в этом конвейере – Vertex Shader – принимает на вход одну 3D-вершину (3D-координаты + произвольные данные).

Vertex - вершина - это набор данных, который может включать в себя различные параметры: координаты самой вершины, координаты текстуры, нормали, цвета и тд.
Vertex Attributes - атрибуты вершины - так называются параметры, из которых состоит вершина. Каждый атрибут имеет свой индекс (index).
Object - объект - объект какого-то внутреннего для OpenGL типа. Чтобы использовать объекты в OpenGL, их нужно включить в контекст.
----------------------
VBO хранит разные данные: вершины, цвета и тд.
Каждая единица данных в VBO называется атрибутом, поэтому добавляется в VBO через функцию glVertexAttribPointer, а активируется с помощью glEnableVertexAttribArray.

Поскольку один VBO может хранить кучу разной информации, которая используется на одним шаге отрисовки и не используется на другом,
нужен способ быстро и просто переключаться между разными состояниями VBO. Для этого есть VAO - это буффер, который отслеживает все модификации VBO, 
а именно: glEnableVertexAttribArray, glDisableVertexAttribArray, glVertexAttribPointer. Для того, чтобы сопоставить VAO и VBO нужно:
1. Создать VAO и VBO, назначить их на роли (targets):
   glBindVertexArray(VAO);
   glBindBuffer(GL_ARRAY_BUFFER, VBO);
   (здесь, после того, как VAO и VBO назначены, они сопоставлены друг с другом)
2. Загружать данные в VBO, вызывать glEnableVertexAttribArray, glDisableVertexAttribArray, glVertexAttribPointer.
   (назначенный VAO будет запоминать эти модификации)
3. Опционально: отбиндить VAO и VBO.
   glBindBuffer(GL_ARRAY_BUFFER, 0);
   glBindVertexArray(0);

Так как смежные полигоны могут иметь вершины с одинаковыми координатами, рисовать их несколько раз неэффективно.
Легче по одному разу определить каждую вершину, и указать в каком порядке их отрисовывать.
Для этого существует EBO.
Он ассоациируется с VAO так же как и VBO (если VAO и EBO назначены на свои роли одновременно, то они считаются ассоциированными)
EBO, по сути, является подобъектом (subtree) VBO, их необходимо использовать вместе И НИ В КОЕМ СЛУЧАЕ НЕ ОТБИНЖИВАТЬ EBO ДО АНБИНДА VAO.
------------
glBindVertexArray(VAO);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);

in - входящая переменная шейдера (входит из C++ кода или из предыдущего шейдера на конвейере)
out - исходящая переменная (выходит из шейдера и передаётся следующему шейдеру на конвейере)
uniform - альтернатива in/out - создаёт глобальную переменную в рамках одной шейдерной программы (то есть переменная доступна в любом шейдере программы, за которой закреплена uniform-переменная)
          В отличие от in/out, uniform никогда не меняет своё значение самостоятельно. Если она получила значение, 
          то переменная будет жить до тех пор, пока шейдерная программа не будет удалена или пока не будет измененено значение вручную.
int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");  // отыскать в шейдерной программе положение переменной ourColor
glUseProgram(shaderProgram);  // перед тем, как модифицировать переменную необходимо активировать шейдерную программу
glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);  // установить новое значение переменной

-----------------

По ходу рендера координаты вершин рассчитываются последовательно в разных системах координат:
<ol>
    <li>local space (local coordinates) - координаты вершин объекта относительно его начала (origin) (обычно 0, 0, 0).</li>
    <li>world coordinates - глобальные координаты объекта относительно всего виртуального мира, в котором находятся и другие объекты (в том числе и камера). local space координаты объекта преобразуются в эту систему посредством model-матрицы.</li>
    <li>view coordinates - координатная система наблюдателя/камеры. world coordinates каждого объекта в сцене конвертируются во view coordinates посредством view-матрицы. То есть при взгляде из камеры координаты всех элементов сцены рассчитываются относительно положения камеры (camera origin).</li>
    <li>clip coordinates - нормализованная координатрая система (от -1 до 1 по осям), в которую преобразуются view coordinates посредством projection-матрицы. На этом этапе создаётся перспектива сцены.</li>
    <li>screen coordinates - система координат, которая задаётся функцией glViewport. Координаты clip coordinates преобразуются в эту систему (viewport transform), а затем отправляются в растерайзер для преобразования в фрагменты.</li>
</ol>
<img src="images/opengl/coords_pipeline.png" class="figure-img img-fluid">

Для того, чтобы определить камеру, нужно:
1. Определить её позицию в сцене, то есть world coordinates.
   glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
   Таким образом, определна камера, котора имет координаты (0, 0, 3) в глобальной системе координат.
   В OpenGL ось z направлена В глаза зрителя, поэтому если по оси z камера сдвинута на положительное число, то это значит, что она отодвинута назад.
2. Вектор направления взгляда камеры (look at).
   glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
   glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
   Камера будет смотреть в начало координат (cameraTarget == (0, 0, 0)).
   Направление камеры (look at) вычисляется путём вычитания координат наблюдаемой точки из положения камеры.
3. Вектор, направленный из камеры вправо.
   glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
   glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
   Сначала нужно определить обычный вектор, направленный вверх, затем вычислить его векторное произведение с cameraDirection.
   В результате получится третий вектор, перпендикулярный этим двум. Это и будет right-вектор. Не забыть нормализовать.
4. Вектор, направленный из камеры вверх.
   glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
   Up-вектор вычисляется подобно right-вектору - через векторное произведение cameraDirection и right-вектоора.

Таким образом будет создана координатная система, с тремя unit-векторами и началом (origin) в camera position.
На основе этих четырёх компонентов 

<img src="images/opengl/pitch_yaw_roll.png" class="figure-img img-fluid">

sin(a) = y/r
cos(a) = x/r
a - угол в радианах
r - радиус и по совместительству гипотенуза прямоугольного треугольника, вписанного в окружность
x - горизонтальный катет прямоугольного треугольника, вписанного в окружность
y - вертикальный катет прямоугольного треугольника, вписанного в окружность

Vx = 
Vy = sin(p)
Vz = 

-----------------------------

Global Illumination - алгоритм, который рассчитывает отражения всех лучей во всех направлениях.
Ambient Light - значительно более простой алгоритм глобального освещения.

Рассчитывать свет эффективнее во view-координатах, а не в world-координатах (стр. 121)


<div style="overflow: auto; max-height: 450px;">
    <img src="images/gamedev/roadmap.png">
</div>
