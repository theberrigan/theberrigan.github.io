<h1>OpenGL</h1>
<pre>
    http://jcgt.org/
    https://paroj.github.io/gltut/
    http://foundationsofgameenginedev.com/

    Начало координат в OpenGL находится в левом нижнем углу.
    2D-координаты во вьюпорте OpenGL всегда выражаются не в пикселях, а в коээфициентах от -1 до 1.
    Например, если ширина вьюпорта 800 пикселей, то коодината -0.5 соответствует 200px, 0 – 400px, 1 – 800px и тп.

    В OpenGL всё в 3D.
    Графический пайплайн в OpenGL в основном занимается двумя процессами:
    - Преобразование 3D в 2D.
    - Преобразование получившихся 2D-коодинат в пиксели на экране.
      2D-координаты, в отличие от пикселей, – очень точное расположение точки в 2D-пространстве.

    Шейдеры – маленькие, работающие параллельно, программы, которые запускаются на специальных ядрах видеокарты (их тысячи).
    Шейдеры занимаются графическими преобразованиями. OpenGL имеет цепочку своих стандартных шейдеров, каждый из которых на вход
    принимает то, что вышло из предыдущего шейдера. Получается конвейер. Разработчик имеет возможность изменять (писать свои) 
    шейдеры некоторых типов. Первый шейдер в этом конвейере – Vertex Shader – принимает на вход одну 3D-вершину (3D-координаты + произвольные данные).

    Vertex - вершина - это набор данных, который может включать в себя различные параметры: координаты самой вершины, координаты текстуры, нормали, цвета и тд.
    Vertex Attributes - атрибуты вершины - так называются параметры, из которых состоит вершина. Каждый атрибут имеет свой индекс (index).
    Object - объект - объект какого-то внутреннего для OpenGL типа. Чтобы использовать объекты в OpenGL, их нужно включить в контекст.
    ----------------------
    VBO хранит разные данные: вершины, цвета и тд.
    Каждая единица данных в VBO называется атрибутом, поэтому добавляется в VBO через функцию glVertexAttribPointer, а активируется с помощью glEnableVertexAttribArray.

    Поскольку один VBO может хранить кучу разной информации, которая используется на одним шаге отрисовки и не используется на другом,
    нужен способ быстро и просто переключаться между разными состояниями VBO. Для этого есть VAO - это буффер, который отслеживает все модификации VBO, 
    а именно: glEnableVertexAttribArray, glDisableVertexAttribArray, glVertexAttribPointer. Для того, чтобы сопоставить VAO и VBO нужно:
    1. Создать VAO и VBO, назначить их на роли (targets):
       glBindVertexArray(VAO);
       glBindBuffer(GL_ARRAY_BUFFER, VBO);
       (здесь, после того, как VAO и VBO назначены, они сопоставлены друг с другом)
    2. Загружать данные в VBO, вызывать glEnableVertexAttribArray, glDisableVertexAttribArray, glVertexAttribPointer.
       (назначенный VAO будет запоминать эти модификации)
    3. Опционально: отбиндить VAO и VBO.
       glBindBuffer(GL_ARRAY_BUFFER, 0);
       glBindVertexArray(0);

    Так как смежные полигоны могут иметь вершины с одинаковыми координатами, рисовать их несколько раз неэффективно.
    Легче по одному разу определить каждую вершину, и указать в каком порядке их отрисовывать.
    Для этого существует EBO.
    Он ассоациируется с VAO так же как и VBO (если VAO и EBO назначены на свои роли одновременно, то они считаются ассоциированными)
    EBO, по сути, является подобъектом (subtree) VBO, их необходимо использовать вместе И НИ В КОЕМ СЛУЧАЕ НЕ ОТБИНЖИВАТЬ EBO ДО АНБИНДА VAO.
    ------------
    glBindVertexArray(VAO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);

    in - входящая переменная шейдера (входит из C++ кода или из предыдущего шейдера на конвейере)
    out - исходящая переменная (выходит из шейдера и передаётся следующему шейдеру на конвейере)
    uniform - альтернатива in/out - создаёт глобальную переменную в рамках одной шейдерной программы (то есть переменная доступна в любом шейдере программы, за которой закреплена uniform-переменная)
              В отличие от in/out, uniform никогда не меняет своё значение самостоятельно. Если она получила значение, 
              то переменная будет жить до тех пор, пока шейдерная программа не будет удалена или пока не будет измененено значение вручную.
    int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");  // отыскать в шейдерной программе положение переменной ourColor
    glUseProgram(shaderProgram);  // перед тем, как модифицировать переменную необходимо активировать шейдерную программу
    glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);  // установить новое значение переменной

</pre>
<div style="overflow: auto; max-height: 450px;">
    <img src="images/gamedev/roadmap.png">
</div>
