<h1>Информатика</h1>
<pre>
    Число с плавающей точкой, которое приведено к экспоненциальному виду, называется нормализованным.
    Оно состоит из мантиссы (mantissa/fraction) и экспоненты.
    И мантисса, и экспонента могут быть положительными и отрицательными.
    Например, в числе 3.45000e5 = 345000, при этом 3.45000 - это мантисса, а 5 - экспонента.

    https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
    https://modernweb.com/what-every-javascript-developer-should-know-about-floating-points/

    +---------------------------------------+
    | ПРЯМОЙ, ОБРАТНЫЙ И ДОПОЛНИТЕЛЬНЫЙ КОД |
    +---------------------------------------+

    - Беззныковые (unsigned) целые числа.
        Просто переводятся в двоичный код. Каждый бит этого кода участвует в представлении числа. 
        Пример: 255 = 11111111
    - Знаковые (signed) целые числа выражаются тремя способами, где каждый последующий усложняет предыдущий для решения каких-то проблем.
        1. Прямой код (signed magnitude): самый простой. 
            Его минус в том, что для него сложно реализовать арифметику и он имеет два нуля: 0 и -0.
            Самый левый (старший) бит числа выделяется под знак. 
            Если число положительное, то знаковый бит - 0, а если отрицательное – 1.
            Пример:
                99 = 0|1100011
               -99 = 1|1100011

        2. Обратный код (1's complement): представляет собой прямой код, но у отрицательных чисел инвертированы биты числа. 
            Минусы: арифметические операции проводятся в два этапа, он тоже имеет два нуля: 0 и -0. 
            Пример:
                99 = 0|1100011
               -99 = 1|0011100
        3. Дополнительный код (2's complement): представляет собой обратный код, но в случае отрицательных чисел ещё прибавляется единица:
            Пример:
                99 = 0|1100011
               -99 = 1|0011101
    - Числа с плавающей точкой хранятся по стандарту IEEE 754. Этот стандарт подразумевает разделение 
      последовательности бит на три секции: знаковый бит, биты экспоненты и биты мантиссы.
      Всего различают два типа точности числа:
      - Одинарная точность. Такое число состоит из 32 бит. Первый бит - знаковый, 
        следующие 8 бит - биты экспоненты, а последние 23 - биты мантиссы.
      - Двойная точность. Эти числа состоят из 64 бит, которые распределены между
        знаком, экспонентой и мантиссой в отношении 1:11:52.

    TODO:
    - Строки и кодировки



    +------------------------------------------------------+
    | ПОРЯДОК СЛЕДОВАНИЯ БИТОВ: BIG-ENDIAN & LITTLE-ENDIAN |
    +------------------------------------------------------+

    Big Endian - Порядок байт, как в математике
    Little Endian - Обратный порядок байт
    Пример:
    Исходный кусок данных: A0 5B 33 FF
    Big Endian:            A0 5B 33 FF (например, в сетях TCP/IP или процессорах Motorola)
    Little Endian:         FF 33 5B A0 (например, в архитектуре Intel x86)
    Little Endian эффективнее, потому что это позволяет упростить вычисления и аппаратуру

    Старший разряд - наиболее значащий (в Big-Endian это самый левый, а в Little-Endian - самый правый)
    Младший разряд - наименее значащий (в Big-Endian это самый правый, а в Little-Endian - самый левый)

    Важно обратить внимание, что биты в байтах всегда следуют слева направо.



    +------------------+
    | БИТОВЫЕ ОПЕРАЦИИ |
    +------------------+

    1. Отбрасывание дробной части
       ! Использовать осторожно, часто даёт неверный результат
       5.25 | 0 == 5

    2. Деление числа на число равное степени двойки с округлением вниз.
       То же самое, что и битовый сдвиг вправо на степень двойки.
       X >> Y == floor(X / (2 ^ Y)) == ((X / (2 ^ Y)) | 0)

    3. Задача:
       Есть четыре последовательных байта в Big Endian порярдке, которые вместе образуют одно число.
       В каждом байте значащими являются только последние 7, а старший бит (самый левый) нельзя использовать.
       Написать выражение, которое получит это 4-байтовое число.
           bytes[3] & 0x7f
       | ((bytes[2] & 0x7f) << 7)
       | ((bytes[1] & 0x7f) << 14)
       | ((bytes[0] & 0x7f) << 21)

    4. Выражение вернёт true, если x и y имеют противоположные знаки
       (x ^ y) < 0
</pre>
