<h1>C++</h1>
<p>
    <code>Namespace::&lt;namespace_member></code><br>
    <code>::</code> - оператор разрешения скоупа<br>
    Все имена стандартной библиоткеки префикснуты <code>std::</code><br>
    Синтаксис: <code>namespace mySpace { ... }</code><br>            
</p>
<p>
    <span class="important">Не использовать имена, начинающиеся с <code>_</code>.</span>            
</p>
<p>
    Template – в терминах С++ просто синтаксис для создания классов, функций и тд.<br>            
</p>
<p>
    <img src="images/cpp/001.png">           
</p>
<p>
    <code>"here is a string"</code> – строковой литерал.<br>
    Raw string literals – альтернатива для escaped characters.  
</p>

<!--<listing lang="cpp">

	    1
	        2
	    	3
		4
	5
						
</listing>-->

<!--
/////////////////////////
/////////////////////////
/////////////////////////
-->

<div hidden>
    <h2>Заголовочные файлы</h2>
    <p>Если импортируется заголовочный файл C++, то его расширение (.h) опускается: #include &lt;iostream&gt;. Если импортируется заголовочный файл, перенесённый из C, то расширение .h остаётся: #include &lt;math.h&gt;. Так же многие ЗФ, пересённые из C были переименованы (в начале добавлен префикс "c"), и они импортируются без расширения, например, <code>#include &lt;math.h&gt;</code> то же самое, что и #include &lt;cmath&gt;.</p>
    <p>Пробельные символы: &lt;пробел&gt;, табуляция (\t), возврат каретки (\r).</p>
    <p>
        <code>cin &gt;&gt; charStr</code><br>
        <code>cin.get()</code><br>
        <code>cin.get(charStr, length)</code><br>
        <code>cin.getline(charStr, length)</code><br>
        <code>getline(cin, stringStr)</code>
    </p>  
    <p><strong>Ширина</strong>&nbsp;&#0151;&nbsp;объём памяти, необходимый для хранения переменной конткретного типа.</p>
    <p>
        <span>&#0151;&nbsp;8 бит может представлять 256 комбинаций: от 0 до 255 или от -128 до 127;</span><br>
        <span>&#0151;&nbsp;16 бит может представлять 65&nbsp;536 комбинаций;</span><br>
        <span>&#0151;&nbsp;32 бит может представлять 4&nbsp;294&nbsp;672&nbsp;296 комбинаций;</span><br>
        <span>&#0151;&nbsp;64 бит может представлять 18&nbsp;446&nbsp;744&nbsp;073&nbsp;709&nbsp;551&nbsp;616 комбинаций.</span><br>
    </p>
    <p><strong>Октет</strong>&nbsp;&#0151;&nbsp;байт, состоящий из 8 бит.</p>
    <p style="margin-bottom: 7px;">
        <span>Таблица типов. Ширина и диапазоны значений указаны с условием, что 1 байт равен 8 битам.</span><br>
        <span>Для того, чтобы узнать размер типа в байтах для определённой реализации, нужно использовать операцию <span class="mono red">sizeof</span>.</span><br>
        <span>В заголовочном файле <span class="mono red">climits</span> (в старых реализациях <span class="mono red">limits.h</span>) указаны максимальные и минимальные значения для целочисленных типов в текущей реализации.</span>
    </p>
    <table class="table table-bordered">
        <tr>
            <th>Тип</th>
            <th>Что хранит</th>
            <th>Ширина</th>
            <th>Минимальное значение</th>
            <th>Максимальное значение</th>
            <th><i>Прим.</i></th>
        </tr>
        <tr>
            <td class="mono">char</td>
            <td>Целое число</td>
            <td>&gt;= 8 бит</td>
            <td class="align-right">-128</td>
            <td class="align-right">127</td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">wchar_t<sup class="opac-75"> 1</sup></td>
            <td>Целое число</td>
            <td>&gt;= 8 бит<sup class="opac-75"> 2</sup></td>
            <td class="align-right">&#0151; <sup class="opac-75">2</sup></td>
            <td class="align-right">&#0151; <sup class="opac-75">2</sup></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">char16_t<sup class="opac-75"> 3</sup></td>
            <td>Целое число</td>
            <td>16 бит</td>
            <td class="align-right"></td>
            <td class="align-right"></td>
            <td>C++11</td>
        </tr>
        <tr>
            <td class="mono">char32_t<sup class="opac-75"> 3</sup></td>
            <td>Целое число</td>
            <td>32 бита</td>
            <td class="align-right"></td>
            <td class="align-right"></td>
            <td>C++11</td>
        </tr>
        <tr>
            <td class="mono">short</td>
            <td>Целое число</td>
            <td>>= 16 бит</td>
            <td></td>
            <td></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">int</td>
            <td>Целое число</td>
            <td>&gt;= <span class="mono">short</span></td>
            <td class="align-right">-&nbsp;32&nbsp;768</td>
            <td class="align-right">&nbsp;32&nbsp;767</td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">long</td>
            <td>Целое число</td>
            <td>&gt;= <span class="mono">int</span><br>&gt;= 32 бит</td>
            <td></td>
            <td></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">long long</td>
            <td>Целое число</td>
            <td>&gt;= <span class="mono">long</span><br>&gt;= 64 бит</td>
            <td></td>
            <td></td>
            <td>C++11</td>
        </tr>
        <tr>
            <td class="mono">unsigned char</td>
            <td>Целое число</td>
            <td>&gt;= 8 бит</td>
            <td class="align-right">0</td>
            <td class="align-right">255</td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">unsigned short</td>
            <td>Целое число</td>
            <td></td>
            <td></td>
            <td></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">unsigned int<sup class="opac-75"> 4</sup></td>
            <td>Целое число</td>
            <td></td>
            <td></td>
            <td></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">unsigned long</td>
            <td>Целое число</td>
            <td></td>
            <td></td>
            <td></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="mono">unsigned long long</td>
            <td>Целое число</td>
            <td></td>
            <td></td>
            <td></td>
            <td>C++11</td>
        </tr>
    </table>

    <p style="margin-top: 10px; margin-bottom: 7px;">
        <span><sup class="opac-75">1</sup> <span>Wide character type</span>.</span><br>
        <span><sup class="opac-75">2</sup> <span>Зависит от компилятора</span>.</span><br>
        <span><sup class="opac-75">3</sup> <span>Являются беззнаковыми типами</span>.</span><br>
        <span><sup class="opac-75">4</sup> <span class="mono">unsigned</span> без указания типа аналогично <span class="mono">unsigned int</span>.</span>
    </p>

    <p style="margin-top: 25px; margin-bottom: 7px;">
        <span>Значения констант в заголовочном файле <span class="mono red">climits</span> (в старых реализациях <span class="mono red">limits.h</span>).</span>
    </p>

    <table class="table table-bordered">
        <tr>
            <th>Имя константы</th>
            <th>Значение константы</th>
        </tr>
        <tr>
            <td class="mono">CHAR_BIT</td>
            <td>Количество битов в <span class="mono">char</span></td>
        </tr>
        <tr>
            <td class="mono">CHAR_MIN</td>
            <td>Минимальное значение <span class="mono">char</span></td>
        </tr>
        <tr>
            <td class="mono">CHAR_MAX</td>
            <td>Максимальное значение <span class="mono">char</span></td>
        </tr>
        <tr>
            <td class="mono">SCHAR_MIN</td>
            <td>Минимальное значение <span class="mono">signed char</span></td>
        </tr>
        <tr>
            <td class="mono">SCHAR_MAX</td>
            <td>Максимальное значение <span class="mono">signed char</span></td>
        </tr>
        <tr>
            <td class="mono">UCHAR_MAX</td>
            <td>Максимальное значение <span class="mono">unsigned char</span></td>
        </tr>
        <tr>
            <td class="mono">SHRT_MIN</td>
            <td>Минимальное значение <span class="mono">short</span></td>
        </tr>
        <tr>
            <td class="mono">SHRT_MAX</td>
            <td>Максимальное значение <span class="mono">short</span></td>
        </tr>
        <tr>
            <td class="mono">USHRT_MAX</td>
            <td>Максимальное значение <span class="mono">unsigned short</span></td>
        </tr>
        <tr>
            <td class="mono">INT_MIN</td>
            <td>Минимальное значение <span class="mono">int</span></td>
        </tr>
        <tr>
            <td class="mono">INT_MAX</td>
            <td>Максимальное значение <span class="mono">int</span></td>
        </tr>
        <tr>
            <td class="mono">UINT_MAX</td>
            <td>Максимальное значение <span class="mono">unsigned int</span></td>
        </tr>
        <tr>
            <td class="mono">LONG_MIN</td>
            <td>Минимальное значение <span class="mono">long</span></td>
        </tr>
        <tr>
            <td class="mono">LONG_MAX</td>
            <td>Максимальное значение <span class="mono">long</span></td>
        </tr>
        <tr>
            <td class="mono">ULONG_MAX</td>
            <td>Максимальное значение <span class="mono">unsigned long</span></td>
        </tr>
        <tr>
            <td class="mono">LLONG_MIN</td>
            <td>Минимальное значение <span class="mono">long long</span></td>
        </tr>
        <tr>
            <td class="mono">LLONG_MAX</td>
            <td>Максимальное значение <span class="mono">long long</span></td>
        </tr>
        <tr>
            <td class="mono">ULLONG_MAX</td>
            <td>Максимальное значение <span class="mono">unsigned long long</span></td>
        </tr>
    </table>

    <p style="margin-top: 25px; margin-bottom: 7px;"><span>Способы инициализации переменных:</span></p>
    <table class="table table-bordered">
        <tr>
            <th>Инициализация</th>
            <th>Описание</th>
            <th><i>Примечание</i></th>
        </tr>
        <tr>
            <td class="mono nowrap"><span class="red">int</span> variable = 5;</td>
            <td>Классическия инициализация.</td>
            <td class="nowrap">Совместимо с Си</td>
        </tr>
        <tr>
            <td class="mono nowrap"><span class="red">int</span> variable(5);</td>
            <td>Значение переменной заключается в круглые скобки.</td>
            <td class="nowrap">Не совместимо с Си</td>
        </tr>
        <tr>
            <td class="mono nowrap"><span class="red">int</span> variable{5};</td>
            <td>Инициализация перменных с одним значением, которое заключается в фигурные скобки.</td>
            <td class="nowrap">Не совместимо с Си</td>
        </tr>
        <tr>
            <td class="mono nowrap"><span class="red">int</span> ary = {5, 10, 12};</td>
            <td>Инициализация перменных, которые имеют одно значение <i>или</i> являются массивом.</td>
            <td class="nowrap">Не совместимо с Си</td>
        </tr>
    </table>
    <p style="margin-bottom: 7px;"><span>В последних двух случаях перменная инициализируется нулём, если скобки оставить пустыми. Кроме того, эти два способа предоставляют лучшую защиту от ошибок преобразования типов.</span></p>

    <p style="margin-top: 25px;">
        <span>Предпочтения в выборе целочисленных типов:</span><br>
        <span>&#0151;&nbsp;Если используеются очень большие числа, использовать тип <span class="mono">long</span>;</span><br>
        <span>&#0151;&nbsp;Если для хранения числа вполне достаточно <span class="mono">int</span>, то лучше использовать <span class="mono">short</span> для экономии памяти. Так как при переносе на другие платформы, <span class="mono">int</span> может занимать больше памяти для расширения диапазона, а у <span class="mono">short</span> диапазон не изменяется;</span><br>
        <span>&#0151;&nbsp;Для хранения небольших чисел (до 255) лучше использовать тип <span class="mono">char</span>.</span>
    </p>

    <p style="margin-top: 25px; margin-bottom: 7px;"><span>Хранение переменных в разных системах счисления:</span></p>
    <table class="table table-bordered">
        <tr>
            <th class="nowrap">Система счисления</th>
            <th class="nowrap">Правило</th>
            <th class="nowrap">Пример</th>
        </tr>
        <tr>
            <td class="nowrap">Десятичная</td>
            <td>Если число равно нулю или состоит из нескольких цифр и при этом первая цифра от 1 до 9.</td>
            <td class="nowrap">1377</td>
        </tr>
        <tr>
            <td class="nowrap">Восьмиричная</td>
            <td>Если число <strong>не</strong> равно нулю, начинается с нуля, и остальные цифры находятся в диапазоне от 0 до 7.</td>
            <td class="nowrap">073</td>
        </tr>
        <tr>
            <td class="nowrap">Шеснадцатиричная</td>
            <td>Число начинается с 0x или 0X и имеет в себе цифры от 0 до 9 и буквы от A до F (регистр не имеет значения).</td>
            <td class="nowrap">0xf91a</td>
        </tr>
    </table>

    <p style="margin-top: 25px; margin-bottom: 7px;">
        <span>Целочисленные константы (числа, указанные явно, например, 237) по умолчанию хранятся как <span class="mono">int</span> при условии, что этого типа данных достаточно для хранения этого числа, и, если число не имеет специального суффикса, указывающего на другой тип. Если для хранения числа не достаточно типа <span class="mono">int</span>, то:</span><br>
        <span>&#0151;&nbsp;Для чисел в десятичной системе счисления будет использоваться <span class="mono">long</span> или <span class="mono">long long</span>;</span><br>
        <span>&#0151;&nbsp;Для чисел в восьмиричной и шестнадцатиричной системах счисления будет использоваться тип <span class="mono">int</span>, <span class="mono">long</span>, <span class="mono">unsigned long</span>, <span class="mono">long long</span> или <span class="mono">unsigned long long</span>.</span>
    </p>

    <p style="margin-top: 25px; margin-bottom: 7px;"><span>Целочисленные суффиксы:</span></p>

    <table class="table table-bordered">
        <tr>
            <th class="nowrap">Суффикс<sup> 1</sup></th>
            <th class="nowrap">Соответствующий тип</th>
            <th class="nowrap">Пример</th>
            <th class="nowrap">Примечание</th>
        </tr>
        <tr>
            <td class="mono nowrap">L</td>
            <td class="mono nowrap">long</td>
            <td class="nowrap align-right">150L</td>
            <td class="nowrap">&#0151;</td>
        </tr>
        <tr>
            <td class="mono nowrap">U</td>
            <td class="mono nowrap">unsigned int</td>
            <td class="nowrap align-right">760U</td>
            <td class="nowrap">&#0151;</td>
        </tr>
        <tr>
            <td class="mono nowrap">UL (LU)</td>
            <td class="mono nowrap">unsigned long</td>
            <td class="nowrap align-right">580UL</td>
            <td class="nowrap">&#0151;</td>
        </tr>
        <tr>
            <td class="mono nowrap">LL</td>
            <td class="mono nowrap">long long</td>
            <td class="nowrap align-right">301LL</td>
            <td class="nowrap">C++11</td>
        </tr>
        <tr>
            <td class="mono nowrap">ULL</td>
            <td class="mono nowrap">unsigned long long</td>
            <td class="nowrap align-right">796ULL</td>
            <td class="nowrap">C++11</td>
        </tr>
    </table>

    <p style="margin-top: 10px; margin-bottom: 7px;">
        <sup class="opac-75">1</sup>
        <span>суффиксы не чувствительны к регистру.</span>
    </p>

    <p style="margin-top: 25px; margin-bottom: 7px;"><span>Тип <span class="mono">char</span> по умолчанию не является знаковым или беззнаковым и зависит от компилятора. Чтобы определить точное поведение этого типа, лучше указывать <span class="mono">signed char</span> или <span class="mono">unsigned char</span>.</span></p>
    <hr><hr>
    <!--
        ////////////////////////////////////////////
        ////////////////////////////////////////////
        ////////////////////////////////////////////
        ////////////////////////////////////////////
    -->
    <pre>
        В 60х года была разработана ASCII для представления символов. Для кодирования каждого символа она использовала
        7 бит, что позволяло закодировать 128 символов (кодовых точек). Из языков туда помещался только латинский.
        Для того, чтобы преодолеть огричения, начали разрабатывать кучу 8-битных кодировок, первые 128 бит, которых
        повторяли ASCII, а оставшиеся 128 бит отдавали под прочие символы и алфавиты. Например, Latin-1 предоставляет
        символы для большинства европейских языков.

        +-------+
        | ASCII |
        +-------+-------------------------------+----------------------------+
        |                                       | <32 управляющих символа>   |
        | Знаки пунктуации:                     | <пробел>!"#$%&'()*+,-./    |
        | Цифры:                                | 0123456789                 |
        | Ещё знаки:                            | :;<=>?@                    |
        | Латинский алфавит в верхнем регистре: | ABCDEFGHIJKLMNOPQRSTUVWXYZ |
        | Ещё знаки:                            | [\]^_`                     |
        | Латинский алфавит в нижнем регистре:  | abcdefghijklmnopqrstuvwxyz |
        | Ещё знаки:                            | {|}~                       |
        +---------------------------------------+----------------------------+

        Для того, чтобы преодолеть и эти ограничения, в начале 90х был разработан стандарт Universal Character Set (UCS),
        который позволял кодировать каждый символ 32 битами (стандарт ISO 10646). UCS определяет соответсвие между
        кодируемыми символами и их числовыми кодами (кодовыми точками).

        <послед._символов> -----> (UCS) -----> <послед._кодовых_точек> -----> (кодировка_UTF-8/16/32) -----> <послед._байт>

        Universal Character Set (UCS) - стандартизированный набор символов, определяемый стандартом ISO 10646. Поскольку
        он разрабатывается в тесном сотрудничестве со стандартом кодирования Unicode, то наборы сиволов в обоих
        стандартах идентичны.

        Помимо самого набора символов ISO 10646 определяет ещё и несколько способов их кодирования (encoding forms).
        Один из этих способов - 16-битная кодировка UCS-2. Эта кодировка способна закодировать 2 ^ 16 = 65536 символов.
        То есть всю Basic Multilingual Plane (BMP).

        Первая поправка к UCS добавила кодировку UTF-16 в качестве расширения к UCS-2. В рамках BMP (65536 кодовых точек)
        UTF-16 полностью совместима с UCS-2. Но для того, чтобы кодировать символы выходящие за рамки BMP использована
        следующая схема: ближе к концу BMP специальным образом выбраны два интервала кодовых точек, стандарт запрещает
        размещать в них символы. Кодовые точки из первого интервала называются нижней сурогатной парой, а кодовые точки
        из второго – верхней сурогатной парой. Сложив их вместе определённым образом, UTF-16 получает кодовые точки
        выше BMP.

        Ещё один способ кодирования символов - UCS-4. Эта кодировка использует фиксированные 4 байта для кодирования символов,
        что теоретически позволит закодировать 0x7FFFFFFF символов, но стандарт определяет предел в 0x10FFFF.

        Итак:
        - UCS - универсальный набор символов, который используется стандартами UCS (ISO 10646) и Unicode.
        - UCS-2 - самая первая кодировка фиксированной ширины - 16 бит. Может закодировать 2 ^ 16 = 65536 символов (всю BMP).
        - UCS-4 - вторая кодировка фиксированной ширины - 32 бита. Может закодировать 2 ^ 32 = 0x7FFFFFFF символов, но ограничена 0x10FFFF.
        - UTF-16 - кодировка переменной ширины, является расширение UCS-2, то есть полность совместима с ней при кодировании
          всей BMP, но дальше использует механизм сурогатных пар.
        - UTF-8 - кодировка переменной ширины, которая совместима с ASCII, в отличие от других кодировок стандарта.
          Кроме того, у этой кодировки отсутствует проблема порядка следования бит, и, как следствие, – BOM.

        UCS-2 и UCS-4 устарели.
        UTF-16 используется редко, в основном в Windows, Java и Javascript.
        UTF-32 используется реже всего.
        UTF-8 доминирует в мире.
                                                                      ~84%                ~85%                ~87%
        +------------------------------------------------------------------------------------------------------------------+
        | 0                                                             | D800 ....... DBFF | DC00 ....... DFFF |     FFFF | 
        +---------------------------------------------------------------+-------------------+-------------------+----------+
                                                                        |  High Surrogates  |  Low Surrogates   |
                                                                        +-------------------+-------------------+

        0x10000 + 0xFFFFF = 0x10FFFF - максимум кодируемых символов (~1.1 млн)

        --

        UTF-16

        // Кодирование в UTF-16
        codePoint = 0x10437
        H = (0x0437 >> 10) + 0xD800    // 0xD801
        L = (0x0437 & 0x3FF) + 0xDC00  // 0xDC37

        // Декодирование из UTF-16
        H = 0xD801
        L = 0xDC37
        codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000  // 0x10437

        Unicode определяет абстрактные символы и присваивает ему порядковый номер в таблице - кодовую точку.
        Кодовые точки лежат в диапазоне от 0 до 0x10FFFF (1 114 112) вне зависимсоти от кодировки.
        0x10FFFF - 21 бит.

        --

        UTF-8:
        - Полностью совместима с ASCII
        - Использует 1-4 байта для кодирования символов
        - 


        --


        Источники:
        - https://en.wikipedia.org/wiki/Universal_Coded_Character_Set
        - https://en.wikipedia.org/wiki/Unicode
        - https://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings
        - https://en.wikipedia.org/wiki/UTF-8
        - https://en.wikipedia.org/wiki/UTF-16
        - https://en.wikipedia.org/wiki/UTF-32
        - https://codeahoy.com/2016/05/08/the-char-type-in-java-is-broken/


        // -------------------------------------
        // СТРОКИ И КОДИРОВКИ
        // -------------------------------------

        <СТАРОЕ_ОПИСАНИЕ>

        ASCII - 7-битная кодировка, которая может отображать символы 0-127.
        ISO-8859-1 и the latin-1 - 8-битные кодировки, отображающие 0-255 символы, перые 128 символов совпадают с ASCII.

        В таблицах символов коды символов правильно называются codepoints, а сами таблицы - code pages.
        Сами по себе codepoints являются обычными числами, а их представление в памяти выражено в
        encoding scheme. Еncoding scheme определяет, сколько байт использовать для каждой codepoint
        в памяти. Это число может быть постоянным (2 байта на codepoint) или динамическим (1/2/3 байта на символ).
        Набор символов, за каждым из которых закреплена codepoint, в code pages называется character set.

        Unicode - кодировка, в code pages которой есть codepoints для всех известных человеку символов, в том числе для всех языков.
        Каждая codepoint в юникоде имеет свой порядковый номер в формате U+0048 ('\u0048'), где 48 - hex (символ H). 
        Первые 256 codepoints соотвествуют latin-1, а первые 128 символов - ASCII.
        Все codepoints в юникоде разделяются на области (planes) по 2 ^ 16 (65536) codepoints на каждую область.
        Первый plane (0 - 0xFFFF) называется Basic Multilingual Plane (BMP) и покрывает все человеческие языки.

        UNICODE

        У Unicode несколько сосуществующих стандартов кодирования codepoints:
        - UTF-8: в этом стандарте используется схема кодирования переменной длины: 
          первые 127 символов (codepoints) (U+0000 - U+007F) кодируются 7 битами в соответствии с ASCII.
          для всех остальных codepoints специальный escape-символ заставляет интерпретировать следующие за ним байты
          для отображения codepoints требующих больше 8 бит для кодирования. Фактически UTF-8 не совместим с latin-1.
        - UTF-16: использует 16 бит для кодирования codepoints, что позволяет последовательно закодировать 
          2 ^ 16 (65536) codepoints, то есть весь Basic Multilingual Plane (BMP). Но UTF-16 также может кодировать и 
          codepoints >65536 с помощью специальной хитрой схемы:
          По стандарту юникод резервирует два интервала codepoints в BMP: 
          - High Surrogates (HS): от U+D800 до U+DB7F
          - Low Surrogates (LS): от U+DC00 до U+DFFF
          И для кодирования codepoints >65536 использует пары codepoints из HS и LS:
          левый элемент пары выражается codepoint из HS, а правый - codepoint из LS: например, U+D800U+DC00.
          Такие пары называются сурогатными. Как только декодер натыкается на codepoint из HS, он понимает ,что имеет дело с 
          сурогатной парой, нужно считать следующий LS-codepoint и декодировать их вместе особым образом.
        - UTF-32: просто использует 32 бита для кодирования codepoints, что позволяет выразить 2 ^ 32 (4294967296) codepoints.

        BOM

        Для многобайтных кодировок (UTF-16 и UTF-32) важно указать порядок следования байт (Big Endian или Little Endian).
        Есть два варианта как это сделать:
        - Использовать BOM (Byte order mark): в начало текста поместить символ U+FEFF, который не имеет визуального представления.
          Этот символ даёт понять декодеру, что он сам должен определить порядок следования байт.
        - Если BOM не задействован, то необходимо указывать порядок следования битов в самой кодировке (UTF-16BE/UTF-16LE, UTF-32BE/UTF-32LE)

        </СТАРОЕ_ОПИСАНИЕ>


        ГЛОССАРИЙ

        - Октет - 8 смежных бит, вместе образующих кусок данных. В большинстве архитектур
          соответствует одному байту.
        - Абстрактный символ (Abstract character) - графическое представление символа.
        - Кодовое пространство - диапазон целых чисел, каждому из которых может соответствовать
          его абстрактный символ. Другими словами, это код символа в наборе символов.
        - Кодовая точка - любое число из кодового пространства (код символа в наборе символов).
        - Закодированный символ (Encoded character) - абстрактный символ, которому 
          поставлена в соответствие кодовая точка.
        - Кодовая единица (Code unit) - минимальное количество бит, которыми может быть 
          закодирован один символ текста.
        - Кластер графем (Grapheme cluster) - последовательность закодированных символов,
          которые визуально (для пользователя) являются одним символом.
        - Набор символов (Character set/Charset) - конечное множество закодированных 
          символов.
        - Кодовая страница (Code page) - частный случай набора символов. В отличие от 
          набора символов, который выражает множество всех закодированных символов данной
          кодировкой, кодовая страница выражает подмножество этого множества, которое
          может быть закодировано одной кодовой единицей. Таким образом, если набор символов
          текущей кодировки превышает одну кодовую страницу, то этот набор делится на
          несколько кодовых страниц. В однобайтовых кодировках набор символов совпадает 
          с кодовой страницей. В Windows понятие кодовой страницы имеет особое значение
          для локализации ОС, так как для неё Юникод не является основным стандартом 
          кодирования, и для каждой локали используются разные кодовые страницы, например 
          Windows-12XX и CP-XXX. Так в Windows 7 для русскоязычной командной оболочки CMD 
          используется кодовая страница CP866.


        УСТРОЙСТВО КОДИРОВОК

        В таблицах символов коды символов называются кодовыми позициями (code points), 
        а сами таблицы - кодовыми страницами (code pages). Сами по себе кодовые позиции 
        являются обычными числами, и они не определяют, как символы представлены в памяти. 
        Их представление в памяти задаётся схемами кодирования (encoding scheme), которые
        определяют, сколькими байтами представляется каждая кодовая позиция в памяти. 
        Например, одна схема кодирования может представлять кодовую позицию в памяти 
        с помощью 4-байт, а другая – переменным количеством байт: для наиболее часто 
        используемых символов - 2 байта, а для более редких - 3 или 4 байта. Символы, 
        расположенные в кодовых страницах, называются наборами символов (character set).


        НЕКОТОРЫЕ КОДИРОВКИ И КОДОВЫЕ СТРАНИЦЫ

        - ASCII - набор символов, кодовая страница и кодировка, использующая для кодирования
          один октет, старший бит которого всегда равен 0, а оставшиеся 7 бит кодируют 
          кодовые позиции 0-127. Позднее были разработаны многие другие 1-байтовые кодировки, 
          которые задействовали все 8 бит октета. Наборы символов этих кодировок содержат
          уже до 2 ^ 8 (256) кодовых позиций, первые 128 из которых идентичны соответствующим 
          кодовым позициям ASCII, а оставшиеся 128 используются для кодирования специфичных
          для этих кодировок кодовых позиций. То есть, эти кодировки совместимы с ASCII.
          К таким кодировкам относятся Latin-1, КОИ-8, CP866, Windows-1251, ISO-8859-1 и т.д.
        - CP866 - кодовая страница, разработанная в СССР для поддержки кириллицы. Полностью
          совместима с ASCII и для кодирования новых кодовых точек использует значения байтов
          со 128 до 255. Является стандартной для Windows 7 CMD.
        - ANSI-кодировка - превдоним для внутренней кодировки Windows, которая зависит 
          от текущей локали ОС. Например, если локаль "ru-RU", то ANSI-кодировкой будет
          Windows-1251, которая поддерживает кириллицу. Также эта используется ОС в качестве 
          кодировки по умолчанию для программ, не поддерживающих Юникод. Не смотря на то, 
          что имеет название идентичное стандарту ANSI, никакого отношения к нему не имеет.
        - OEM-кодировка - подобие ANSI-кодировки, но используется для командной строки.
          Например, локали "ru-RU" соответствует OEM-кодировка CP866.


        ЮНИКОД

        Юникод - стандарт, который включает в себя набор символов и 3 схемы кодирования.

        Юникод включает в себя набор символов, который называется "Стандартизованный набор 
        символов" (Universal Character Set, UCS). Этот набор целиком разбит на диапазон
        целых положительных чисел от 0 до 0x10FFFF. Этот диапазон называется "кодовым 
        пространством Юникода" (Unicode codespace), а сами числа "кодовыми точками" (Code 
        points). Например, U+0067, U+007F, U+1F428. Каждой кодовой точке может быть назначено 
        одно графическое представление, которое называется "абстрактным символом" (Abstract 
        character). Абстрактным символом также считается любой символ из реального мира, 
        который не добавлен в набор символов Юникода, но потенциально мог бы. Кодовые 
        точки 0-127 совпадают с соответствующими кодовыми точками ASCII, а кодовые точки 
        0-255 – с соответствующими кодовыми точками Latin-1. Кодовое пространство Юникода 
        разделено на 17 (0-0x10) "плоскостей" (planes) по 2 ^ 16 (65536) кодовых точек 
        в каждой. 4 правые цифры кодовой точки соответствуют его порядковому номеру 
        в плоскости (0-0xFFFF), а те цифры, которые находятся левее этих четырёх, означают 
        порядковый номер плоскости (0-0x10), именно поэтому кодовое пространство Юникода 
        разбито на диапазон 0-0x10FFFF. Например, кодовая точка U+0067 представляет символ 
        0x0067 из плоскости 0 ("g"), а кодовая точка U+1F428 представляет символ 0xF428 
        из плоскости 0x1 (символ "KOALA"). Самая первая плоскость (plane 0) называется 
        "основной многоязычной плоскостью" (Basic Multilingual Plane, BMP) и содержит 
        в себе большинство основных символов для всех письменностей мира, а также многие 
        исторические и редко используемые символы. На сегодняшний день большинство всех 
        символов Юникода для почти всех текстовых данных можно найти в BMP. Кроме того, 
        кодовое пространство Юникода разделено на 291 "блок" (Block) разного размера, 
        которые можно рассматривать как категории различных символов. 
        Например, 0x0000-0x007F: Basic Latin; 0x0080-0x00FF: Latin-1 Supplement. 
        Текст, который по сути представляет из себя последовательность кодовых точек, 
        для обработки и хранения компьютером преобразуется в последовательность байт.
        Этот процесс выполняют кодировки (Unicode Transformation Format, UTF), которых 
        в стандарте Юникод три. Каждая из них задаёт "кодовую единицу" (Code unit) - 
        минимальное количество бит, которым может быть закодирован один символ текста.

        В 1988 году был опубликован черновик первой версии стандарта Юникод, в которой 
        авторы наивно предполагали, что 16 бит будет достаточно для кодирования кодовых 
        точек, представляющих все возможные языки и прочие символов. В 1991 опубликовали 
        Юникод 1.0, а саму кодировку назвали UCS-2, где "2" означает, что каждая кодовая 
        точка кодируется строго двумя октетами. Это означает, что UCS-2 фактически была 
        кодировкой фиксированной ширины. Очень быстро на Юникод/UCS-2 переключились многие 
        проекты и IT-компании, в том числе и Qt (1992), Windows NT 3.1 (1993) и Java (1995).
        Вскоре выяснилось, что 16 бит на кодовую точку не достаточно, и в 1996 вышел 
        стандарт Юникод 2.0, в котором кодовое пространство было расширено и разбито на 
        17 плоскостей. Кроме того, была введена кодировка UTF-16, полностью совместимая 
        с UCS-2 и исправлявшая её недостатки. Однако, UTF-16 в отличие от UCS-2 не была
        полностью кодировкой фиксированной ширины: строго 16 битами кодировались только
        первые 2 ^ 16 (65536) кодовых точек (BMP), а последующие – суррогатными парами.
        Помимо этого, Юникод 2.0 получил новые механизмы кодирования символов, с которыми 
        могла взаимодействовать UTF-16 и не могла UCS-2.

          1. UTF-8: в этом стандарте используется схема кодирования переменной длины: 
             Первые 127 кодовые позиции (U+0000 - U+007F) кодируются 7 битами в соответствии 
             с ASCII. Для всех остальных кодовых позиций специальный escape-символ 
             заставляет интерпретировать следующие за ним байты для отображения кодовых 
             позиций требующих больше 8 бит для кодирования. Фактически UTF-8 не совместим 
             с Latin-1.
          2. UTF-16 (ранее USC-2): использует 16 бит для кодирования codepoints, что 
             позволяет последовательно закодировать 2 ^ 16 (65536) codepoints, то есть 
             весь Basic Multilingual Plane (BMP). Но UTF-16 также может кодировать и 
             codepoints >65536 с помощью специальной хитрой схемы:
             По стандарту юникод резервирует два интервала codepoints в BMP: 
             - High Surrogates (HS): от U+D800 до U+DB7F
             - Low Surrogates (LS): от U+DC00 до U+DFFF
             И для кодирования codepoints >65536 использует пары codepoints из HS и LS:
             левый элемент пары выражается codepoint из HS, а правый - codepoint из LS: 
             например, U+D800U+DC00. Такие пары называются суррогатными. Как только декодер 
             натыкается на codepoint из HS, он понимает, что имеет дело с суррогатной парой, 
             нужно считать следующий LS-codepoint и декодировать их вместе особым образом.
          3. UTF-32 (ранее UCS-4): просто использует 32 бита (4 байта) для кодирования 
             кодовых позиций, что позволяет выразить 2 ^ 32 (> 4 млдр) кодовых позиций. 
             Эта кодировка удобная для работы со строками в языках программирования 
             в силу своей простоты, но не слишком удобна для хранения текстов, т. к. 
             использует много памяти для кодирования каждого символа.


        BOM

        Для многобайтных кодировок (UTF-16 и UTF-32) важно указать порядок следования 
        байт (Big Endian или Little Endian).
        Есть два варианта как это сделать:
        - Использовать BOM (Byte order mark): в начало текста поместить символ U+FEFF, 
          который не имеет визуального представления. Этот символ даёт понять декодеру, 
          что он сам должен определить порядок следования байт.
        - Если BOM не задействован, то необходимо указывать порядок следования битов 
          в самой кодировке (UTF-16BE/UTF-16LE, UTF-32BE/UTF-32LE)

        ПРИМЕР

        Unicode-символ "снеговик" (U+2603) кодируется в UTF-8 как трехбайтовая 
        последовательность: 0xE2 0x98 0x83, а его эквивалент в UTF-16 является одной 
        16-битной кодовой единицей 0x2603. Unicode-символ "кружка пива" (U+1F37A), 
        находящийся вне BMP, кодируется в UTF-8 как четырехбайтовая последовательность: 
        0xF0 0x9F 0x8D 0xBA, а в UTF-16 использует две 16-битные кодовые единицы-суррогатные 
        пары: 0xD83C 0xDF7A.


        ПЛЮСЫ И МИНУСЫ КОДИРОВОК ЮНИКОДА
        - UTF-8
          + Не зависит от порядка следования байт.
          + При лексикографической сортировке даёт правильный порядок символов.
          + Тратит 8 бит на кодирование ASCII-символов, которые являются наиболее частыми.
          + Совместима с ASCII.
        - UTF-16
          - По сути, костыль для UCS-2, выбор которого был ошибкой проектирования.
          - Зависит от порядка следования байт.
          - Widechar-тип в C++ по стандарту не имеет размера, поэтому для UTF-16 он
            подходит только в Windows-системах, где этот тип имеет 16 бит (в UNIX он
            имеет размер 32 бита). 
          - При лексикографической сортировке даёт неправильный порядок символов.
          - Отдаёт предпочтние в компактности кодирования нескольким блокам азиатских 
            символов, что неэффективно, так как чаще всего в тексте встречаются символы
            ASCII.
          - Часто по ошибке используется как кодировка фиксированной ширины, поэтому как
            только встречаются сурогатные пары, софт интерпретирует их как два разных
            символа, которые даже не имеют представления в наборе символов Юникода.
          - Не совместима с ASCII.
        - UTF-32
          + Наиболее проста в использовании.
          + При лексикографической сортировке даёт правильный порядок символов.
          - Избыточная кодировка, использующая для кодирования каждого символа по 32 бита.
          - Не совместима с ASCII.


        БАЙТЫ И СИМВОЛЫ

        Условно говоря, строки бывают в двух состояниях:
        - Последовательность символов/текст/строка. То есть мы имеем дело с последовательностью 
          незакодированных кодовых точек из таблицы какой-то кодировки. Какой именно кодировке 
          принадлежит эта таблица символов, зависит от интерпретатора языка, компилятора или ОС.
          Например, в Python 3 в качестве набора символов для реализации использует набор 
          сиволов Юникода. Поэтому строковые литералы можно записывать по разному: 
          u"абв" == "абв" == "\u0430\u0431\u0432". Все эти три способа записи являются 
          текстом, то есть последовательностью кодов символов.
        - Последовательность байт. Берётся символ из текста, определяется его код в таблице 
          символов какой-то кодировки. Этот код кодируется кодировкой, и на выходе получается
          один байт или последовательность из нескольких байт. Алгоритм повторяется для
          всех символов строки, и получившиеся байты выстраиваются в одну последовательность.
          Эту последовательность невозможно отобразить в виде текста, так как символы 
          закодированы. Важно знать, какой кодировкой закодирована эта последовательность,
          чтобы можно было правильно произвести процесс декодирования и отобразить символы.

        Пример: в Python 3 текст имеет тип "str" и является неизменяемой последоветльностью 
        кодовых точек из таблицы Юникода. str выглядит так "абв" или так u"абв" (оба варианта
        эквивалентны, но второй является избыточным). Но для того, чтобы компьютер мог
        оперировать этими строками, передавать их или записывать в файл, их нужно закодировать
        в последовательность байт с помощью какой-то кодировки: 
        >>> "абв".encode('utf-8')  # кириллица
        b'\xd0\xb0\xd0\xb1\xd0\xb2'
        На выходе получается последовательность байт. В данном случае, каждая кодовая 
        позиция закодирована двумя байтами.
        Может полуиться и так:
        >>> "abc".encode('utf-8')  # латиница
        b'abc'
        Возникает вопрос: почему Python в предыдущем случае вывел байты в виде экранированных
        шестнадцатеричных значений, а в этом случа - в виде сиволов. Дело в том, что все
        кодировки совместимы с ASCII, которая однозначно определяет коды для 128 символов.
        Поэтому в таблице каждой кодировки первые 128 кодовых точек (0-127) идентичны.
        При этом каждая кодовая точка кодируется 1 байтом, а точнее, 7 битами. Соответственно
        если в получившейся при кодировании последовательности байт есть байты, имеющие
        значение от 0 (0x0) до 127 (0x7f) то их можно однозначно интерпретировать как символы 
        из таблицы ASCII. Те байты, которые имеют значения больше 127, уже не в компетенции
        ASCII – они зависят от кодировки и не могут быть однозначно интерпретированы,
        поэтому Python выводит их в виде \xXX.

        Итак:
        Это текст без кодировок:  u"абв" == "абв" == "\u0430\u0431\u0432"
        Это он закодирован UTF-8: b'\xd0\xb0\xd0\xb1\xd0\xb2'


        СТРОКИ И КОДИРОВКИ В C++

        В начале развития стандарта Юникод в C++ был введён новый тип символа - wchar_t, 
        по определению являющийся целочисленным типом с диапазоном, достаточным для 
        представления всех символов, доступных на данной системе. Так как поначалу 
        предполагалось, что Юникоду хватит 16 бит для представления всех номеров UCS, 
        в некоторых системах (например, Windows) был закреплён 16-битный wchar_t. 
        В современных GNU/Linux-системах используется 32-битный wchar_t, подходящий для 
        кодировки UTF-32. В связи с введением в обиход различных кодировок UTF и отсутствием 
        совместимости между различными системами при использовании wchar_t, в C++11 были 
        добавлены два новых символьных (целочисленных) типа: char16_t для 16-битных кодировок 
        (UCS-2, UTF-16) и char32_t для 32-битных кодировок (UTF-32). Возможно введение 
        в будущем стандарте типа char8_t, пока же для представления единиц кодирования 
        строк в кодировке UTF-8 используется тип char.

        Символьный литерал - один символ в одинарных кавычках: 'a', '2', '+', '\x5c' (hex), '\134' (oct)
        Строковой литерал - строка в двойных кавычках: "hello", "z", "zzzz"

        При записи непосредственно символа в литерал, компилятор может оставить код в той 
        кодировке, в которой символ был введён, либо преобразовать в некоторую кодировку 
        по умолчанию. Например, исходный код может быть набран в кодировке UTF-8, в которой 
        кириллические знаки записываются двухбайтными кодами, но компилятор Visual C++ 
        при оформлении символьного литерала типа char (один байт) преобразует их к 
        кодировке Windows-1251.


        СОВЕТЫ

        - I/O всегда в байтах (utf-8)
        - Файлы всегда читать и писать в binary mode
        - Концы строк на всех платформах обозначать через \n, и писать в файл в binary mode
        - Всегда использовать #define UNICODE и #define _UNICODE или Project Preferences ->
          -> General -> Use Unicode Character Set -> Yes, чтобы компилятор выдавал ошибку
          там, где Windows API-функция ожидает ANSI-строку, а мы ей пытаемся передать 
          обычную utf-8 char* строку. В этих местах нужно использовать функции явного 
          преобразования типов строк narrow() / widen().
        - Избегать fopen() из соображений RAII/OOD. Если необходимо, использовать _wfopen().
          ? http://utf8everywhere.org/#how.files
        - Всегда использовать char*/std::string для всех строк внутри программы
        - Строковой литерал в utf-8 можно записать следующими способами:
          - В виде С++11 utf-8 литерала: u8"Хай!"
            В этом случае независимо от кодировки ОС и компилятора, литерал будет в UTF-8.
          - В виде последовательности байтов: "\xd0\xa5\xd0\xb0\xd0\xb9!"
          - Просто записать литерал в виде строки и сохранить в utf-8: "Хай!"
            В этом случае кодировку литерала определяет компилятор вместе с ОС. Например,
            компилятор MSVC сконвертирует эту строку в какую-то кодовую страницу ANSI, 
            и тем самым повредит строку. В этом случае, нужно сохранить файл исходника 
            в utf-8 без BOM. Это решит проблему, но так же сделает невозможным использование 
            Юникодовых идентификаторов \uXXXX и wchar_t-литералов L"". Но эти вещи и 
            не нужны.

        ----------------------------------

        - #include <cstring> для использования функций strlen, strcpy, strcat и тд. для строк char[]
        - #include <string> для использования std::string
        - С объектом cout имя char-массива, указатель на char и строковая константа интерпретируются как адрес первого символа строки
        - В строках, хранимых в char[] нельзя забывать про нулевой символ
        - string:
        - можно инициализировать с помощью char[]-строк
        - string можно соединять через +
        - к отдельным символам можно обращаться через индекс, как у массивов
        - длина строки: str.size()
        - Указатели в строках:
        char text[]{ "Hello" };
        const char *text{ "Hello" };
        char *text = new char[6];
        - Кодировка: utf-8  / Тип: char (1 байт/8 бит)        / Литерал: u8""  // char* utf8String = u8"С Новым Годом!";
        Кодировка: utf-16 / Тип: char16_t (2 байта/16 бит)  / Литерал: u""   // char16_t* utf16String = u"С Новым Годом!";
        Кодировка: utf-32 / Тип: char32_t (4 байта/32 бита) / Литерал: U""   // char32_t* utf32String = U"С Новым Годом!";

        std::string    == typedef basic_string<char> string;          // C++98; тип строки: string;    одна кодовая позиция выражается типом: char      // Подходит для utf-8
        std::wstring   == typedef basic_string<wchar_t> wstring;      // C++98; тип строки: wstring;   одна кодовая позиция выражается типом: wchar_t   // Подходит для utf-16 в Windows
        std::u16string == typedef basic_string<char16_t> u16string;   // C++11; тип строки: u16string; одна кодовая позиция выражается типом: char16_t
        std::u32string == typedef basic_string<char32_t> u32string;   // C++11; тип строки: u32string; одна кодовая позиция выражается типом: char32_t

          "text"     char *                                                                                    C90
          "text"s    std::string s                                                                             C++98
        u8"text"     char *                        std::string    (typedef basic_string<char> string)          C++98
         L"text"     wchar_t  *    wchar_t  s[]    std::wstring   (typedef basic_string<wchar_t> wstring)      C++98
         u"text"     char16_t *    char16_t s[]    std::u16string (typedef basic_string<char16_t> u16string)   C++11
         U"text"     char32_t *    char16_t s[]    std::u32string (typedef basic_string<char32_t> u32string)   C++11
         R"te\xt"    

         !!! char, wchar_t, char16_t, char32_t HOLD VALUES OF CODE UNITS

        * Для wchar_t стандарт не определяет размер, поэтому в компиляторе VS sizeof(wchar_t) == 2, а в GCC sizeof(wchar_t) == 4,
          поэтому std::wstring / wchar_t подходит для utf-16 только в Windows, и использование этого типа для представления utf-16
          делает код не кросс-платформенным. Для Windows API родной кодировкой является UTF-16, поэтому std::wstring / wchar_t идеально
          подходит для кода, специфичного для Windows.

        - R"(This string is "raw" string)";
        - Префикс R скомбинированный с другими префиксами

        std::basic_string<T> - шаблонный класс похожий на контейнер, который позволяет 
        создать строку, каждый символ в которой будет представлен типом T (любой POD-тип).

        На кодировки влияют:
        - Кодировка файла исходного кода
        - Особенности различных компиляторов
        - BOM

        * Что такое ANSI
        * Что такое BOM
        * рассмотреть все префиксы и суффиксы https://blogs.msmvps.com/gdicanio/2018/05/28/how-many-strings-does-c-have/
        * рассмотреть конвертеры кодировок
        * как BOM вляет на исходники
        * почему не важен порядок байт в UTF-8 -> UTF-8 has no endianness issues, and the UTF-8 BOM exists only to manifest that this is a UTF-8 stream.
        * различия между символьными и строковыми литералами и как они соотносятся
        * разница между типами byte и "текст", как это реализовано в Python 2 и 3
        * отличие мультибайтовых строк от широких
        * narrow() / widen() (http://utf8everywhere.org/#windows)

        * Посмотреть реализацию строк в проектах:
          - Unreal Engine: 
            Runtime\Core\Private\Containers\String.cpp, 
            Runtime\Core\Public\Containers\UnrealString.h, 
            Runtime\Core\Public\Containers\StringConv.h
          - Qt:
            utils\unicode\*
            src\corelib\tools\qchar.cpp
            src\corelib\tools\qstring.cpp

        Статьи:
        - https://habr.com/post/257895/
          - Экскурс в историю кодировок
          - Об ICU (ICU4C) и iconv

        Если посмотреть на Python 3 в сравнении с Python 2, то третья версия совершила по-настоящему серьезный скачок в развитии, разделив эти два понятия. Крайне рекомендую даже опытному C/C++ разработчику поработать немного в Python 3, чтобы ощутить всю глубину, с которой произошло разделение текста и байтов на уровне языка в Python. Фактически текст в Python 3 отделен от понятия кодировки, что для разработчика C/C++ звучит крайне непривычно, строки в Python 3 отображаются одинаково в любой точке мира, и если мы хотим работать с представлением этой строки в какой-либо кодировке, то придется преобразовать текст в набор байтов, с указанием кодировки. При этом внутреннее представление объекта типа str, по сути, не так важно, как понимание, что внутреннее представление сохранено в Юникоде и готово к преобразованию в любую кодировку, но уже в виде набора байтов типа bytes.

        Как в проектах реализованы строки
        - Banshee Game Engine: String - обёрнутая string для ASCII, WString - обёрнутая wstring для Unicode
        - Unigine 2010: char
        - Unreal Engine 4: макрос TEXT: L"String"s, FString


        // -------------------------------------
        // УСТРОЙСТВО ПАМЯТИ И УКАЗАТЕЛИ
        // -------------------------------------

        // Ссылки:
        // https://rsdn.org/article/cpp/ObjectsAndPointers.xml
        // https://www.wikiwand.com/ru/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8

        Адрес памяти - адрес байта.
        Адресное пространство - непрерывный диапазон ячеек, доступный для адресации в конкретной операционной системе.
        Адресное пространство можно представить ввиде упорядоченных вертикально ячеек, адресованных снизу вверх.

        Оперативная память делится на 4 типа:
        - Статическое хранилище - выделяется при запуске программы до вызова функции main, а освобождается после завершения работы функции main (на стадии завершения всей программы).
          Этот вид памяти используется для хранения ГЛОБАЛЬНЫХ и статических (static) объектов, констант и объектов, определённых в пространствах имён.
          Статической памятью управляет компилятор.
          Объекты в этой области памяти живут на протяжении всего времени работы ПРОГРАММЫ.
        - Автоматическое хранилище - располагается в стеке; этот вид памяти выделяется и освобождается на тех же стадиях, что и статическая, но используется для хранения ЛОКАЛЬНЫХ объектов.
          Стек работает по принципу LIFO. Стек определяется двумя указателями: первый указывает на начало стека и не сдвигается во время выполнения программы (?). 
          Второй - указывает на вершину стека. У каждой программы свой стек. Размер стека всегда ограничен. Для программ, разработанных в Visual Studio ограничение составляет 1 Мб.
          Обычно говорят, что стек растёт вверх в соответствии с увеличением адресов памяти.
          Но на архитектуре x86 стек растёт вниз - в сторону уменьшеня адресов памяти.
          Стеком управляет компилятор.
          Объекты в этой области памяти живут на протяжении всего времени работы ФУНКЦИИ.
        - Динамическое хранилище - располагается в куче; многократно выделяется и освобождается на протяжении всей работы программы.
          В C++ место в динамической памяти выделяет оператор new, освобождает оператор delete, а доступ к выделенным областям осуществляют указатели (*) и ссылки (&).
          ! Оператор delete освобождает динамически выделенную память, на которую указывает указатель, а не удаляет указатель.
          При выделении памяти отыскивается ближайшая подходящая по размеру область.
          Динамической памятью управляет программист.
          Объекты в этой области памяти живут с new до delete.
        - Хранилище потока - ?

        Примечания:
        - Объект, на который указывает указатель, может находиться как в любой из трёх областей памяти. Но сам указатель находится в стеке.
        - Оператор delete освобождает динамически выделенную память, на которую указывает указатель, а не удаляет указатель.
          После этой операции указатель становится "недействительным" - продолжает указывать на ту область, которая уже не пренадлежит программе.
          Если есть желание переиспользовать указатель после delete, лучше явно указать, что этот указатель больше ни на что не указывает (p = nullptr) (после delete).

        Указатель, созданный локально в функции, уничтожается при выходе из функции, т. к. он хранился в стеке. 

        Регион > область > блок памяти - непрерывные последовательности ячеек памяти.

        // --------------------------

        УКАЗАТЕЛИ

        // Темы:
        // - Указатели на stack-память
        // - Указатели на heap-память
        // - Указатели без инициализации
        // - Указатели со всеми видами инициализации
        // - Указатели на примитивные типы
        // - Указатели на массивы
        // - разница между указаталем на первый элемент массива и на весь массив
        // - Указатели на строки
        // - Многомерные массивы указателей на простые и сложные типы
        // - Освобождение памяти многомерных массивов и строк
        // - Арифметика указателей
        // - Указатели на (строковые) константы и константные указатели
        // - Указатели в качестве элементов списка инициализации
        // - Поведение массивов и строк в выражениях, и с cout/cin
        // - Как указатели на разные типы интерпретируются в разных ситуациях
        // - Указатели на функции

        - Указатель - переменная, хранимая в стеке, указывающая на данные, расположенные в стеке или в куче.
        - Прямое значение указателя - адрес
          Косвенное значение указателя - начение в памяти
        - Объявление указателя легче читать справа налево
        - Имя массива является указателем
        - Имя функции является указателем
        - Разыменовывание нулевого указателя приводит к неопределённому поведению
        - <type> const == const <type>
        - Указатель типа const <type>* может указывать как на константу, так и на переменную

        int num = 5;       // Обычная переменная

        // Создание указателя с инициализацией и без
        int *p;                  // Создание указателя на данные типа int; без инициализации
        int *p = &num;           // Создание указателя на данные типа int; указатель указывает на переменную num, хранимую в стеке
        int *p = new int;        // Создание указателя на данные типа int; указатель указывает на выделенную heap-память типа int, в которой хранится мусор
        int *p = new int{ 10 };  // Создание указателя на данные типа int; указатель указывает на выделенную heap-память типа int, в которой хранится число 10

        // Присваивание нового значения указателю
        p = &num;          // Теперь указатель укаызвает на переменную num, которая хранится в стеке
        p = new int;       // Создание указателя на данные типа int; указатель указывает на выделенную heap-память типа int, в которой хранится мусор
        p = new int{ 10 }; // Теперь указатель укаызвает на данные типа int, расположенные в куче

        // Указатель на указатель
        int *p = &num;                     // Указатель на переменную
        int **pp = &p;                     // Указатель на указатель на переменную
        int ***ppp = &pp;                  // Указатель на указатель на указатель на переменную
        *p == **pp == ***ppp == num == 5   // Разыменовывание указателей

        // Указатель на функцию
        int func (int, int);            // Прототип функции
        int (*pFunc)(int, int) = func;  // Указатель на эту функцию

        // ПРИМЕРЫ
        int *const p;                       // указатель-константа
        const int *p;                       // указатель на константу
        const int *const p;                 // указатель-константа на константу
        int const *const p;                 // указатель-константа на константу (то же самое, что и предыдущий пример)
        const int *const * *const * * * x;  // указатель на указатель на указатель на константный указатель на указатель на константный указатель на int-константу


        // ----------------

        // Базовое использование
        int *p;              // указатель на переменную типа int
        int *const p;        // указатель-константа на переменную типа int, ему нельзя присвоить другой адрес
        const int *p;        // указатель на константу типа int
        const int *const p;  // указатель-константа на константу типа int

        // Использование с выделением памяти
        int *p = new int;       // выделение памяти в куче посредством оператора new и присваивание адреса указателю p
        int *p = new int{ 5 };  // то же самое, только с иициализацией
        *p = 10;                // присваивание нового значения указателю
        delete p;               // ! освобождает память, выделенную оператором new, а не удаляет указатель. Указатель продолжает указывать на тот же адрес.
        int *p = new int[100];  // выделение памяти для массива из 100 элементов типа int
        delete []p;             // освобождение памяти из-под массива

        int *p;
        p = (int *)0xB8000000;  // присваивание указателю нового адреса
        *p = 200;               // записать значение 200 в область памяти, на которую указывает указатель


        int *pYears = new int[3]{ 2000, 2010, 2020 };
        sizeof(nums)    // 12 (размер массива в байтах)
        sizeof(pYears)  // 4  (размер указателя на int)


        int nums[]{ 10, 20, 30 };                       // статическое (раннее) связывание
        int *pYears = new int[3]{ 2000, 2010, 2020 };   // динамическое (позднее) связывание; при создании массива через оператор new обязательно указывать кол-во элементов массива в [] скобках

        nums[0] или *nums        // доступ к 0-му элементу обычного массива
        nums[1] или *(nums + 1)  // доступ к 1-му элементу обычного массива

        pYears[0]      // 2000
        *pYears        // 2000
        *(++pYears)    // 2010 (так указатель лучше не изменять, потому что delete [] pYears будет работать некорректно)
        *(pYears + 1)  // 2020 (а вот так нормально)

        pYears = nums;       // так можно заставить указатель указывать на массив
        pYears = &nums[0];   // а можно и так

        // Важно:
        &nums[0] и &nums - один и тот же адрес, но &nums[0] - адрес 0-ого элемента массива, а &nums - адрес всего массива
        int *pNums1 = nums;        // pNums указывает на первый элемент массива nums
        int (*pNums2)[3] = &nums;  // pNums указывает на массив из 3 элементов

        int (*p)[3] = &nums;  // p - указатель на массив из трёх элементов int
        int *p[3]             // p - массив из трёх указателей на int

        // -------------------------------------
        // -------------------------------------
        // -------------------------------------

        Заметки:

        - Списковая инициализация через {} (стиль С++11) имеет следующие особенности
          - Не допускает сужения
          - Пустые скобки инициализируют переменную нулём
        - Чтение из консоли (cin, .get(), .getline(), getline(), .clear()): 
          // с. 142-146, 151-152, 240-249, глава 6
          - cin >> <var> - читает строку до первого пробельного символа или до тех пор, 
            пока ввод подходит под тип переменной. Если <var> - числовая переменная, то
            пробельный символ остаётся в очереди, а если <var> - строка, то пробельный 
            символ отбрасывается. Если <var> - char, то пробелы и символы новой строки 
            из очереди ввода просто выбрасывает и не записывает в <var>. Не следит 
            за количеством введённых символов, поэтому может переполнить переменную <var>.
          - cin.get(<var>[, <length>]) - считывает строку вплоть до символа новой строки, 
            (а не до пробельного символа, как cin >>), но не более <length> - 1 (1 место
            оставляет для символа конца строки). Не считывает из потока ввода конец строки,
            а оставляет его там. Если была считана пустая строка, то ставит флаг failbit
            и запрещает дальнейший ввод. Чтобы разблокировать ввод, нужно использовать 
            метод cin.clear(), который обнуляет этот флаг. В отличие от cin.getline() 
            позволяет проверить, был ли ввод считан полностью (по наличию символа новой 
            строки в очереди ввода). Если метод натыкается на EOF, то cin при приведении
            к типу bool превратится в false.
            EOF из iostream.
          - cin.get() - читает один любой символ (даже символ конца строки) и возвращает
            его. Если метод натыкается на EOF в очереди ввода, то возвращает константу 
            EOF из iostream.
          - cin.getline(<var>, <length>) - считывает строку вплоть до символа новой строки, 
            (а не до пробельного символа, как cin >>), но не более <length> - 1 (1 место
            оставляет для символа конца строки). Сам символ новой строки тоже считывает 
            и отбрасывает. Если ввод не был считан полностью по причине нехватки места
            в переменной, то устанавливает флаг failbit.
          - cin.clear() - сбрасывает флаги failbit и eofbit и позволяет вводить данные 
            снова.
          - getline(cin, <var>) - считывает в строку типа std::string. Аргумент <length>
            отсутствует, потому что std::string-строки автоматически подстраиваются под 
            размер ввода.

          Здесь:
          - <var> - переменная, в которую нужно записать ввод.
          - <length> - максимальная длина считывания

          Примечания:
          - Все разновидности методов cin.get() и cin.getline() появились задолго 
            до введения string-строк, поэтому эти методы не умели работать с такими строкми, 
            чтобы исправить проблему, была введена функция getline(), которая для совместимости 
            используется внутри cin.getline().
          - Методы cin.get() и cin.getline() возвращают объект cin, что позволяет использовать 
            цепной вызов. Можно комбинировать вызовы так: (cin >> i).get()
          - Когда cin обнаруживает EOF, то устанавливает два флага: failbit и eofbit.
            Проверить, установлены ли эти флаги, можно с помощью методов cin.fail() и cin.eof()
            соответственно. 
          - cin преобразуется в bool-значение, когда используется в выражении, ожидающем
            именно этот тип. Принимает значение true, когда последняя попытка чтения была 
            успешной и false - в противном случае. Пример: while (cin) { ... }


        - Массивы и указатели:  
          int nums[]{ 10, 20, 30 };                       // статическое (раннее) связывание
          int *pYears = new int[3]{ 2000, 2010, 2020 };   // динамическое (позднее) связывание; при создании массива через оператор new обязательно указывать кол-во элементов массива в [] скобках

          nums[0] или *nums        // доступ к 0-му элементу обычного массива
          nums[1] или *(nums + 1)  // доступ к 1-му элементу обычного массива

          pYears[0]      // 2000
          *pYears        // 2000
          *(++pYears)    // 2010 (так указатель лучше не изменять, потому что delete [] pYears будет работать некорректно)
          *(pYears + 1)  // 2020 (а вот так нормально)
          
          pYears = nums;       // так можно заставить указатель указывать на массив
          pYears = &nums[0];   // а можно и так

          // Важно:
          &nums[0] и &nums - один и тот же адрес, но &nums[0] - адрес 0-ого элемента массива, а &nums - адрес всего массива
          int *pNums1 = nums;        // pNums указывает на первый элемент массива nums
          int (*pNums2)[3] = &nums;  // pNums указывает на массив из 3 элементов

          int (*p)[3] = &nums;  // p - указатель на массив из трёх элементов int
          int *p[3]             // p - массив из трёх указателей на int

          // Двумерный массив
          int matrix[2][4]{
            {1, 2, 3, 4},
            {5, 6, 7, 8}
          };

          // массив указателей на 2 строки
          const char *cities[2] {
            "Moscow",
            "St. Petersburg"
          };

        - sizeof() работает так:
          - int nums[]{ 10, 20, 30 };
            int *pYears = new int[3]{ 2000, 2010, 2020 };
            sizeof(nums)    // 12 (размер массива в байтах)
            sizeof(pYears)  // 4  (размер указателя на int)

        - Структуры:
          - Варианты синтаксиса:
            // Обычная структура с двумя полями
            struct Tax {
              int amount;
              char currency[3];
            };

            Tax customTax = { 10, "USD" }; // переменная типа Tax
            Tax customTax { 10, "USD" };   // C++11
            Tax customTax {};              // C++11, инициализация каждого поля нулемыми значениями

            cout << customTax.amount << customTax.currency;  // обращение к полям структуры 

            // Можно присваивать одну структура данно типа другой структуре того же типа
            // В этом случае присваиваются отдельные поля.
            Tax smallTax = { 1, "USD" };
            customTax = smallTax;

            // Можно создать переменные во время объявления структуры
            struct Tax {
              int amount;
              char currency[4];
            } customTax, smallTax;

            // ... с инициализацией
            struct Tax {
              int amount;
              char currency[3];
            } customTax { 10, "USD" }, smallTax { 1, "USD" };

            // Структура может быть анонимной в случае одновременного создания переменной
            struct {
              int amount;
              char currency[3];
            } customTax;

            // Массив структур
            Tax taxes[]{
              { 10, "USD" },
              { 610, "RUB" }
            };

            // Можно определить размер члена структуры с помощью битовых полей (только для целочисленных членов int, enum и bool)
            // Это может пондобиться для выравнивания по размеру регистра для увеличения производительности
            struct Tax {
              int amount : 4;        // 4 бита
              bool isRequired : 1;   // 1 бит
              Сurrency сurrency : 4; // 4 бита (Сurrency - enum)
            };

            // Указатели на структуру
            Tax *pCustomTax = new Tax{ 10, "USD" };
            pCustomTax->amount;    // доступ к члену структуры по указателю
            (*pCustomTax).amount;  // доступ к члену структуры по разыменованному указателю

        - Объединения (union):
          - В один момент времени хранит значение только одного поля
          - Работаю те же трюки инициализации и объявления, что и со структурами

          union Offer {
            char id_str[16];
            unsigned int id_num;
          };

          Offer offer2018_58;
          offer2018_58.id_str = "custom_id";  // сечайс хранится в id_str
          offer2018_58.id_num = 50;           // а сечайс хранится в id_num

          // Структура + анонимное объединение
          struct Tax {
            int amount;
            union {
              char currency_str[3];
              Сurrency сurrency_enum;
            }
          } customTax;

          customTax.currency_str = "USD";
          customTax.сurrency_enum = USD;
        - Перечисления (enum):
          - Является альтернативой по отношению к const для создания констант
          - Переменные типа enum автоматически преобразуются в int, но не обратно
          - Размером конкретного enum будет число n-1, где n - наименьшее число, являющееся степенью двойки, которое больше максимального перечислителя

          // Простое перечисление
          enum Color {
            Red,    // значение по умолчанию: 0
            Green,  // значение по умолчанию: 1
            Blue    // значение по умолчанию: 2
          };

          Color pixelColor;
          pixelColor = Red;
          pixelColor = 1;        // нельзя (int -/-> enum)

          int pixelColor = Red;
          pixelColor = 1 + Red;      // можно (enum --> int)
          pixelColor = Green + Red;  // нельзя

          // Явное присваивание значений членам enum
          enum Color {
            Red = 2,
            Green,    // (будет присвоено на 1 больше, чем предыдущему, то есть 3) не обязательно присваивать значение всем компонентам
            Blue = 6
          };
        Указатели и выделение памяти:
          - new (выделяет память в куче) и delete (освобождает память в куче) используются в паре
          - антипаттерн: new в одной функции, а delete - в другой
          - нельзя многократно освобождать одну и ту же память с помощью delete. Результат будет неопределён.
          - указатель на массив фиктически указывает на первый элемент массива
          - нельзя узнать размер массива через sizeof, созданного с помощью new
          - для доступа к элементам динамического массива можно использовать сам указтель со скобками: p[i], где p - указатель на массив, а i - индекс элемента
          - у указателей на массивы есть арифметика:
            - p + 1 - сдвигает начало массива на 1 вправо, а p - 1 на один влево (при таком сдвиге delete[] будет работать не корректно)
            - 

          // Базовое использование
          int *p;              // указатель на переменную типа int
          int *const p;        // указатель-константа на переменную типа int, ему нельзя присвоить другой адрес
          const int *p;        // указатель на константу типа int
          const int *const p;  // указатель-константа на константу типа int

          // Использование с выделением памяти
          int *p = new int;       // выделение памяти в куче посредством оператора new и присваивание адреса указателю p
          int *p = new int{ 5 };  // то же самое, только с иициализацией
          *p = 10;                // присваивание нового значения указателю
          delete p;               // ! освобождает память, выделенную оператором new, а не удаляет указатель. Указатель продолжает указывать на тот же адрес.
          int *p = new int[100];  // выделение памяти для массива из 100 элементов типа int
          delete []p;             // освобождение памяти из-под массива

          int *p;
          p = (int *)0xB8000000;  // присваивание указателю нового адреса
          *p = 200;               // записать значение 200 в область памяти, на которую указывает указатель
        Кастомные типы:
          #define BYTE char   // BYTE - псевдоним char
          typedef char byte;  // byte - псевдоним char
        Циклы:
          for (<type> x : <container>) {}  // C++11; цикл, который перебирает с помощью переменной x все элементы контейнера <container> типа <type>



        // -------------------------------------

        Объявление, инициализация и обращение к переменным:

        Инициализация приминтивных типов:
        int num = 5;      // стек, стиль С
        int num(5);       // стек, стиль C++
        int num = { 5 };  // стек, стиль С++11  | если оставить скобки пустыми, то переменная инициализируется 0
        int num{ 5 };     // стек, стиль С++11  |

        Инициализация массивов:
        int months[12];                 // в стеке, только выделение памяти
        int months[12] = { 1, 2, 3 };   // в стеке, выделение памяти для 12 элементов, заполнение только 3х элементов
        int months[] = { 1, 2, 3 };     // в стеке, 
        int months[] { 1, 2, 3 };       // в стеке, стиль С++11

        Инициализация строк:
        char char_str[] = { "Stringo" };
        char char_str[]{ "Stringo" };
        string string_str = { "Stringo" };
        string string_str{ "Stringo" };

        // -------------------------------------

        >>> ПРЕОБРАЗОВАНИЯ ТИПОВ 120
        >>> СТРОКИ 136 / СТЕНИЕ ВВОДА СТРОК 141
        >>> Vector & Array 196
        >>> ЧТЕНИЕ ФАЙЛА 287-297 

        // -------------------------------------

        #include <iostream>

        // Константа, хранимая в статической области памяти
        const int GLOB_CONST = 5;

        int main () {
            // Переменная, хранимая в автоматической области памяти (в стеке)
            int num = 5;
            
            // Указатели
            const int *pGC = &GLOB_CONST;  // указывает на константу в статической области памяти
            int *pNum = &num;              // указывает на переменную в автоматической области памяти (в стеке)
            int *pLevel = new int{ 10 };   // указывает на переменную в динамической области памяти (в куче) 

            std::cout << *pGC << " " << *pNum << " " << *pLevel << std::endl;

            // delete pGC;    // нельзя применять delete для указателей, которые указывают на объекты в статической области памяти 
            // delete pNum;   // нельзя применять delete для указателей, которые указывают на объекты в автоматической области памяти (в стеке)
            delete pLevel;    // необходимо применять delete для указателей, которые указывают на объекты в динамической области памяти (в куче) 

            return 0;
        }

        // -------------------------------------
        // -------------------------------------
        // -------------------------------------



        Функция sizeof() возвращает:
        - sizeof(<type>) - размер типа <type> в байтах
        - sizeof("string") - длина строки в символах (размер всегда больше видимого количества символов на один, т.к. учитывается нулевой символ \0)

        sizeof(char): 1
        sizeof(short): 2
        sizeof(short int): 2
        sizeof(int): 4
        sizeof(long int): 4
        sizeof(long): 4
        sizeof(long long): 8

        СТР. 9: о размераз типов и переменных, sizeof, climits

        Варианты инициализации переменной:
        - int var = 5;
        - int var = { 5 };
        - int var{ 5 };
        Фигурные скобки можно оставить пустыми, тогда переменная будет инициализирована 0.

        Компьютер наиболее эффективно работает с типом int.

        Системы счисления, в которых C++ позволяет записывать целочисленные литералы:
        - oct: 042 (если чсло начинается с 0 и не имеет цифр больше 7)
        - hex: 0x162f
        - dec: 10
        В std есть соответствующие манипуляторы oct, hex и dec, которые позволяют выводить числа в нужной СС.

        При объявлении целочисленных литералов можно указать суффиксы:
        - l/L - long
        - u/U - unsigned int
        - ul/lu/UL/LU - unsigned long
        - ll/LL - long long
        - ull/ULL - unsigned long long

        При объявлении целочисленных литералов язык подбирает тип, которого достаточно для хранения литерала:
        - dec: int, long, long long
        - hex: int, long, unsigned long, long long, unsigned long long (unsigned - потому что hex-числа часто используются для адресов памяти, которые не могут быть отрицательными)

        -------------------------------

        Указатель хранит адрес значения.

        * – "косвенное значение" или "операция разыменовывания".

        -------------------------------
        Модификаторы доступа:
        - public
        - private
        - protected

        Ключевые слова:
        - auto - имеет новое значение с C++11: автоматически выводит тип переменной
        - friend - ключевое слово для функций, которое даёт функции те же права доступа к членам класса, что и функции-члены этого класса
        - explicit - ключевое слово для функций, запрещающее неявное преобразование типов аргументов

        CV-квалификаторы (C - const, V - volatile): 
        - const - делает переменную константой.
        - volatile - по-умолчанию значение переменных кэшируется в регистре ЦП между двумя использованиями для оптимизации (чтобы не обращаться к памяти каждый раз). Но если мы знаем, что значение в ячейке пямяти может измениться независимо от нашей программы, можно отменить кэширование этим квалификатором.

        Спецификаторы:
        - constexpr - помогает рассчитать значение выражения на этапе компиляции.

        Спецификаторы класса хранения:
        - auto (был спецификатором, сейчас исключён) - в ранних версиях C/C++ насильно делал переменную автоматический. В новых версиях С++ исключён из спецификаторов и имеет другое назначение.
        - register - в ранних версиях C/C++ заставлял хранить переменную в регистре ЦП для скорости. Сейчас он эквивалентен auto.
        - static - делает переменную статической (внутри блоков) или назначает внутреннее связываение глобальным переменным (объявленным вне блоков).
        - extern - указывает на ссылочное объявление. Для переменных, которые видны во всех файлах программы.
        - thread_local - переменная существует только на протяжении существования потока.
        - mutable - разрешает изменять отдельные члены структурной контстантной переменной, каторая имеет тип "const <имя_структуры>"
        В одном объявлении можно использовать только один спецификатор.
        Исключение: thread_local можно использовать вместе со static или extern.

        Знаковость:
        - unsigned - беззнаковая переменная
        - signed - знаковая переменная
        -------------------------------


        Пример:
        pointer – указатель и хранит адрес значения.
        Тогда *pointer – значение по адресу pointer.


        Пример 2:
        variable — простая переменная.
        pointer – указатель на адрес значения переменной variable.
        Тогда:
        – pointer == &variable == адрес значения в памяти;
        – *pointer = variable == значение в памяти по адресу pointer.


        Объявление указателя:
        <type> *<pointer_name>;
        Здесь:
        – <type> – тип значения, хранимого по адресу памяти;
        – <pointer_name> указывает на тип <type>;
        – *<pointer_name> является значением типа <type>;
        – <type> * – тип "указатель на int".


        Схема того, как работает указатель на простую переменную:

               duck              |-------------|  *birddog
            |------->  0xfbaf90  |          12 | <----------|
            |                    |-------------|            |
            |          0xfbaf91  |             |            |
            |                    |-------------|            |
            |          0xfbaf92  |             |            |
            |                    |-------------|   birddog  |
            |          0xfbaf93  |    0xfbaf90 | <----------|
            |                    |-------------|            |
            |          0xfbaf94  |             |            |
            |                    |-------------|            |
            |                                               |
        int duck = 12;                          int *birddog = &duck;


        Адрес, хранимый в указателе, обычно, имеет размер 2-4 байта.

        -----------------------------------------------------
        | Перед тем, как использовать указатель, необходимо |
        | сохранить в указателе адрес памяти!               |
        -----------------------------------------------------

        --------------------------------------------------------
        | <type> * — совершенно самостоятельный тип данных.    |
        | Поэтому, не смотря на то, что визуально адрес памяти |
        | напоминает целое число, указателю нельзя присваивать |
        | целые числа. Сначала необходимо явно преобразовать в |
        | целочисленный тип в тип "указатель на <type>" сле-   |
        | дующим образом: <type> *p = (<type> *) 0x50fa19df    |
        --------------------------------------------------------


        Пример указателя на целочисленный массив:
        int *p = new int[3] { 5, 10, 15 };
        Получить n-ный элемент массива можно 2 способами:
        – p[n]
        – *(p + n)


        ----------------------------------------------------------
        | Имя массива - адрес первого элемента этого массива.    |
        | Поэтому, если создать переменную-массив, то адрес этой |
        | переменной  можно получить без применения операции &.  |
        | int ary = new int[3] {1, 2, 3};                        |
        | int *ap = ary; (БЕЗ &) (или &ary[0])                   |
        ----------------------------------------------------------

        ВАЖНО!
        char-строка, как и массив числового типа, возвращает аресс первой буквы

        Объявление указателей на разные типы:
        int *pa = new int{3};
        short *pb = new sort[3] {5, 16, 80};
        char 9pc = new 

        Как работает:
        int *pa = new int[40];             // так пишем
        int *pa = new(40 * sizeof(int));   // так работает

        ------------------------

        cin >> char       - не принимает пробельные символы. Возвращает cin.
        char = cin.get()  - возвращает введённый символ или константу EOF, если конец файла/ввода (cin.get без аругментов может возвращать беззнаковый char и не получится провериь на конец строки (EOF), поэтому принимать нужно в int)
        cin.get(char)     - принимает все символы. Возвращает cin. Преобразуется в true/false при использовании в логич. выражениях
        В языке С:
        cin.get() == getchar(), но getchar сохраняет код символа в int, а cin.get в char;
        cout.put(char) == putchar(int)
        getchar и putchar находятся в cstdio (stdio.h)


        Vector & array
        Функции
        Встроенные функции
        Прототипы функций
        Шаблоны функций
        ---------------------------------------
        Прототип нешаблонной функции:
        void swap (job &a, job &b);
        ---------------------------------------
        Прототип шаблона с произвольным типом:
        template <typename T>
        void swap (T &a, T &b);
        ---------------------------------------
        Шаблон функции с произвольным типом:
        template <typename T>
        void swap (T &a, T &b)
        {
            
        }
        ---------------------------------------
        Явная специализация для типа job:
        template <> void swap<job>(job &, job &);
        или
        template <> void swap(job &, job &);
        * <job> можно опустить, т. к. специализация функции определяется по типу принимаемых значений
        ---------------------------------------
        Явное создание экземпляра (в данном случае для типа <int>):
        template void swap<int>(int, int);
        ---------------------------------------
        !!! Не путать явную СПЕЦИАЛИЗАЦИЮ и явное создание ЭКЗЕМПЛЯРА !!!
        ---------------------------------------
        Указание типа при вызове шаблонной функции:
        template <typename T>
        void swap (T &a, T &b)
        {
            
        }

        double x = 5, y = 10;
        swap<double>(x, y);   // <===========
        ---------------------------------------


        ----------------------------
        decltype(x) y;    // создаёт переменную "y" с тем же типом, что и "x"
        auto swap (T1 x, T2 y) -> decltype(x);    // определение типа, возвращаемого функцией через decltype
        ----------------------------
        typedef
        ----------------------------
        inline
        ----------------------------

        ----------------------------
        В заголовочные файлы стоит включать следующее:
        - Прототипы функций
        - Символические константы, определённые через define или const
        - Объявления структур
        - Объявления классов
        - Объявления шаблонов
        ----------------------------
        4 хранилища дынных в памяти:
        - Автоматическое (для переменных, созданных внутри функции)
        - Статическое (для переменных, созданных за пределами функций или с модификатором static)
        - Потоковое (переменные, созданные с модификатором thred_local, существуют только на протящении существования потока)
        - Динамическое (здесь хранятся переменные, создаваемые через new)
        ----------------------------
        Доступ к глобальной переменной:
        int myvar = 5;
        void funct () {
            int myvar = 10;

            myvar;    // доступ к локальной перемнной
            ::myvar;  // доступ к глобальной переменной
        }
        ----------------------------
        // file1.cpp
        int myvar = 5;

        // file2.cpp
        static int myvar = 10;
        // Далее везде используется myvar из этого файла (ile2.cpp)

        Здесь myvar из file1.cpp не конфликтует с одноимённой переменной в file2.cpp,
        так как в file2.cpp используется статическая переменная myvar;
        -----------------------------
        Желательно вместо статических глобальных переменных использовать переменные в namespace
        -----------------------------

        -----------------------------
        using Namespace::varname   - объявление using
        using namespace Namespace  - директива using
        -----------------------------

        -----------------------------
        ОШИБКА, т. к. Small, Medium, Large находсятся в одной глобальной области видимости:
        enum egg {Small, Medium, Large}
        enum tshirt {Small, Medium, Large}

        Ключевое слово class устанавливает индивидуальную область видимости для перечисления:
        enum class egg {Small, Medium, Large}
        enum class tshirt {Small, Medium, Large}

        <int_type> - целочисленный тип для числового представления элементов перечисления:
        enum class : <int_type> egg {Small, Medium, Large}
        enum class : <int_type> tshirt {Small, Medium, Large}
        -----------------------------

        -----------------------------
        Создание класса:

        class ClassName {

        private:                                             // Если не указывать этот модификатор для секции, то все свойства и методы в этой секции по умолчанию private
            int private_var;
            void private_func_proto();
            static const int const_var = 5;                  // Создать константу внутри класса можно только с помощью ключевого слова static, но при этом она будет общей для всех объектов, созданных из этого класса
        public:                                              // Публичные свойства и методы
            ClassName();                                     // Конструктор по умолчанию
            ClassName(const ClassName &);                    // Конструктор копирования
            ClassName(int a);                                // Конструктор #3. Конструктор с одним аргументом (или с несколькими, где все кроме первого имеют значения по умолчанию) преобразует присваеваемое значение в тип класса
            ClassName(int a, int b);                         // Конструктор #4
            ~ClassName();                                    // Деструктор

            int public_var;
            void public_func_proto();

            ClassName operator+(const ClassName &t) const;          // Перегрузка операции сложения (+) через функцию-член
            friend ClassName operator+(const ClassName &t) const;   // Перегрузка операции сложения (+) через функцию-друга

            operator double() {                                     // Функция для преобразования объекта в другой тип (в данном случае в double)
                return double(private_var);
            }

            explicit operator int() const;                          // Прототип функции ЯВНОГО преобразования из ClassName в int
        }

        ClassName::operator int() const {                           // Функция ЯВНОГО преобразования из ClassName в int
            // ...
        }

        // Функция-друг для класса ClassName, которая перегружает операцию сложения переменных этого класса
        // Имеет те же права, что и функция-член класса
        // Её прототип указывается внутри целевого класса, а не отдельно
        ClassName operator+(const ClassName &t, const ClassName &t2) const {
            
        }
        -----------------------------
        [inline] <type> <class_name>::<method_name>([<args>]) [const] {};
        const обозначает, что метод обязуется не изменять аргументы <args>.
        -----------------------------
        По умолчанию все функции, объявленные внутри класса - встроенные.
        Если нужно сделать метод класса, объявленный вне класса встроенным, еспользовать inline.
        -----------------------------
        Статические переменные в классе создаются по следующим правилам:
        - Объявление переменной должно иметь кл. слово static и должно находиться в объявлении класса в заголовочном файле (.h), но не должно быть инициализировано значением.
        - Присвоение значения статической перемнной класса должно иметь тип, но не иметь кл. слова static.

        // example.h
        class ExampleClass {
        private:
            static int example_num;          // Не имеет значения, но имеет static
        }

        // example.cpp
        int ExampleClass::example_num = 10;  // Не имеет static, но имеет тип
        -----------------------------
        Создание объекта из класса:
        <class_name> <var_name> = <class_name>(<args>);        // основная форма
        <class_name> <var_name>(<args>);                       // сокращённая форма
        <class_name> *<var_name> = new <class_name>(<args>);   // через укаазтель

        Создание объекта из класса в С++11 с аргументами:
        <class_name> <var_name> = {<args>};                    // 1я форма
        <class_name> <var_name>{<args>};                       // 2я форма
        <class_name> *<var_name> = new <class_name>{<args>};   // через укаазтель
        -----------------------------


        ----------------------------------------------------------------------------------------
        Статические переменные:
        - Статическими переменными считаются переменные, которые объявлены в глобальной области видимости или с ключевым словом static.
        - Хранятся в стеке, существуют на протяжении всего выполнения программы.
        - Если при объявлении статическая переменная не получает значения, то она инициализируется нулевым значением (все биты устанавливаются в 0).
        - Стат. перем. с внешним связыванием создаётся с помощью объявления в глобальнй области видимости.
        - Стат. перем. с внутренним связываение создаётся с помощью объявления с ключевым словом static.
        - Стат. перем. без связывания создаётся с ключевым словом static внутри любого блока, заключённого в {}.
        - Если у переменной со внешним связываем используется модификатор const, то эта меерменная становится константной переменной СО ВНУТРЕННИМ связываением.
        - Ключевое слово static вне блоков управляет связыванием, но внутри блоков оно управляет временем хранения. 

        int global;              // Переменная, статическая, внешнее связывание
        static int one_file;     // Переменная, статическая, внутреннее связывание
        const int с_one_file;    // Константа, статическая, внутреннее связывание

        void func () {
            static int count;    // Переменная, статическая, нет связывания
        }
        ----------------------------------------------------------------------------------------
        Ключевое слово extern и ссылочная инициализация:
        - Ключевое слово extern указывает на то, что переменная является общей для нескольких файлов.
        - Переменная с ключевым словом extern может быть инициализирована значением ТОЛЬКО В 1 файле, а в остальных её можно только объявить.

        int maindecl = 5;    // file1.cpp Главное объвление переменной в одном файле...
        extern int maindecl; // file2.cpp ...ссылочное объявление переменной в другом файле с помощью extern
        ----------------------------------------------------------------------------------------
        Связываение:
        - Внешнее:
        - - Переменные, доступные для нескольких/всех единиц трансляции.
        - Внутреннее:
        - - Переменные, доступные внутри только одной единицы трансляции.
        - Без связывания:
        - - Переменные, доступные только внутри блока кода, заключённого в {}.

        Конструкторы и деструкторы:
        - Конструктор по умолчанию создаётся автоматически, если не определён ни один другой конструктор.
        - Конструктор считается по умолчанию, если все его аргументы имеют значение по умолчанию.
        - Контструктор по умолчанию:
        - - Создаётся автоматически при отсутствии.
        - - Конструктором по умолчанию считается конструктор, который не принимает аргументов или у которого все аргументы имеют значения по умолчанию.
        - Конструктор копирования:
        - - Создаётся автоматически при отсутствии.
        - - Служит для копирования объекта в создаваемый объект.
        - - Применяется так же при передаче аргумента по значению и тогда, когда функция возвращает объект.
        - - По умолчанию почленно копирует значения одного объекта в значения другого по значению.
        - - Имеет прототип: <class_name> (const <class_name> &);
        - - Случаи, когда вызывается конструктор копирования:
            <class_name> first_obj;
            1. <class_name> second_obj(first_obj);
            2. <class_name> second_obj = first_obj;
            3. <class_name> second_obj = <class_name>(first_obj);
            4. <class_name> *p_second_obj = new <class_name>(first_obj);




        -----------------------------------------------

        В C++ переменную лучше объявлять непосредственно перед использованием.

        Присваивание возвращает присваеваемое значение.
        int a, b, c;
        a = b = c = 5;  // a, b и c равны 5

        Директиву using можно использовать не только в глобальном пространстве имён, но и в любом бллоке кода.

        В именах не стоит использовать __ в начале или _ с первой буквой в верхнем регистре, т. к. такое именование зарезервировано за системными переменными (__var, _Var)

        Целочисленные типы: char, short, int, long, long long

        --------------------

        // макросы
        // числовые типы, строки, перечисления, объединения, структуры, классы
        // указатели
        // функции, лямбда-функции
        // приведение типов, ***_cast
        // потоки и файлы
        // volatile, const
        // inline, override
        // friend
        // auto, typedef, decltype
        // size_t 
    </pre>
    <hr><hr>
    <h1 id="section-headers">Заголовочные файлы</h1>
    <p>Заголовочные файлы подключаются следующим образом:</p>
    <pre>
        <code class="lang-cpp">
            #include &lt;iostream&gt;   // Новый стиль C++
            #include &lt;iostream.h&gt; // Старый стиль C++
            #include &lt;cmath&gt;      // Новый стиль C
            #include &lt;math.h&gt;     // Старый стиль C
        </code>
    </pre>
    <p>Именование заголовоных файлов:</p>
    <div class="table border border-grey headers-nowrap">
        <table>
            <thead>
                <tr>
                    <th>Тип заголовка</th>
                    <th>Соглашение</th>
                    <th>Пример</th>
                    <th>Комментарий</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="nowrap">Старый стиль C++</td>
                    <td class="nowrap">Расширение <code>.h</code></td>
                    <td><code>iostream.h</code></td>
                    <td>Используется в программах на C++</td>
                </tr>
                <tr>
                    <td class="nowrap">Старый стиль C</td>
                    <td class="nowrap">Расширение <code>.h</code></td>
                    <td><code>math.h</code></td>
                    <td>Используется в программах на C и C++</td>
                </tr>
                <tr>
                    <td class="nowrap">Новый стиль C++</td>
                    <td class="nowrap">Без расширения</td>
                    <td><code>iostream</code></td>
                    <td>Используется в программах на C++, используется пространство имён <code>std</code></td>
                </tr>
                <tr>
                    <td class="nowrap">Новый стиль C</td>
                    <td class="nowrap">Префикс <code>c</code>, без расширения</td>
                    <td><code>cmath</code></td>
                    <td>Используется в программах на C++, может использовать свойства, не характерные для C, такие как пространство имён <code>std</code></td>
                </tr>
            </tbody>
        </table>
    </div>
    <h1 id="section-namespaces">Пространства имён</h1>
    <p>В C++ существуют пространства имён (namespaces). Есть несколько способов работы с ними:</p>
    <ul>
        <li>
            Использовать банарный оператор <code>::</code> :
            <pre>
                <code class="lang-cpp">
                    std::cout << "Hello!"; // использовано имя cout из пространства имён std
                </code>
            </pre>
        </li>
        <li>
            Использовать <em>директиву</em> <code>using</code> для извлечения <em>всех</em> имён из пространства имён:
            <pre>
                <code class="lang-cpp">
                    #include &lt;iostream&gt;
                    using namespace std; // директива using

                    int main () {
                        cout &lt;&lt; "Hello!"; // использовано имя cout из пространства имён std напрямую
                        // ...
                    }
                </code>
            </pre>
        </li>
        <li>
            Использовать <em>объявление</em> <code>using</code> для извлечения <em>некоторых</em> имён из пространства имён:
            <pre>
                <code class="lang-cpp">
                    #include &lt;iostream&gt;
                    using std::cout; // объявление using

                    int main () {
                        cout &lt;&lt; "Hello!"; // использовано имя cout из пространства имён std напрямую
                        // ...
                    }
                </code>
            </pre>
        </li>
    </ul>
    <p>И директиву <code>using</code> и объявление <code>using</code> можно использовать в любом блоке кода или вне блоков вообще:</p>
    <pre>
        <code class="lang-cpp">
            #include &lt;iostream&gt;
            using namespace FakeNamespace; // директива using использована вне блоков кода

            int main () {
                using std::cout; // объявление using использована в блоке функции main
                {
                    using namespace MyNamespace; // директива using использована во вложенном блоке кода
                    cout &lt;&lt; "Hello!"; 
                } 
                return 0;
            }
        </code>
    </pre>
    <h1 id="section-cin-cout">Всё о cin и cout</h1>             
    <p><code>cin</code> (поток ввода) и <code>cout</code> (поток вывода) – это объекты, экземпляры классов <code>istream</code> и <code>ostream</code> соответсвенно.</p>
    <p>Объекты <code>cin</code> и <code>cout</code> не подходят для работы с типом <code>wchar_t</code>, необходимо использовать альтернативные объекты <code>wcin</code> и <code>wcout</code> из <code>iostream</code>.</p>
    <h4>Использование cout</h4>
    <div class="table border border-grey headers-nowrap">
        <table>
            <thead>
                <tr>
                    <th>Способ вывода</th>
                    <th>Описание способа</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="nowrap"><code>std::cout &lt;&lt; my_var;</code></td>
                    <td class="nowrap">Выводит данные разных типов</td>
                </tr>
                <tr>
                    <td class="nowrap"><code>std::cout.put('c');</code></td>
                    <td class="nowrap">Выводит единственный символ типа <code>char</code></td>
                </tr>
            </tbody>
        </table>
    </div>
    <h4>Манипуляторы</h4>
    <ul>
        <li>
            <code>endl</code> – манипулятор окончания строки; моментально выводит данные на экран (сброс буфера), в отличие от <code>\n</code>.
            <pre>
                <code class="lang-cpp">
                    std::cout &lt;&lt; "Hello!" &lt;&lt; endl; 
                </code>
            </pre>
        </li>
        <li>
            <code>dec</code> – выводить целочисленные типы в десятичном формате.
            <pre>
                <code class="lang-cpp">
                    std::cout &lt;&lt; std::dec &lt;&lt; 325 &lt;&lt; endl; // выведет: 325
                </code>
            </pre>
        </li>
        <li>
            <code>hex</code> – выводить целочисленные типы в шестнадцатеричном формате.
            <pre>
                <code class="lang-cpp">
                    std::cout &lt;&lt; std::hex &lt;&lt; 0xF6A9 &lt;&lt; endl; // выведет: 0xF6A9
                </code>
            </pre>
        </li>
        <li>
            <code>oct</code> – выводить целочисленные типы в восьмеричном формате.
            <pre>
                <code class="lang-cpp">
                    std::cout &lt;&lt; std::oct &lt;&lt; 0744 &lt;&lt; endl; // выведет: 0744
                </code>
            </pre>
        </li>
    </ul>
    <h4>Другие способы форматирования в cout</h4>
    <p><code>std::cout.setf()</code> устанавливает формат вывода данных. Например, <code>std::cout.setf(ios_base::fixed)</code> запретит использование экспоненциального формата для чисел с плавающей точкой при выводе данных.</p>
    <h1 id="section-dictionary">Словарь</h1>
    <p>
        <strong>Лексема</strong>&nbsp;&#0151;&nbsp;неделимый элемент в строке кода.<br>
        <strong>Пробельные символы</strong>&nbsp;&#0151;&nbsp;символы, используемые для разделения лексем: <code>&lt;пробел&gt;</code>, табуляция (<code>\t</code>), возврат каретки (<code>\r</code>).<br>
        <strong>Квалификатор</strong>&nbsp;&#0151;&nbsp;выражение, уточнающее объявление.
    </p>
    <!-- Variables -->
    <h1 id="section-variables">Переменные</h1>
    <div class="message green">Переменные лучше всего объявлять как можно ближе к месту использования.</div>
    <pre>
        <code class="lang-cpp">
            int num;        // оператор объявления (Объявление/определение переменной)
            num = 5;        // оператор присваивания
            int score = 60; // инициализация (объявление + присваивание)
        </code>
    </pre>
    <p>Замечания по именованию переменных:</p>
    <ul>
        <li>Не начинать имя переменной с одного или двух символов подчёркивания</li>
        <li>Не давать переменным имена длиннее 63 символов, т. к. некоторые компиляторы могут не поддерживать >63 символов</li>
    </ul>
    <p>Способы инициализации переменных:</p>
    <div class="table border border-grey headers-nowrap">
        <table>
            <thead>
                <tr>
                    <th>Как выглядит</th>
                    <th>Примечание</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="nowrap"><code>int num = 5;</code></td>
                    <td class="nowrap">Стиль языка C</td>
                </tr>
                <tr>
                    <td class="nowrap"><code>int num(5);</code></td>
                    <td class="nowrap">Стиль языка C++</td>
                </tr>
                <tr>
                    <td class="nowrap"><code>int num = { 5 };</code></td>
                    <td class="nowrap">Стиль языка C++11. Если оставить скобки пустыми, то переменная инициализируется <code>0</code>.</td>
                </tr>
                <tr>
                    <td class="nowrap"><code>int num{ 5 };</code></td>
                    <td class="nowrap">Стиль языка C++11. Если оставить скобки пустыми, то переменная инициализируется <code>0</code>.</td>
                </tr>
            </tbody>
        </table>
    </div>
    <h4>Переменные с точки зрения памяти</h4>
    <p>При работе с переменной, компьютер отслеживает три её фундаментальных свойства:</p>
    <ul>
        <li>Где хранится информация</li>
        <li>Какое значение сохранено</li>
        <li>Разновидность (тип) сохранённой информации</li>
    </ul>
    <!-- /Variables -->
    <!-- Functions -->
    <h1 id="section-functions">Функции</h1>
    <p>В каждой программе должна быть функция <code>main</code>, которая является точкой входа в программу и запускается операционной системой. Исключения могут оставлять библиотеки.</p>
    <p>В программе могут быть несколько функций с одним и тем же именем, но с разным набором аргументов.</p>
    <p>Если функция не принимает аргументов, то можно на месте их поставить <code>void</code>.</p>
    <!-- /Functions -->
    <!-- Types -->
    <h1 id="section-types">Типы</h1>
    <p>
        <strong>Ширина</strong>&nbsp;&#0151;&nbsp;объём памяти, необходимый для хранения переменной конткретного типа.<br>
        <strong>Байт в памяти компьютера</strong> означает 8-битный объём памяти.<br>
        <strong>Байт C++</strong> состоит из минимального количества смежных битов, достаточного для того, чтобы вместить базовый набор символов для реализации (обычно равен 8 бит). <span class="more">см. &laquo;Прата – ЯП C++&raquo;, врезка на стр. 89</span>
    </p>

    <h4>Операция sizeof</h4>
    <p>
        Операция <code>sizeof</code> возвращает размер типа или переменной в байтах C++.<br>
        Если <code>sizeof</code> применяется к имени типа, то скобки необходимы (<code>sizeof(int)</code>), а если к имени переменной, то скобки не обязательны (<code>sizeof my_var</code>). 
    </p>

    <h4>Числа с плавающей точкой</h4>
    <p>В любом числе с плавающей точкой часть слева называется значением, а слева – масштабным коэффициентом.</p>
    <p><code>3.45e6</code> – это экспоненциальная запись числа <code>3 450 000</code>. Здесь <code>3.45</code> – это мантисса, а <code>6</code> – это порядок.</p>
    <p>Значащие цифры – это цифры в любом числе, идущие перед смежными нулями справа. Например, в числе <code>14 179</code> значащими являются все цифры, а в числе <code>14 000</code> значащими являются цифры <code>14</code>, а <code>000</code> – просто заполнители. Количество значащих цифр не зависит от позиции десятичной точки, например, в числе <code>14.179</code> значащими являются все цифры.</p>
    <p>Заголовочный файл <code>cfloat</code> (<code>float.h</code>) содержит информацию о параметрах типов с плавающей точкой. <span class="more">см. &laquo;Прата – ЯП C++&raquo;, листинг на стр. 113</span></p>
    <p>По умолчанию программа хранит константы с плавающей точкой в типе <code>double</code>. Если необходимо заставить программу хранить такое число во других типах, то необходимо добавить соответствующий суффикс из таблицы ниже.</p>
    <p>Операции над числами с плавающей точкой выполняются медленее операций с целочисленными типами.</p>
    <p>Таблица вещественных чисел:</p>
    <div class="table border border-grey headers-nowrap">
        <table class="black-border">
            <thead>
                <tr>
                    <th>Тип</th>
                    <th>Ширина <sup>1</sup></th>
                    <th>Мин. знач. порядка</th>
                    <th>Макс. знач. порядка</th>
                    <th>Суффикс</th>
                    <th><em>Прим.</em></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>float</code></td>
                    <td>&gt;= 32 бит</td>
                    <td class="text-right">-37</td>
                    <td class="text-right">38</td>
                    <td><code>f</code>/<code>F</code></td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>double</code></td>
                    <td>&gt;= 48 бит<br>&gt;= float <sup>2</sup></td>
                    <td class="text-right">-307</td>
                    <td class="text-right">308</td>
                    <td>&#0151;</td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>long double</code></td>
                    <td>&gt;= double <sup>3</sup></td>
                    <td class="text-right">-4 931</td>
                    <td class="text-right">4 932</td>
                    <td><code>l</code>/<code>L</code></td>
                    <td>&#0151;</td>
                </tr>
            </tbody>
        </table>
    </div>
    <p>
        <sup>1</sup> Здесь ширина означает объём памяти, выделяемый типом для хранения значащей части.<br>
        <sup>2</sup> <code>double</code> обычно имеет размер 64 бита.<br>
        <sup>3</sup> <code>long double</code> чаще всего имеет размер 80, 96 или 128 битов.
    </p>
    <p class="todo">Добавить столбец "значащая часть"</p>

    <h4>Целочисленные типы</h4>
    <p>Заголовочный файл <code>climits</code> (<code>limits.h</code>) содержит диапазоны целочисленных типов, например <code>CHAR_BIT</code> – количество битов в байте C++. <span class="more">см. &laquo;Прата – ЯП C++&raquo;, таблица на стр. 92</span></p>
    <p>Компьютер наиболее эффективно обрабатывает тип <code>int</code>, поэтому если нет веской причины выбирать другой тип, то лучше использовать именно его.</p>
    <p>Программа хранит целочисленные литералы в виде типа <code>int</code>, за исключением двух случаев:</p>
    <ol>
        <li>Используется специальный суффикс (<span class="more">см. таблицу целочисленных типов ниже</span>)</li>
        <li>Типа <code>int</code> не достаточно для хранения представленного значения. Тогда для десятичного литерала используется наименьшим из следующих типов, способных его вместить: <code>int</code>, <code>long</code> или <code>long long</code>, а для шестнадцатеричного и восьмеричного литералов – <code>int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code> или <code>unsigned long long</code>.</li>
    </ol>
    <p>Три способа записи целочисленных литералов (<span class="more">о формат. целочисл. литералов в <code>cout</code> см. раздел &laquo;Всё о cin и cout&raquo; &laquo;Манипуляторы&raquo;</span>):</p>
    <ul>
        <li>С основанием 10. Пример: <code>325</code></li>
        <li>С основанием 8. Пример: <code>0744</code></li>
        <li>С основанием 16. Пример: <code>0xF63E</code></li>
    </ul>
    <p>Таблица целочисленных типов:</p>
    <div class="table border border-grey headers-nowrap">
        <table class="black-border">
            <thead>
                <tr>
                    <th>Тип</th>
                    <th>Что хранит</th>
                    <th>Ширина</th>
                    <th>Мин. значение</th>
                    <th>Макс. значение</th>
                    <th>Суффикс</th>
                    <th><em>Прим.</em></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>char</code> <sup>7</sup></td>
                    <td>Целое число</td>
                    <td>&gt;= 8 бит</td>
                    <td class="text-right">-128</td>
                    <td class="text-right">127</td>
                    <td>&#0151;</td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>wchar_t</code> <sup>1</sup></td>
                    <td>Целое число</td>
                    <td>&gt;= 8 бита <sup>2</sup></td>
                    <td class="text-right">&#0151; <sup>2</sup></td>
                    <td class="text-right">&#0151; <sup>2</sup></td>
                    <td>Преф. <code>L</code></td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>char16_t</code> <sup>3</sup></td>
                    <td>Целое число</td>
                    <td>16 бит</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td>Преф. <code>u</code></td>
                    <td>C++11</td>
                </tr>
                <tr>
                    <td><code>char32_t</code> <sup>3</sup></td>
                    <td>Целое число</td>
                    <td>32 бита</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td>Преф. <code>U</code></td>
                    <td>C++11</td>
                </tr>
                <tr>
                    <td><code>short</code></td>
                    <td>Целое число</td>
                    <td>&gt;= 16 бит</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td>&#0151;</td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>int</code> <sup>5 6</sup></td>
                    <td>Целое число</td>
                    <td>&gt;= short</td>
                    <td class="text-right">-2&nbsp;147&nbsp;483&nbsp;648</td>
                    <td class="text-right">2&nbsp;147&nbsp;483&nbsp;647</td>
                    <td>&#0151;</td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>long</code></td>
                    <td>Целое число</td>
                    <td>&gt;= <code>int</code><br>&gt;= 32 бит</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td><code>l</code>/<code>L</code></td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>long long</code></td>
                    <td>Целое число</td>
                    <td>&gt;= <code>long</code><br>&gt;= 64 бит</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td><code>ll</code>/<code>LL</code></td>
                    <td>C++11</td>
                </tr>
                <tr>
                    <td><code>unsigned char</code></td>
                    <td>Целое число</td>
                    <td>&gt;= 8 бит</td>
                    <td class="text-right">0</td>
                    <td class="text-right">255</td>
                    <td>&#0151;</td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>unsigned short</code></td>
                    <td>Целое число</td>
                    <td>&gt;= 16 бит</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td>&#0151;</td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>unsigned int</code> <sup>4 5</sup></td>
                    <td>Целое число</td>
                    <td>&gt;= short</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td><code>u</code>/<code>U</code></td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>unsigned long</code></td>
                    <td>Целое число</td>
                    <td>&gt;= <code>int</code><br>&gt;= 32 бит</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td><code>ul</code>/<code>UL</code></td>
                    <td>&#0151;</td>
                </tr>
                <tr>
                    <td><code>unsigned long long</code></td>
                    <td>Целое число</td>
                    <td>&gt;= <code>long</code><br>&gt;= 64 бит</td>
                    <td class="text-right"></td>
                    <td class="text-right"></td>
                    <td><code>ull</code>/<code>ULL</code></td>
                    <td>C++11</td>
                </tr>
            </tbody>
        </table>
    </div>
    <p>
        <sup>1</sup> Wide character type.<br>
        <sup>2</sup> Зависит от компилятора.<br>
        <sup>3</sup> Являются беззнаковыми типами.<br>
        <sup>4</sup> <code>unsigned</code> без указания типа аналогично <code>unsigned int</code>.<br>
        <sup>5</sup> типы <code>int</code> и <code>unsigned int</code> могут иметь ширину 16, 24 или 32 бита. В большинстве современных систем они имеют ширину 32 бита.<br>
        <sup>6</sup> <code>short int</code> то же самое, что <code>short</code>; <code>long int</code> то же самое, что <code>long</code>; <code>long long int</code> то же самое, что <code>long long</code>.<br>
        <sup>7</sup> тип <code>char</code> не является ни знаковым, ни беззнаковым, поэтому, когда нужно, чтобы переменная этого типа гарантированно обладала определёнными свойствами, рекомендуется использовать <code>signed char</code> или <code>unsigned char</code>.
    </p>
    <p class="todo">Описать диапазоны у всех типов</p>

    <h4>Символы и строки</h4>
    <p>Одиночные символы типа <code>char</code> заключаются в одинарные кавычки (<code>'a'</code>), а строки типа <code>char[]</code> и <code>string</code> – в двойные (<code>"hello"</code>).</p>
    <p>Тип <code>wchar_t</code> — <em>(wide character type)</em> целочисленный тип с объёмом, достаточным для представления самого большого расширенного набора символов в системе. Этот тип имеет такой же размер и знак, как и лежащий в основе тип (<code>unsignet short</code> или <code>int</code>). Объекты <code>cin</code> и <code>cout</code> не подходят для работы с этим типом, необходимо использовать альтернативные объекты <code>wcin</code> и <code>wcout</code> из <code>iostream</code>.</p>
    <h4>Тип bool</h4>
    <p>Тип <code>bool</code> — логический (булевский) тип. Принимает значения <code>true</code> и <code>false</code>. Все нулевые значения интерпретирует как <code>false</code>, а ненулевые – как <code>true</code>. Любое числовое значение или значение указателя может быть интерпретировано неявно при присваивании значения переменной.</p>
    <h4>Константы</h4>
    <p>Константы позволяют сделать переменные неизменяемыми.</p>
    <p>Константы можно определить двумя способами:</p>
    <ul>
        <li>С помощью препроцессорной директивы <code>#define</code>. Это способ в стиле C, но поддерживается в C++. Обычно буквы в имени констант такого типа имеют верхний регистр.</li>
        <li>
            С помощью квалификатора <code>const</code>. Это способ в стиле C++, но поддеживается в ANSI C. Имена таким константам принято задавать подобно обычным переменным. Этот способ лучше препроцессорной директивы по трём причинам:
            <ol>
                <li>Можно явно задать тип константы.</li>
                <li>Можно ограничивать область видимости таких констант.</li>
                <li>Можно использовать для более сложных типов, например, для массивов, структур и тд.</li>
            </ol>
        </li>
    </ul>

    <h4>Преобразования типов</h4>
    <p>Правила преобразования при инициализации и присваивании и возможные проблемы:</p>
    <ul>
        <li>При присваивании нулевого значения переменной типа <code>bool</code> будет интерпретировано как <code>false</code>, а ненулевого – как <code>true</code>.</li>
        <li>При присваивании значения переменной одного типа переменной другого типа это значение преобразуется к типу переменной, которая получает значение.</li>
        <li>При присваивании значения переменной целочисленного типа переменной с плавающей точкой может привести к потере точности из-за слишком малого количества значащих цифр переменной с плавающей точкой. <span class="more">(см. таблицу типов с плавающей точкой)</span></li>
        <li>
            При преобразовании большего типа с плавающей точкой в меньший тип с плавающей точкой (например, <code>double</code> &rarr; <code>float</code>) могут произойти следующие проблемы:
            <ul>
                <li>Потеря точности (значащих цифр)</li>
                <li>Исходное значение может превысить диапазон, допустимый для целевого типа, поэтому результат окажется неопределённым</li>
            </ul>
        </li>
        <li>
            При преобразовании типа с плавающей точкой в целочисленный тип могут произойти следующие проблемы:
            <ul>
                <li>Потеря дробной части</li>
                <li>Исходное значение может превысить диапазон целевого типа, поэтому результат будет неопределён</li>
            </ul>                       
        </li>
        <li>
            При преобразовании большего целочисленного типа в меньший целочисленный тип (например, <code>long</code> &rarr; <code>short</code>) могут произойти следующие проблемы:
            <ul>
                <li>Исходное значение может превысить диапазон целевого типа</li>
                <li>Обычно копируются только младшие байты</li>
            </ul>
        </li>
        <li>
            Преобразование при списковой инициализации {} (в C++11) имеет следующие свойства:
            <ul>
                <li>Не допускается сужение</li>
                <li>Преобразования типов с плавающей точкой в целочисленные типы не разрешены</li>
                <li>Преобразование целочисленных типов в другие целочисленные типы и в типы с плавающей точкой разрешены только если компилятор может сообщить, способна ли целевая переменная корректно хранить предоставленное значение.</li>
                <li>Преобразование большего целочисленного типа в меньший целочисленный тип разрешено только если значение вмещается в целевой тип и является константой</li>
            </ul>
        </li>
    </ul>

    <p>Правила преобразования арифметических типов при выполнении арифметических операций над ними:</p>
    <ul>
        <li>Если в арифметической операции участвуют два разных типа, то меньший тип преобразуется в больший</li>
        <li>При делении <strong>целочисленного типа</strong> на <strong>целочисленный тип</strong>, в результате получается целочисленный тип, любая дробная часть отбрасывается.</li>
        <li>
            Контрольный список, используемый для преобразований:
            <ol>
                <li>Если один из операндов имеет тип <code>long double</code>, то другой операнд преобразуется в <code>long double</code></li>
                <li>Иначе, если один из операндов имеет тип <code>double</code>, то другой операнд преобразуется в <code>double</code></li>
                <li>Иначе, если один из операндов имеет тип <code>float</code>, то другой операнд преобразуется в <code>float</code></li>
                <li>Иначе, операнды имеют целочисленный тип, и тогда используется целочисленное расширение, описанное ниже</li>
                <li>В этом случае, если оба операнда имеют знак, или оба операнда беззнаковые, и один из них имеет меньший ранг, чем другой, то они оба преобразуются в больший ранг</li>
                <li>Иначе, один операнд имеет знак, а другой беззнаковый. Если беззнаковый операнд имеет больший ранг, чем операнд со знаком, то последний преобрауется в тип беззнакового операнда</li>
                <li>Иначе, если тип со знаком может представить все значения беззнакового типа, беззнаковый опренд преобразуется к типу операнда со знаком</li>
                <li>Иначе, оба операнда преобразуются в беззнаковую версию операнда со знаком.</li>
            </ol>
        </li>
        <li>
            Целочисленные расширения:
            <ul>
                <li>Всегда, когда в выражениях встречаются типы <code>bool</code>, <code>char</code>, <code>unsigned char</code>, <code>signed char</code> и <code>short</code>, на время выполнения операции они преобразуются в тип <code>int</code>, т. к. этот тип наиболее естественный для компьютера, и операции над ним выполняются максимально быстро.</li>
                <li>Тип <code>unsigned short</code> преобразуется в <code>int</code>, если тип <code>short</code> короче, чем <code>int</code></li>
                <li>Если <code>short</code> и <code>int</code> имеют одинаковую ширину, то <code>unsigned short</code> преобразуется в <code>unsigned int</code></li>
                <li>Тип <code>wchar_t</code> расширяется в один из следующих типов, способный уместить значение: <code>int</code>, <code>unsigned int</code>, <code>long</code> или <code>unsigned long</code></li>
            </ul>
        </li>
    </ul>

    <p>Правила преобразования при передаче аргументов функции:</p>
    <ul>
        <li><span class="todo">Правила преобразования при передаче аргументов функции</span></li>
    </ul>

    <h4>Приведение типов</h4>
    <div class="table border border-grey headers-nowrap">
        <table class="black-border">
            <thead>
                <tr>
                    <th>Способ</th>
                    <th>Комментарий</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>(целевойТип)переменная</code></td>
                    <td>Стиль C</td>
                </tr>
                <tr>
                    <td><code>целевойТип(переменная)</code></td>
                    <td>Стиль C++</td>
                </tr>
                <tr>
                    <td><code>static_cast<целевойТип>(переменная)</code></td>
                    <td>Стиль C++</td>
                </tr>
            </tbody>
        </table>
    </div>
    <p class="todo">Описать 4 уникальных для C++ способа приведения типов</p>

    <h4>Обявление auto в С++11</h4>
    <p>Объявление <code>auto</code> позволяет автоматически выводить тип переменной, основываясь на значении, присваиваемом ей при инициализации. Чаще всего используется для более сложных типов, чем для примитивных.</p>
    <pre>
        <code class="lang-cpp">
            std::vector&lt;double&gt; scores;
            auto pv = scores.begin();
            // вторая строка эквивалентна: 
            // std::vector&lt;double&gt;::iterator pv = scores.begin();
        </code>
    </pre>
</div>