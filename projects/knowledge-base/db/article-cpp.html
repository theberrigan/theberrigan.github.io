<h1>C++</h1>
<p>
    Template – в терминах С++ просто синтаксис для создания классов, функций и тд.<br>            
</p>
<p>
    <code>"here is a string"</code> – строковой литерал.<br>
    Raw string literals – альтернатива для escaped characters.  
</p>
<div class="alert alert-success" role="alert">
    В числовых литералах можно использовать одинарную кавычку для разделения разрядов числа.
    Это никак не влияет на значение числа, но делает его более читаемым: <code>123'456</code>.
</div>

<h2>Заголовочные файлы</h2>
<p>Если импортируется заголовочный файл C++, то его расширение <code>.h</code> опускается: <code>#include &lt;iostream&gt;</code>. Если импортируется заголовочный файл, перенесённый из C, то расширение <code>.h</code> остаётся: <code>#include &lt;math.h&gt;</code>. Так же многие ЗФ, пересённые из C были переименованы (в начале добавлен префикс <code>c</code>), и они импортируются без расширения, например, <code>#include &lt;math.h&gt;</code> то же самое, что и <code>#include &lt;cmath&gt;</code>.</p>
<!--<listing lang="cpp">
#include <iostream>   // Новый стиль C++
#include <iostream.h> // Старый стиль C++
#include <cmath>      // Новый стиль C
#include <math.h>     // Старый стиль C             
</listing>-->
<p>Именование заголовоных файлов:</p>
<table class="table table-bordered">
    <thead>
        <tr>
            <th>Тип заголовка</th>
            <th>Соглашение</th>
            <th>Пример</th>
            <th>Комментарий</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="text-nowrap">Старый стиль C++</td>
            <td class="text-nowrap">Расширение <code>.h</code></td>
            <td class="text-nowrap"><code>iostream.h</code></td>
            <td>Используется в программах на C++</td>
        </tr>
        <tr>
            <td class="text-nowrap">Старый стиль C</td>
            <td class="text-nowrap">Расширение <code>.h</code></td>
            <td class="text-nowrap"><code>math.h</code></td>
            <td>Используется в программах на C и C++</td>
        </tr>
        <tr>
            <td class="text-nowrap">Новый стиль C++</td>
            <td class="text-nowrap">Без расширения</td>
            <td class="text-nowrap"><code>iostream</code></td>
            <td>Используется в программах на C++, используется пространство имён <code>std</code></td>
        </tr>
        <tr>
            <td class="text-nowrap">Новый стиль C</td>
            <td class="text-nowrap">Префикс <code>c</code>, без расширения</td>
            <td class="text-nowrap"><code>cmath</code></td>
            <td>Используется в программах на C++, может использовать свойства, не характерные для C, такие как пространство имён <code>std</code></td>
        </tr>
    </tbody>
</table>

<h2>Способы инициализации переменных</h2>
<table class="table table-bordered">
    <thead>
        <tr>
            <th>Инициализация</th>
            <th>Описание</th>
            <th><i>Примечание</i></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="text-nowrap"><code>int variable = 5;</code></td>
            <td>Классическия инициализация.</td>
            <td class="text-nowrap">C/C++</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>int variable(5);</code></td>
            <td>Значение переменной заключается в круглые скобки.</td>
            <td class="text-nowrap">C++</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>int variable{ 5 };</code><sup>1</sup></td>
            <td>Инициализация перменных с одним значением, которое заключается в фигурные скобки.</td>
            <td class="text-nowrap">C++11</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>int ary = {5, 10, 12};</code><sup>1</sup></td>
            <td>Инициализация перменных, которые имеют одно значение <i>или</i> являются массивом.</td>
            <td class="text-nowrap">C++11</td>
        </tr>
    </tbody>
</table>
<p><sup>1</sup> В последних двух случаях перменная инициализируется нулём, если скобки оставить пустыми. Кроме того, эти два способа предоставляют лучшую защиту от ошибок преобразования типов.</p>
<div class="alert alert-success" role="alert">
    Замечания по именованию переменных:
    <ul style="margin: 0;">
        <li>Переменные лучше всего объявлять как можно ближе к месту использования.</li>
        <li>Не использовать имена, начинающиеся с <code>_</code> для переменных, констант, функций и тд.</li>
    </ul>
</div>

<h2>Целочисленные типы</h2>
<p>Компьютер наиболее эффективно обрабатывает тип <code>int</code>, поэтому если нет веской причины выбирать другой тип, то лучше использовать именно его.</p>
<p>Программа хранит целочисленные литералы в виде типа <code>int</code>, за исключением двух случаев:</p>
<ul>
    <li>Используется специальный суффикс</li>
    <li>Типа <code>int</code> не достаточно для хранения представленного значения. Тогда для десятичного литерала используется наименьшим из следующих типов, способных его вместить: <code>int</code>, <code>long</code> или <code>long long</code>, а для шестнадцатеричного и восьмеричного литералов – <code>int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code> или <code>unsigned long long</code>.</li>
</ul>
<p>
    Ширина и диапазоны значений указаны с условием, что 1 байт равен 8 битам.<br>
    Для того, чтобы узнать размер типа в байтах для определённой реализации, нужно использовать операцию <code>sizeof</code>.<br>
    В заголовочном файле <code>climits</code> (в старых реализациях <code>limits.h</code>) указаны максимальные и минимальные значения для целочисленных типов в текущей реализации.
</p>
<table class="table table-bordered">
    <thead>
        <tr>
            <th>Тип</th>
            <th>Xранит</th>
            <th>Ширина</th>
            <th>Мин.</th>
            <th>Макс.</th>
            <th>Суфф./преф.</th>
            <th><code>climits</code><br><code>limits.h</code></th>
            <th>Прим.</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="text-nowrap"><code>char</code> <sup>7</sup></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= 8 бит</td>
            <td class="text-right text-nowrap">-128</td>
            <td class="text-right text-nowrap">127</td>
            <td class="text-nowrap">&#0151;</td>
            <td><code>CHAR_BIT</code>, <code>CHAR_MIN</code>, <code>CHAR_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>signed char</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= 8 бит</td>
            <td class="text-right text-nowrap">0</td>
            <td class="text-right text-nowrap">255</td>
            <td class="text-nowrap">&#0151;</td>
            <td><code>SCHAR_MIN</code>, <code>SCHAR_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>unsigned char</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= 8 бит</td>
            <td class="text-right text-nowrap">0</td>
            <td class="text-right text-nowrap">255</td>
            <td class="text-nowrap">&#0151;</td>
            <td><code>UCHAR_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>wchar_t</code> <sup>1</sup></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= 8 бита <sup>2</sup></td>
            <td class="text-right text-nowrap">&#0151; <sup>2</sup></td>
            <td class="text-right text-nowrap">&#0151; <sup>2</sup></td>
            <td class="text-nowrap">Преф. <code>L</code></td>
            <td> </td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>char16_t</code> <sup>3</sup></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">16 бит</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap">Преф. <code>u</code></td>
            <td> </td>
            <td>C++11</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>char32_t</code> <sup>3</sup></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">32 бита</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap">Преф. <code>U</code></td>
            <td> </td>
            <td>C++11</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>short</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= 16 бит</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap">&#0151;</td>
            <td><code>SHRT_MIN</code> <code>SHRT_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>int</code> <sup>5 6</sup></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= short</td>
            <td class="text-right text-nowrap">-2&nbsp;147&nbsp;483&nbsp;648</td>
            <td class="text-right text-nowrap">2&nbsp;147&nbsp;483&nbsp;647</td>
            <td class="text-nowrap">&#0151;</td>
            <td><code>INT_MIN</code> <code>INT_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>long</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= <code>int</code><br>&gt;= 32 бит</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap"><code>l</code>/<code>L</code></td>
            <td><code>LONG_MIN</code> <code>LONG_MAX</code> </td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>long long</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= <code>long</code><br>&gt;= 64 бит</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap"><code>ll</code>/<code>LL</code></td>
            <td><code>LLONG_MIN</code> <code>LLONG_MAX</code> </td>
            <td>C++11</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>unsigned short</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= 16 бит</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap">&#0151;</td>
            <td><code>USHRT_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>unsigned int</code> <sup>4 5</sup></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= short</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap"><code>u</code>/<code>U</code></td>
            <td><code>UINT_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>unsigned long</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= <code>int</code><br>&gt;= 32 бит</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap"><code>ul</code>/<code>UL</code></td>
            <td><code>ULONG_MAX</code></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>unsigned long long</code></td>
            <td class="text-nowrap">Целое</td>
            <td class="text-nowrap">&gt;= <code>long</code><br>&gt;= 64 бит</td>
            <td class="text-right text-nowrap"></td>
            <td class="text-right text-nowrap"></td>
            <td class="text-nowrap"><code>ull</code>/<code>ULL</code></td>
            <td><code>ULLONG_MAX</code></td>
            <td>C++11</td>
        </tr>
    </tbody>
</table>
<p>
    <sup>1</sup> Wide character type.<br>
    <sup>2</sup> Зависит от компилятора.<br>
    <sup>3</sup> Являются беззнаковыми типами.<br>
    <sup>4</sup> <code>unsigned</code> без указания типа аналогично <code>unsigned int</code>.<br>
    <sup>5</sup> типы <code>int</code> и <code>unsigned int</code> могут иметь ширину 16, 24 или 32 бита. В большинстве современных систем они имеют ширину 32 бита.<br>
    <sup>6</sup> <code>short int</code> то же самое, что <code>short</code>; <code>long int</code> то же самое, что <code>long</code>; <code>long long int</code> то же самое, что <code>long long</code>.<br>
    <sup>7</sup> тип <code>char</code> не является ни знаковым, ни беззнаковым, поэтому, когда нужно, чтобы переменная этого типа гарантированно обладала определёнными свойствами, рекомендуется использовать <code>signed char</code> или <code>unsigned char</code>.
</p>

<h3>Поведение при инициализации числовым литералом</h3>
Целочисленные константы (числа, указанные явно, например, 237) по умолчанию хранятся как <code>int</code> при условии, что этого типа данных достаточно для хранения этого числа, и, если число не имеет специального суффикса, указывающего на другой тип. Если для хранения числа недостаточно типа <code>int</code>:
<ul>
    <li>Для чисел в десятичной системе счисления будет использоваться <code>long</code> или <code>long long</code></li>
    <li>Для чисел в восьмиричной и шестнадцатиричной системах счисления будет использоваться тип <code>int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code> или <code>unsigned long long</code></li>
</ul>

<h3>Способы записи целочисленных литералов</h3>
<table class="table table-bordered">
    <thead>
        <tr>
            <th class="text-nowrap">Система счисления</th>
            <th class="text-nowrap">Правило</th>
            <th class="text-nowrap">Пример</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="text-nowrap">Десятичная</td>
            <td>Если число равно нулю или состоит из нескольких цифр и при этом первая цифра от 1 до 9.</td>
            <td class="text-nowrap"><code>1377</code></td>
        </tr>
        <tr>
            <td class="text-nowrap">Восьмиричная</td>
            <td>Если число <strong>не</strong> равно нулю, начинается с нуля, и остальные цифры находятся в диапазоне от 0 до 7.</td>
            <td class="text-nowrap"><code>073</code></td>
        </tr>
        <tr>
            <td class="text-nowrap">Шеснадцатиричная</td>
            <td>Число начинается с 0x или 0X и имеет в себе цифры от 0 до 9 и буквы от A до F (регистр не имеет значения).</td>
            <td class="text-nowrap"><code>0xf91a</code></td>
        </tr>
        <tr>
            <td class="text-nowrap">Двоичная</td>
            <td>Число начинается с 0b или 0B и имеет в себе цифры от 0 до 1. Только C++14.</td>
            <td class="text-nowrap"><code>0b10101011</code></td>
        </tr>
    </tbody>
</table>


<h2>Числа с плавающей точкой</h2>
<p>Числа с плавающей точкой можно представить в нормализованной (экспоненциальной) форме. Например, число <code>3 450 000</code> можно представить в виде <code>3.45e6</code>. Часть числа слева от <code>e</code> называется мантиссой, а справа – экспонентой (или порядком). Мантисса имеет точность, которая выражается в количестве её значащих цифр. Значащие цифры мантиссы – это все её цифры без всех нулей справа. Например, в числе <code>14 179</code> значащими являются все цифры, а в числе <code>14 000</code> значащими являются цифры <code>14</code>, а <code>000</code> – просто заполнители. Количество значащих цифр не зависит от позиции десятичной точки, например, в числе <code>14.179</code> значащими являются все цифры.</p>
<p>Заголовочный файл <code>cfloat</code> (<code>float.h</code>) содержит информацию о параметрах типов с плавающей точкой. <span class="more">см. &laquo;Прата – ЯП C++&raquo;, листинг на стр. 113</span></p>
<p>По умолчанию программа хранит константы с плавающей точкой в типе <code>double</code>. Если необходимо заставить программу хранить такое число во других типах, то необходимо добавить соответствующий суффикс из таблицы ниже.</p>
<p>Операции над числами с плавающей точкой выполняются медленее операций с целочисленными типами.</p>

<p>Числа с плавающей точкой представлены в соответсвии со стандартом IEEE 754. Этот стандарт определяет <code>+infinity</code>, <code>-infinity</code>, <code>nan</code> – специальные значения, которые принимает переменная с плавающей точкой в некоторых случаях. В заголовочном файле <code>cmath</code> есть функции <code>std::isinf()</code> и <code>std::isnan()</code>, которые позволяют проверить числовые переменные.</p>
<div class="alert alert-danger">
    Любое число, являющееся дробью с нечетным знаменателем, не может быть представлено в точности как двоичное значение с плавающей точкой.
    Нужно быть очень осторожным при сравнении и при рассчётах с числами с плавающей точкой.
</div>
<figure class="figure">
  <img src="images/cpp/ieee754_inf_nan.png" class="figure-img img-fluid">
  <figcaption class="figure-caption text-center">Операции, приводящие к +infinity, -infinity и nan</figcaption>
</figure>

<p>Таблица вещественных чисел:</p>
<table class="table table-bordered">
    <thead>
        <tr>
            <th>Тип</th>
            <th>Ширина <sup>1</sup></th>
            <th>Мин. знач. порядка</th>
            <th>Макс. знач. порядка</th>
            <th>Суффикс</th>
            <th>Значащая часть</th>
            <th><em>Прим.</em></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>float</code></td>
            <td>&gt;= 32 бит</td>
            <td class="text-right">-37</td>
            <td class="text-right">38</td>
            <td><code>f</code>/<code>F</code></td>
            <td></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td><code>double</code></td>
            <td>&gt;= 48 бит<br>&gt;= float <sup>2</sup></td>
            <td class="text-right">-307</td>
            <td class="text-right">308</td>
            <td>&#0151;</td>
            <td></td>
            <td>&#0151;</td>
        </tr>
        <tr>
            <td><code>long double</code></td>
            <td>&gt;= double <sup>3</sup></td>
            <td class="text-right">-4 931</td>
            <td class="text-right">4 932</td>
            <td><code>l</code>/<code>L</code></td>
            <td></td>
            <td>&#0151;</td>
        </tr>
    </tbody>
</table>
<p>
    <sup>1</sup> Здесь ширина означает объём памяти, выделяемый типом для хранения значащей части.<br>
    <sup>2</sup> <code>double</code> обычно имеет размер 64 бита.<br>
    <sup>3</sup> <code>long double</code> чаще всего имеет размер 80, 96 или 128 битов.
</p>

<h2>Приведение числовых типов</h2>
<h3>Неявное приведение типов</h3>
<p>Если выполняется арифметическая операция между числовыми переменными разных типов, то тип одной переменной приводится к типу другой. 
Это называется <em>неявное приведение</em> (implicit conversion). Переменная с большими ограничениями (по точности или ширине)
приводится к типу переменной с меньшими ограничениями:
<code>long double</code> ← <code>double</code> ← <code>float</code> ← <code>unsigned long long</code> ← <code>long long</code> ← 
<code>unsigned long</code> ← <code>long</code> ← <code>unsigned int</code> ← <code>int</code>.<br>Типы <code>char</code>, 
<code>signed char</code>, <code>unsigned char</code>, <code>short</code> и <code>unsigned short</code> 
всегда приводятся как минимум к <code>int</code>.</p>
<p>Важно понимать, что в выражении сначала выполняется приведение типов, а уже потом арифметическая операция. В следующем примере 
результатом будет <code>4294967286</code> вместо <code>-20</code>, поскольку переменная <code>y</code> сначала приводится
к <code>unsigned int</code>, поскольку C++ считает, что у него больше диапазон, а уже потом выполняется вычитание. Но беззнаковый 
<code>unsigned int</code> не может сохранить отрицательное значение и получается переполнение вправо (underflow):</p>
<!--<listing lang="cpp">
    unsigned int x { 20u };
    int y { 30 };
    auto z = x - y;  // unsigned int
    std::cout << z << std::endl;
</listing>-->
<p>Underflow – переполнение числовой переменной в левую сторону, а overflow - в правую.</p>
<p>Неявное приведение типов присходит при присвоении значения переменной одного типа переменной другого.</p>

<h3>Явное приведение типов</h3>
<p>Компилятор допускает суживающее неявное приведение, выдавая предупреждение. Лучше использовать <em>явное приведение</em> (expicit conversion/cast).</p>

<table class="table table-bordered">
    <thead>
        <tr>
            <th class="text-nowrap">Способ</th>
            <th class="text-nowrap">Комментарий</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="text-nowrap"><code>(целевой_тип)переменная</code></td>
            <td>Стиль C</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>целевой_тип(переменная)</code></td>
            <td>Стиль C++</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>static_cast<целевой_тип>(переменная)</code></td>
            <td>Стиль C++. Static означает статическое приведение, то есть при компиляции.</td>
        </tr>
    </tbody>
</table>
<p>Приведение переменной дробного типа к целому типу усекает (truncate) дробную часть. Если вместо усечения нужно округлить,
то можно использовать функции <code>std::round()</code>, <code>lround()</code> и <code>llround()</code> из STL.</p>

<p>В заголовочном файле <code>limits</code> есть функции <code>std::numeric_limits&lt;тип_переменной>::min()</code> и 
<code>std::numeric_limits&lt;тип_переменной>::max()</code> которые позволяют узнать минимальное и максимальное
значения для переменной типа <code>тип_переменной</code>. Важно, что для чисел с плавающей точкой функция <code>min()</code>
возвращают не отрицательное число, а минимальное положительное число. Для того чтобы узнать наименьшее отрицательное 
значение числа с плавающей точкой, нужно использовать функцию <code>lowest()</code>.</p>
<p>Помимо этих функций, в <code>limits</code> есть и множество других функций и констант:
<code>std::numeric_limits&lt;тип_переменной>::digits</code> – количество двоичных цифр в числе.<br>
<code>float positive_infinity = std::numeric_limits&lt;тип_переменной>::infinity();</code> – +infinity.<br>
<code>double negative_infinity = -std::numeric_limits&lt;тип_переменной>::infinity();</code> – -infinity.<br>
<code>long double not_a_number = std::numeric_limits&lt;тип_переменной>::quiet_NaN();</code> –  quiet_NaN.<br>
<code>long double not_a_number = std::numeric_limits&lt;тип_переменной>::signaling_NaN();</code> –  signaling_NaN.
</p>

<h2>Символьные типы</h2>
<ul>
    <li>
        <a href="https://en.wikipedia.org/wiki/Wide_character" target="_blank">Wide character</a>
        (<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%80%D0%BE%D0%BA%D0%B8%D0%B9_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB" target="_blank">Широкий символ</a>)
    </li>
</ul>
<!--<listing lang="cpp">
    char yes { 'Y' };
    char x { 120 };
    char tab { '\t' };
    char a { '\x41' };  // ASCII 'a' in hex
</listing>-->
<p>Тип <code>char</code> не является ни знаковым, ни беззнаковым, поэтому, когда нужно, чтобы переменная этого типа гарантированно 
обладала определёнными свойствами, рекомендуется использовать <code>signed char</code> или <code>unsigned char</code>.</p>

<p>Поскольку <code>char</code> является узким (narrow) 1-байтовым типом, то может хранить только 256 значений. Для представления 
Unicode-символов можно (но не нужно) использовать <code>wchar_t</code>. Этот тип является широким (wide), но его ширина зависит от компилятора. 
<code>wchar_t</code> — целочисленный тип с объёмом, достаточным для представления самого большого расширенного набора символов 
в системе. Этот тип имеет такой же размер и знак, как и лежащий в основе тип (<code>unsignet short</code> или <code>int</code>). 
Размер типа <code>wchar_t</code> определяется компилятором, вплоть до минимальных 8 бит. Соответственно, приложения, которым 
требуется сохранять переносимость на различных C и C++ компиляторах, не должны использовать <code>wchar_t</code> для хранения 
Unicode-текста. Тип <code>wchar_t</code> предназначен для хранения широких символов в том виде, в котором их понимают конкретные 
компиляторы, и это может не соответствовать Юникоду. Объекты <code>cin</code> и <code>cout</code> не подходят для работы с этим 
типом, необходимо использовать альтернативные объекты <code>wcin</code> и <code>wcout</code> из <code>iostream</code>.</p>

<p>Лучше всего использовать <code>char16_t</code>, который хранит символы, закодированные UTF-16, или <code>char32_t</code>, 
который использует UTF-32.</p>
<ul>
    <li><code>u</code> – префикс UTF-16</li>
    <li><code>U</code> – префикс UTF-32</li>
</ul>
<!--<listing lang="cpp">
    wchar_t wch {L'\x0438'};   // кириллическая "и"

    char16_t letter {u'B'};    // UTF-16-код для B
    char16_t cyr {u'\x0438'};  // UTF-16-код для кириллической "и"

    char32_t letter {U'B'};    // UTF-32-код для B
    char32_t cyr {U'\x044f'};  // UTF-32-код для кириллической "и"
</listing>-->

<h2>Строки</h2>
<p>Строки типа <code>char[]</code> и <code>string</code> заключаются в двойные кавычки <code>"hello"</code>.</p>

<h2>auto</h2>
<p>Объявление <code>auto</code> позволяет автоматически выводить тип переменной, основываясь на значении, 
присваиваемом ей при инициализации. Чаще всего используется для более сложных типов, чем для примитивных.</p>
<!--<listing lang="cpp">
    std::vector<double> scores;
    auto pv = scores.begin();
    // вторая строка эквивалентна: 
    // std::vector<double>::iterator pv = scores.begin();
</listing>-->
У <code>auto</code> есть <strong>много подводных камней</strong>:
<!--<listing lang="cpp">
    // (обратить внимание на знак =)
    // Выведется тип std::initializer_list<int> вместо int
    auto m = { 10 };

    // Здесь выведется ожидаемый тип std::initializer_list<int>
    auto list = { 1, 2, 3 };  

    // Обычно std::initializer_list<int> используется для инициализации контейнеров типа std::vector<>

    // C++11 и C++14
    auto i { 10 };              // i имеет тип std::initializer_list<int> !!!
    auto pi = { 3.14159 };      // pi имеет тип std::initializer_list<double>
    auto list1{ 1, 2, 3 };      // list1 имеет тип std::initializer_list<int>
    auto list2 = { 4, 5, 6 };   // list2 имеет тип std::initializer_list<int>

    // C++17 и новее
    auto i { 10 };              // i имеет тип int
    auto pi = { 3.14159 };      // pi имеет тип std::initializer_list<double>
    auto list1{ 1, 2, 3 };      // ошибка компиляции
    auto list2 = { 4, 5, 6 };   // list2 имеет тип std::initializer_list<int>
</listing>-->
<div class="alert alert-danger" role="alert">
    Не рекомендуется использовать для инициализации переменных синтаксис <code>= {}</code> вместе с <code>auto</code>.
</div>



<!-- //=====================================// -->
<!--
Конверсия типов:

Явная, неявная
При присваивании, при передаче аргумента
Как C++ выбирает тип для числового литерала
Как работать с числами с плавающей точкой
При арифметических операциях с разными типами

char, int, short, long, long long
float, double, long double
-->
<!-- //=====================================// -->

<h2>Всё о cin и cout</h2>  
<p><code>cin</code> (поток ввода) и <code>cout</code> (поток вывода) – это объекты, экземпляры классов <code>istream</code> и <code>ostream</code> соответсвенно.</p>
<div class="alert alert-success" role="alert">
    Объекты <code>cin</code> и <code>cout</code> не подходят для работы с типом <code>wchar_t</code>, необходимо использовать альтернативные объекты <code>wcin</code> и <code>wcout</code> из <code>iostream</code>.
</div>

<h3>cin</h3>
<table class="table table-bordered">
    <thead>
        <tr>
            <th class="text-nowrap">Способ вывода</th>
            <th class="text-nowrap">Описание способа</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="text-nowrap"><code>std::cout &lt;&lt; my_var;</code></td>
            <td class="text-nowrap">Выводит данные разных типов</td>
        </tr>
        <tr>
            <td class="text-nowrap"><code>std::cout.put('c');</code></td>
            <td class="text-nowrap">Выводит единственный символ типа <code>char</code></td>
        </tr>
    </tbody>
</table>

<!--<listing lang="cpp">
    cin >> charStr;
    cin.get()
    cin.get(charStr, length)
    cin.getline(charStr, length)
    getline(cin, stringStr)
</listing>-->

<h3>cout</h3>
<p>Манипуляторы</p>
<ul>
    <li>
        <code>endl</code> – манипулятор окончания строки; моментально выводит данные на экран (сброс буфера), в отличие от <code>\n</code>.
        <!--<listing lang="cpp">
            std::cout << "Hello!" << endl; 
        </listing>-->
    </li>
    <li>
        <code>dec</code> – выводить целочисленные типы в десятичном формате.
        <!--<listing lang="cpp">
            std::cout << std::dec << 325 << endl; // выведет: 325
        </listing>-->
    </li>
    <li>
        <code>hex</code> – выводить целочисленные типы в шестнадцатеричном формате.
        <!--<listing lang="cpp">
            std::cout << std::hex << 0xF6A9 << endl; // выведет: 0xF6A9
        </listing>-->
    </li>
    <li>
        <code>oct</code> – выводить целочисленные типы в восьмеричном формате.
        <!--<listing lang="cpp">
            std::cout << std::oct << 0744 << endl; // выведет: 0744
        </listing>-->
    </li>
    <li>
        <code>std::cout.setf()</code> устанавливает формат вывода данных. Например, <code>std::cout.setf(ios_base::fixed)</code> запретит использование экспоненциального формата для чисел с плавающей точкой при выводе данных.
    </li>
</ul>

<h2>sizeof</h2>
Функция sizeof() измеряет размер чего-то в разных единицах, возвращает число типа <code>size_t</code>, который в C++ определён как <code>unsigned int</code>:
<ul>
    <li>
        <code>sizeof(&lt;type>)</code> - размер типа <code>&lt;type></code> в байтах:
        <!--<listing lang="cpp">
            sizeof(char): 1
            sizeof(short): 2
            sizeof(short int): 2
            sizeof(int): 4
            sizeof(long int): 4
            sizeof(long): 4
            sizeof(long long): 8
        </listing>-->        
    </li>
    <li><code>sizeof("string")</code> - длина строки в символах (размер всегда больше видимого количества символов на один, т.к. учитывается нулевой символ \0)</li>
    <li>
        Массивы и указатели:
        <!--<listing lang="cpp">
            int nums[]{ 10, 20, 30 };
            int *pYears = new int[3]{ 2000, 2010, 2020 };
            sizeof(nums)    // 12 (размер массива в байтах)
            sizeof(pYears)  // 4  (размер указателя на int)
        </listing>-->
    </li>
</ul>
<p>Если <code>sizeof</code> применяется к имени типа, то скобки необходимы (<code>sizeof(int)</code>), а если к имени переменной, то скобки не обязательны (<code>sizeof my_var</code>).</p>
<div class="alert alert-danger" role="alert">
    Нельзя узнать размер массива через <code>sizeof</code>, созданного с помощью <code>new</code>, то есть массива, хранящегося в куче.
</div>

<h2>Bitwise ops</h2>
<div class="alert alert-danger" role="alert">
   В C++ не существует математических и битовых операций над целыми типами, меньше <code>int</code>.
   Поэтому при использовании таких операторов операнды неявно приводятся к типу <code>int</code>. 
   Нужно использовать <code>static_cast</code> после использования таких операторов.
</div>
<p><code>&lt;&lt;</code>/<code>>></code> на n бит эквивалентно умножению/делению на 2n.</p>
<p>В смещении участвует и знаковый бит, поэтому суть числа со знаком может сильно измениться после смещения.</p>
<p>Запись <code>number >>= 2;</code> эквивалентна <code>number = static_cast&lt;unsigned short>(number >> 2);</code>.</p>
<p>В целых числах со знаком при сдвиге вправо может вставляться 1 на место знакового бита, а может ставиться 0. Всё зависит от компилятора и ОС.</p>

<h2>enum</h2>
<!--<listing lang="cpp">
    // Эквивалентные способы объявления  
    enum Color { Red, Green, Blue };                             // Неявно присваиваются числовые значения 0, 1 и 2
    enum Color { Red = 0, Green = 1, Blue = 2 };                 // Явно присваиваются числовые значения 0, 1 и 2
    enum Color { Red = 0, Green = Red + 1, Blue = Green + 1 };   // Значение следующего члены вычисляется на основе предыдущего
</listing>-->
<ul>
    <li>Является альтернативой по отношению к <code>const</code> для создания логически связанных констант.</li>
    <li>Каждому члену можно явно присвоить число. Если число не указано явно, то член получает значение на 1 больше предыдущего члена.     
    <!--<listing lang="cpp">
        enum Player { 
            First,      // 0
            Second,     // 1
            Third = 5,  // 5
            Fourth,     // 6
            Fifth,      // 7
            Sixth = 5,  // 5
            Seventh     // 6
        };
    </listing>-->
    </li>
    <li>Членам enum можно присваивоить любую целочисленную compile-time-константу.
    <!--<listing lang="cpp">
        // Явно определён целочилсенный тип, который ляжет в основу этого enum
        enum class Punctuation : char {
            Comma  = ',', 
            Exclamation = '!', 
            Question='?' 
        };
    </listing>-->
    </li>
    <li>Члены <code>enum</code> не обязательно должны иметь уникальное числовое значение.
    <!--<listing lang="cpp">
        enum Color { Red = 1, Green = 1, Blue = 1 };
    </listing>-->
    </li>
    <li>Переменные типа <code>enum</code> автоматически преобразуются в <code>int</code>, но не обратно.
    <!--<listing lang="cpp">
        Color pixelColor;
        pixelColor = Red;
        pixelColor = 1;            // нельзя, потому что int не приводится к enum

        int pixelColor = Red;
        pixelColor = 1 + Red;      // можно, потому что enum не приводится к int
        pixelColor = Green + Red;  // нельзя
    </listing>-->
    </li>
    <li>Можно объявлять переменные того же типа, что и enum, а затем присваивать им значение любого из членов этого enum:
    <!--<listing lang="cpp">
        enum class Day { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday };

        // Три переменные типа Day, каждой из которых присвоено одно из значений enum
        Day yesterday{ Day::Monday }, 
            today{ Day::Tuesday }, 
            tomorrow{ Day::Wednesday };
    </listing>-->
    </li>
    <li style="opacity: 0.5">
        Размером конкретного enum будет число n-1, где n - наименьшее число, являющееся степенью двойки, которое больше максимального перечислителя.
        Например, значение наибольшего перечислителя равно 12. Ближайшее число, которое больше 12 и является степенью двойки - 16. Поэтому размер - 15.
    </li>
</ul>
Есть два способа объявить enum: старый (old-style) и сильно-типизованый (strongly typed):
<ul>
    <li>
        <code>enum</code>, объявленный старым способом, не имеют своего собственного скоупа:
        <!--<listing lang="cpp">
            enum Animals { Bear, Cat, Chicken };
            enum Birds { Eagle, Duck, Chicken };  // ошибка: Chicken has already been declared!            
        </listing>-->
        Новый способ такой проблемы не имеет:
        <!--<listing lang="cpp">
            enum class Fruits { Apple, Pear, Orange };
            enum class Colours { Blue, White, Orange };         
        </listing>-->
    </li>
    <li>
        <code>enum</code>, объявленный старым способом, используют неявное приведение типов, что может привести к странному поведению:
        <!--<listing lang="cpp">
            bool b = Bear && Duck;  // что?        
        </listing>-->
    </li>
    <li>
        Новый способ позволяет явно указать, какой целочисленный тип заложить в основу enum. Старый способ использует <code>int</code>.
        <!--<listing lang="cpp">
            // Для подсчёта использован char
            enum class Foo : char { A, B, C};    
        </listing>-->
    </li>
</ul>

<h2>Псевдонимы типов</h2>
Для создания псевдонима типа можно использовать один из следующих способов:
<ul>
    <li>
        Использовать препроцессорную директиву <code>#define</code> (старый способ):
        <!--<listing lang="cpp">
            // BYTE - псевдоним char
            #define BYTE char    
        </listing>-->        
    </li>
    <li>
        Использовать <code>typedef</code> (старый способ):
        <!--<listing lang="cpp">
            // byte - псевдоним char
            typedef char byte;
        </listing>-->
    </li>
    <li>
        Использовать ключевое слово <code>using</code> (предпочтительный способ):
        <!--<listing lang="cpp">
            // byte - псевдоним char
            using byte = char;
        </listing>-->
    </li>
</ul>

<h2>Компиляция, связывание и память</h2>
Ссылки:
<ul>
    <li><a href="https://en.wikipedia.org/wiki/Data_segment" target="_blank">Data segment</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Portable_Executable" target="_blank">Portable Executable</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Object_file" target="_blank">Object file</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Automatic_variable" target="_blank">Automatic variable</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Static_variable" target="_blank">Static variable</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">Call stack</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Memory_management" target="_blank">Memory management</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank">Stack buffer overflow</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Stack_overflow" target="_blank">Stack overflow</a></li>
    <li>https://en.wikipedia.org/wiki/Data_segment</li>
    <li>https://stackoverflow.com/questions/9535250/why-is-the-bss-segment-required</li>
    <li>https://stackoverflow.com/questions/93039/where-are-static-variables-stored-in-c-and-c</li>    
    <li>https://stackoverflow.com/questions/22311751/how-to-disassemble-a-lib-static-library</li>
    <li>https://stackoverflow.com/questions/305287/how-to-see-the-contents-of-windows-library-lib</li>
    <li>https://en.cppreference.com/w/cpp/language/storage_duration</li>
    <li>https://docs.microsoft.com/en-us/cpp/build/dlls-in-visual-cpp?view=vs-2017</li>
    <li>https://www.youtube.com/watch?v=Jzh4ZULXsvo</li>
    <li>https://www.youtube.com/watch?v=pLy69V2F_8M</li>
    <li>https://www.youtube.com/watch?v=H4s55GgAg0I</li>
    <li>https://www.youtube.com/watch?v=or1dAmUO8k0</li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
</ul>
<h3>Компиляция и процесс связывания (linking)</h3>
<p>Во время компиляции выполняется следующая последовательность действий:</p>
<ol>
    <li>
        Компилятор принимает все входящие cpp-файлы и пропускает их через препроцессор. 
        Сначала препроцессор рекурсивно проходит по всем файлам и заменяет все <code>#include</code>
        на содержимое соответствующих h-файлов. В результате получается <em>препроцессорная
        единица трансляции (компиляции)</em>. После этого препроцессор проходит по всем ПЕТ
        и заменяет все <code>#define</code>, <code>#ifdef</code> и тп на соответсввующие выражения.
        Таким образом получаются <strong>единицы трансляции</strong>.
    </li>
    <li>
        Заметка: <strong>модуль</strong> – это любая сущность в программе: функция, класс, переменнаяя и тд.
        Каждая ЕТ отправляется на компиляцию. На этом этапе компилятору важно, чтобы в каждом файле 
        содержались, как минимум, все необходимые объявления (declarations) модулей, используемых в данной ЕТ.
        Примером объявления можно назвать прототип функции. Но вместо простого объявления можно использовать
        непосредственное определение (definition) модуля. В случае функции – это функция с её реализацией. Как именно
        эти объявления/определения появились и представлены в этой ЕТ, компилятору не важно. Ему даже не нужны
        определения модулей. Если компилятор натыкается на объявление модуля, то он не будет проверять есть ли
        где-то определение этого модуля или нет – это будущая задача линковщика. Компилятор скомпилирует исходный 
        код каждой ЕТ в машинный код, а для каждого программного модуля с внешним связыванием (external linkage) 
        создаст "символ" – уникальный идентификатор, по которому линковщик будет связывать объектные файлы. 
        Для функции таким идентификатором служит её сигнатура: "тип_функции + имя_функции + аргументы_с_их_типами".
        Машинный код каждой ЕТ вместе с символами и кучей дополнительной мета-информации компилятор упакует
        в объектные (obj) файлы, по одному на каждую ЕТ. Объектный файл содержит следующую мета-информацию:
        <ul>
            <li>Header (descriptive and control information)</li>
            <li>Code segment ("text segment", executable code)</li>
            <li>Data segment (initialized static variables)</li>
            <li>Read-only data segment (rodata, initialized static constants)</li>
            <li>BSS segment (uninitialized static data, both variables and constants)</li>
            <li>External definitions and references for linking</li>
            <li>Relocation information</li>
            <li>Dynamic linking information</li>
            <li>Debugging information</li>
        </ul>
    </li>
    <li>
        Линковщик считает все obj-файлы и статические (lib) библиотеки (если такие подключены) и просто скопирует 
        их содержимое в конечный файл (exe/dll), а затем переопределит адреса всех инструкций, потому что после склейки
        в конечный файл, они изменились. Затем он извлечёт символы из объектных файлов и будет искать соответсвующие
        модули в соседних obj/lib-файлах и переопределять адреса этих модулей.<br>
        <strong>Статическая библиотека</strong> - это просто набор obj-файлов, которые упакованы в один AR-архив.
        Формат этого архива настолько прост, что obj-файлы в нём, по сути, просто склеены.
        Чтобы дизассемблировать статическую библиотеку: <code>dumpbin /disasm /OUT:output.asm input.lib</code><br>
        Чтобы просмотреть, из каких obj-файлов состоит: <code>dumpbin /ARCHIVEMEMBERS openssl.x86.lib</code>
    </li>
</ol>
<p>
    <img src="images/cpp/001.png" style="max-height: 350px;">           
</p>
<p>
    <img src="images/cpp/memory_layout.png" style="float: left; max-height: 800px; border: 1px solid #000;">
    <img src="images/cpp/memory_layout_2.png" style="float: left; max-height: 330px; box-shadow: inset 0 0 1px #000; border: 1px solid #000;">
    <img src="images/cpp/memory_layout_3.png" style="float: left; max-height: 330px; border: 1px solid #000;">
    <img src="images/cpp/memory_layout_linux.png" style="float: left; border: 1px solid #000;">
    <img src="images/cpp/memory_layout_win32.png" style="float: left; max-height: 350px; border: 1px solid #000;">
    <div style="clear: both"></div>
</p>

<h3>Квалификаторы и спецификаторы</h3>
cv-квалификаторы:
<ul>
    <li><code>const</code> – делает переменную константой.</li>
    <li>
        Если компилятор обнаружит, что программа несколько раз использует одну и ту же переменную в рамках нескольких операторов, то он может 
        оптимизировать код программы так, чтобы значение этой переменной кэшировалось в процессоре для ускорения операций с ним. Подразумевается
        что за это время значение переменной в ячейке памяти (не кэша) не изменится. Но бывают случаи, когда память может измениться, пока процессор 
        оперирует устаревшим закэшированным значением. Таким случаем может быть расшаренная память между процессами, или модификация памяти устройством, 
        которое используется этой программой. Квалификатор <code>volatile</code> запрещает как-либо кэшировать переменную.
    </li>
</ul>
Спецификаторы класса хранения:
<ul>
    <li><code>auto</code> – начиная с C++11 имеет новое назначение: автоматическое выведение типа переменной по её значению при инициализации.</li>
    <li><code>register</code> – начиная с C++11 потеряла свой изначальный смысл и теперь это просто способ явно указать, что переменная является автоматической.</li>
    <li><code>static</code> – применяется для явного обозначения переменной как статической и для переключения связывания с внешнего на внутренее.</li>
    <li><code>extern</code> – сигнализирует о том, что переменную нужно исползовать для внешнего связывания.</li>
    <li><code>thread_local</code> – </li>
    <li>
        <code>mutable</code> указывает, что какой-то член класса (структуры) может быть изменён, даже если переменная типа этого класса (структуры) объявлена с квалификатором <code>const</code>.
        <!--<listing lang="cpp">
            struct Data {
                int immutMember;
                mutable int mutMember;
            };

            // my объявлена константой, поэтому нельзя присвоить новое 
            // значение константе my или изменить её члены
            const Data my { 1, 2 };

            // однако член Data.mutMember объявлен как mutable, поэтому его можно изменить
            my.mutMember = 5;
        </listing>-->
    </li>
</ul>
<strong>Важно:</strong> в одном объявлении можно использовать только один из спецификаторов, кроме <code>thread_local</code> – 
в комбинации с ним можно использовать <code>static</code> или <code>extern</code>.

<h3>Продолжительность хранения переменной (storage duration)</h3>
Память, выделенную для программы делят на несколько хранилищ, в зависимости от того, как долго они хранят данные (переменные).
Время жизни каждой переменной зависит от того, в каком из чётырёх хранилищ она находится:
<ul>
    <li>
        Переменные, объявленные в блоке кода без ключевого слова <code>static</code>, находятся в <strong>автоматическом хранилище</strong>.<br>
        Они существуют с момента своего определения до конца блока кода, в котором определены, то есть до <code>}</code> этого блока.<br>
        Такие переменные называют <strong>автоматическими</strong> или <strong>локальными переменными</strong>.<br>
        Такие переменные имеют <strong>локальную</strong> или <strong>блочную область видимости</strong>.
    </li>
    <li>
        Переменные, объявленные с ключевым словом <code>static</code>, находятся в <strong>статическом хранилище</strong>.<br>
        Это <strong>статические переменные</strong>.<br>
        Они существуют с момента своего определения до конца работы программы.
    </li>
    <li>
        Переменные, для которых память выделяется динамически посредством ключевого слова <code>new</code>, хранятся в <strong>динамическом хранилище</strong>.<br>
        Они существуют с момента выделения памяти с помощью <code>new</code>, до освобождения памяти с помощью <code>delete</code>.
    </li>
    <li>        
        Переменные, объявленные с ключевым словом <code>thread_local</code>, находятся в <strong>хранилище потока</strong>.
    </li>
</ul>

<h3>Декларативные области и области видимости (scope)</h3>
Три важных термина, связанных с областью видимости:
<ul>
    <li>
        <strong>Декларативная область</strong> - любой блок кода, то есть код заключённый в <code>{}</code>.<br>
        Для имени декларативной областью будет корневой блок кода, в котором оно объявлено.
    </li>
    <li>
        <strong>Потенциальная область видимости</strong> - область с точки объявления имени, до конца декларативной области.<br>
        Потенциальная она потому что во вложенных блоках имя может быть перекрыто другим таким же именем.
    </li>
    <li>
        <strong>Фактическая область видимости</strong> (или просто "область видимости"/scope) - вся область где имя фактически доступно.  
    </li>
</ul>
<div class="alert alert-danger">
    В одной декларативной области не могут быть объявлены несколько переменных с одним именем.<br>
    И напротив: в разных декл. областях могут быть объявлены одинковые имена, не связанные друг с другом.
</div>
Области видимости переменных:
<ul>
    <li>
        <strong>Глобальная ОВ</strong> или <strong>ОВ файла</strong>. В неё входят переменные, определённые вне какого-либо блока кода.<br>
        Они хранятся в статическом хранилище и существуют с запуска программы до её завершения.<br>
        Глобальные переменные инициализируются до вызова функции <code>main</code>.<br>
        Если не инициализовать глобальную переменную сразу, то ей будет присвоено нулевое значение.<br>
        <strong>Важно:</strong> После добавления в C++ пространств имён, глобальная ОВ стала частным случаем ОВ пространства имён.
    </li>
    <li>
        <strong>Локальная ОВ</strong> или <strong>ОВ блока</strong>. В неё входят переменные, объявленные в каком-то блоке кода.<br>
        Такие переменные не имеют связывания.
    </li>
    <li><strong>ОВ прототипа функции</strong>. В неё входят переменные, находящиеся в скобках прототипа функции.</li>
    <li><strong>ОВ класса</strong>. В неё входят переменные, объявленные внутри класса.</li>
    <li><strong>ОВ пространства имён</strong>. В неё входят переменные, объявленные внутри пространства имён <code>namespace</code>.</li>
</ul>
<div class="alert alert-success">
    Функции могут иметь либо ОВ пространства имён (в том числе и глобальную ОВ), либо ОВ класса.
</div>

<h3>Связывание (linkage)</h3>
Есть несколько правил связи (linkage) для модулей, по которым компилятор будет решать внешняя это связь (external linkage) 
(то есть связь с другими obj/lib-файлами) или внутренняя (internal linkage) (только в рамках текущего obj-файла).
От того, как программист использует эти правила, будет зависеть работа линковщика на этапе связывания (linking).
<ul>
    <li><strong><code>auto</code>-переменные</strong> не имеют и не могут иметь связывания.</li>
    <li>
        <strong>Статические переменные:</strong>
        <ul>
            <li>Статическая переменная, объявленная в каком-то блоке с использованием ключевого слова <code>static</code> не будет иметь связывания.</li>
            <li>Статическая переменная, объявленная вне всех блоков с использованием ключевого слова <code>static</code> будет иметь внутреннее связывание.</li>
            <li>
                Переменная, объявленная вне всех блоков кода и <strong>без</strong> ключевого слова <code>static</code> 
                (то есть обычная глобальная переменная) будет статической переменной с внешним связыванием.
                Переменная с внешним связыванием должна быть объявлена в каждом файле, в котором она используется.
                Но в C++ используется "правило одного определения", то есть нельзя определять внешнюю переменную 
                с одним и тем же названием в разных файлах исходного кода.<br>
                Для решения этой проблемы существует специальный способ объявления переменной в разных файлах:
                <ol>
                    <li>
                        В одном файле нужно использовать <em>определяющее объявление</em>:
                        <!--<listing lang="cpp">
                            double var;  // == 0
                        </listing>-->
                        В этом случае выделяется память под переменную и она инициализируется.<br>
                        <strong>Важно:</strong> поскольку эта переменная объявлена в области видимости файла, она является статической, 
                        а любая статическая переменная при отсутствии инициализации (как в данном случае), автоматически инициализируется 
                        нулями при компиляции.
                    </li>
                    <li>
                        Во всех остальных файлах, где задействована эта переменная, нужно использовать <em>ссылочное объявление</em>.
                        Для этого нужно использовать ключевое слово <code>extern</code> и ни в коем случае не присваивать никакого значения:
                        <!--<listing lang="cpp">
                            extern double var;  // важно: присваивание отсутсвует
                        </listing>-->
                        При таком объявлении память под новую переменную не выделяется, а линковщик будет искать определение этой переменной в другом объектном файле.
                        Если же в таком объявлении присвоить какое-то значение, то создастся абсолютно новая переменная:
                        <!--<listing lang="cpp">
                            extern double var = 13.5;  // создалась новая переменная
                        </listing>-->
                        <strong>Примечание:</strong> не обязательно использовать ссылочное объявление вне любого блока, его можно использовать, например, внутри функции.
                    </li>
                </ol>
            </li>
        </ul>
    </li>
    <li>
        По умолчанию <strong>функции</strong>, объявленные в ОВ файла, имеют внешнее связывание. Чтобы переключить 
        связывание на внутреннее, нужно определять функцию с ключевым словом <code>static</code>.
    </li>
    <li>
        <strong>Константы:</strong>
        <ul>
            <li><code>const</code>, объявленные внутри блока, являются локальными для этого блока, поэтому не имеют связывания.</li>
            <li>                
                Глобальные <code>const</code>, в отличие от переменных, по умолчанию имеют внутреннее связывание. Это сделано для того, чтобы не повторять для констант
                неудобный механизм двойного объявления глобальных переменных с внешним связыванием через <code>extern</code>. Переменным такой механизм нужен, 
                ведь они могут изменяться. А константы – неизменяемы, поэтому ничего страшного если каждый cpp-файл, который включит хедер с константой, получит свой 
                экземпляр этой константы. Но если необходимо внешнее связывание, то у каждого объявления константы нужно использовать <code>extern</code>:
                <!--<listing lang="cpp">
                    // file2.cpp
                    extern const int XC = 5;

                    // file1.cpp
                    extern const int XC;
                    std::cout << XC;  // 5
                </listing>-->
            </li>
        </ul>
    </li>
    <li>
        <strong>Неименованное <code>namespace</code></strong> задаёт именам, объявленным внутри него, внутренне связывание. 
        В этом плане, оно является альтернативой <code>static</code>. Подробнее см. раздел <strong>Пространства имён</strong>.
    </li>
    <li>
        Во время компиляции для декорирования имён модулей (name mangling), компилятор для C и C++ использует
        разные способы кодирования, поэтому обычное связывание не сработает (напрмер, одинаковые функции будут 
        иметь разные сигнатуры в C++ obj и в C obj).<br>
        Допустим, что в нашей программе, написанной на C++, используется статическая <strong>библиотека, написанная на C</strong>.
        Тогда для внешнего связывания нужно использовать <code>extern "C"</code>. Это укажет компилятору, что
        для этого модуля нужно использовать C-шный способ декорирования имён.
    </li>
</ul>
<div class="alert alert-success">
    <strong>Простое правило:</strong> использование <code>static</code> с именами в глобальном пространстве имён, 
    которые по умолчанию имеют внешнее связывание, задаёт им внутренне связывание (например, переменные и функции).
    Использование <code>extern</code> с именами в глобальном пространстве имён, которые по умолчанию имеют внутреннее 
    связывание, задаёт им внешнее связывание (например, константы). (Тем не менее, для назначения внутреннего связывания
    именам из глобального пространства имён лучше использовать неименованный <code>namespace</code>).
</div>

<h3>Размещение программы в памяти. Сегменты</h3>
<p>
    Когда программа загружается в память, разные её части размещаются в разных местах. 
    Где будут расположены переменные и константы, зависит от их связи (linkage), области видимости (scope) и 
    от того, определено их значение или нет.
</p>

<h3>Пространства имён</h3>
Правила пространств имён:
<ul>
    <li>
        <code>namespace</code> могут быть вложены друг в друга, но их нельзя вкладывать в блоки кода, и сами они не являются блоками кода.
        Поэтому, имена, объявленные непосредственно внутри <code>namespace</code> имеют точно такое же связывание, как если бы они 
        были объявлены вне какого-либо блока кода (то есть на глоб. уровне).        
    </li>
    <li>
        Для пространства имён можно создать псевдоним:
        <!--<listing lang="cpp">
            namespace B = A;                       // B - псевдоним A
            namespace MEF = myth::elements::fire;  // MEF - псевдоним myth::elements::fire
        </listing>--> 
    </li>
    <li>
        Файл исходного кода и соответствующий ему заголовочный файл должны иметь одинаковую пространств имён:
        <!--<listing lang="cpp">
            // module.h
            namespace my {
                void fn();
            }

            // module.cpp
            namespace my {
                void fn() {
                    // ...
                }
            }
        </listing>--> 
    </li>
    <li>
        Если в пространстве имён определено несколько функций с одним и тем же именем, но разной сигнатурой, 
        то использование <code>using</code> импортирует сразу все версии этой функции.
    </li>
    <li>Заголовочные файлы, перенесённые из C и подключаемые с указанием расширения .h не имеют пространств имён.</li>
    <li>Все имена стандартной библиоткеки находятся в пространстве имён <code>std</code>.</li>
</ul>
Пространства имён:
<ul>
    <li>
        <strong>Глобальное пространство имён</strong> - пространство имён, которое не задаётся явно и совпадает с декларативной областью файла.<br>
        До появления <code>namespace</code> имена, объявленные на уровне файла назывались глобальными именами, а теперь они описываются как часть глобального пространства имён.<br>
        Особенность ГПИ заключается в том, что с именами, объявленными в нём, не используется уточнение <code>::</code>, но при этом это уточнение неявно подразумевается. 
        Поэтому уточнение <code>::</code> для глобальных имён можно указать явно, например, <code>::glob_var</code>. Это удобно, если внутри какого-то блока кода глобальное
        имя перекрыто таким же локальным именем, и при этом нужно обратиться к глобальной его версии:
        <!--<listing lang="cpp">
            // Здесь глобальное ПИ
            int var{ 5 };

            void fn () {
                double var{ 10.5 };
                cout << var << " + " << ::var;  // Выведется: 5 + 10.5
            }
        </listing>-->        
    </li>
    <li>
        <strong>Именованное пространство имён</strong> - задаётся с помощью <code>namespace</code>, за которым следует имя ПИ.
    </li>
    <li>
        <strong>Неименованное пространство имён</strong> - задаётся точно так же, как и ИПИ, но без имени.<br>
        Имена, объявленные в НПИ, имеют область видимости своей декларативной области, то есть они будто объявлены вообще без этого НПИ.
        Поскольку имена объявлены внутри НПИ, это ПИ должно иметь имя, чтобы его можно было использовать в других файлах
        исходного кода. Но НПИ имени не имеет, поэтому его (и всего имена внутри его) невозможно использовать за пределами
        данного файла исходного кода. Эта особенность используется для того, чтобы задать именам внутри НПИ внутреннее связывание.
        То есть это альтернатива ключевому слову <code>static</code> для переменных и функций.
    </li>
</ul>
Примеры пространств имён:
<!--<listing lang="cpp">
    A::var;      // обратиться к переменной/константе var из ПИ A
    A::B::fn();  // вызвать ф-цию, которая находится в ПИ B, которое находится в ПИ A
    ::var;       // обратиться к переменной из глобального пространства имён
</listing>--> 
Два типа <code>using</code>:
<ul>
    <li>
        <strong>Объявление <code>using</code></strong> - помещает имя из пространства имён в текущую декларативную область:
        <!--<listing lang="cpp">
            void fn () {
                using A::var;  // теперь в этой декларативной области доступна переменная var
            }
        </listing>--> 
    </li>
    <li>
        <strong>Директива <code>using</code></strong> - извлекает все имена из ПИ и делает их доступными в текущей декларативной области:
        <!--<listing lang="cpp">
            void fn () {
                using namespace A;  // теперь в этой декларативной области доступны все имена из ПИ A
            }
        </listing>--> 
    </li>
</ul>
<p>
    Отличие объявления <code>using</code> и директивы <code>using</code> в том, что в случае объявления (импорт одного имени)
    при возникновении конфликта имён произойдёт ошибка, а в случае директивы (импорт сразу всех имён)
    при конфликтах произойдёт перекрытие имени из ПИ, именем из локальной области видимости.    
</p>
Советы:
<ul>
    <li>Использовать ИПИ вместо объявления имён в глобальном пространстве.</li>
    <li>Использовать НПИ вместо <code>static</code> для назначения глобальным именам внутреннего связывания.</li>
    <li><code>using</code> не следует использовать в заголовочных файлах.</li>
</ul>

<h3>Использование заголовочных файлов</h3>
<div class="alert alert-success">
    В заголовочные файлы <strong>не</strong> следует помещать сущности, которые представляют собой непосредственный код программы.
    Туда нужно помещать сущности, которые дают инструкции компилятору для выполнения компиляции.
</div>
В заголовочные файлы <strong>нужно</strong> помещать:
<ul>
    <li>Определение типов</li>
    <li>Прототипы функций</li>
    <li>Символические константы, определённые с помощью <code>#define</code> или <code>const</code></li>
    <li>Объявления структур</li>
    <li>Объявления классов</li>
    <li>Объявления шаблонов</li>
    <li><strong>Определения</strong> inline-функций</li>
</ul>
В заголовочные файлы <strong>не следует</strong> помещать:
<ul>
    <li>Определение функций</li>
    <li>Объявление переменных</li>
</ul>

<h3>Замечания</h3>
<ul>
    <li>
        Если в глобальной и локальной области видимости есть переменная с одним и тем же именем, то для получения доступа к глобальной переменной,
        нужно использовать унарный оператор <code>::</code>. Например, <code>::var</code>.
    </li>
    <li>Делать переменные глобальными не рекомендуется. А вот глобальные константы – это нормально.</li>
    <li>
        Случайное обращение к памяти, котора не пренадлежит процессу или конкретной переменной в программе, 
        может вызвать ошибку <em>segmentation fault</em> или <em>access violation</em>.
    </li>
</ul>

----------------------------------

- символы/сигнатуры модулей зависят от компилятора, поэтому obj/lib от разных компиляторов могут не связаться
- хедер должен включаться один раз. Для контроля этого есть #pragma once
- не нужно использовать #include для включения файлов исходного кода, только для хедеров
- память процесса делится на следующие сегменты:
  - стек, в x86 растёт вниз
  - куча, растёт вверх
  - bss - сегмент, который хранит все глобальные переменные и локальные статические переменные, которые инициализированы нулём или не имеют явной инициализации в коде. (оптимизация)
  - data - read-write сегмент, который хранит все глобальные переменные и локальные статические переменные, инициализированные явно не нулём.
    Размер этого сегмента у каждой программы свой, и он не меняется на протяжении выполнения программы.
  - text/code - там код программы и, по-моему, константы
- динамически выделенная память, которую забыла очистить программа через delete очищается после завершения программы (но не всегда, иногда ОС не способна зачистить память сама (ЯП С++, с457))
- static перед функцией говорит о том, что она может использоваться только в рамках этой единицы компиляции.
  В противном случае компилятор подразумевает, что эта функция потенциально может вызывать где-то за пределами этой единицы компиляции.
- константы по умолчанию имеют внутреннее связывание
- если статическая переменная не инициализирована явно при объвлении, то компилятор инициализирует её нулём.

- инициализация с помощью new (ЯП С++, с458):
  - Синтаксис с круглыми скобками, который можно использовать для скалярных типов и для классов, 
    которые имеют подходящий конструктор (но нельзя использовать для структуры или массива):
    int* pi = new int(6);
  - Синтаксис списковой инициализации C++11, который можно использовать И для структуры или массива: 
    User* usr = new User{ 1, "John" };     // структура
    int* arr = new int[4]{ 1, 2, 3, 4 };   // массив
    int* id = new int{ 5 };                // числовая перем
    int* pi = new int{};                   // иниц. нулями
- new может сбоить, если не сможет выделить достаточный объё памяти.
  очень давно в этом случае указатель принял бы нулевое значение.
  но сегодня генерируется исключение std::bad_alloc
- !!! delete можно использовать только для освобождения памяти в куче, выделенной обычным оператором new (не "new с размещением")
- внутри языка операторы new и delete определны как функции:
  void * operator new(std::size_t);
  void * operator new[](std::size_t);
  void operator delete(void *);
  void operator delete[](void *);
  Поэтому:
  - int * pi = new int;
    эквивалентно
    int * pi = new(sizeof(int));
  - int * pa = new int[40];
    эквивалентно
    int * pa = new(40 * sizeof(int));
  Функции new и delete называются заменяемыми.
- По умолчанию new ищет в куче блок памяти, который удовлетворяет запрашиваемому размеру и возвращает первый попавшийся. (ЯП С++, с460)
  Существует оператор "new с размещением", которому можно указать адрес блока для выделения (эта память может находиться где угодно).
  "new с размещением" всего лишь принимает адрес памяти, приводит его к типу void*, чтобы его можно было присвоить любому типу указателя, и возвращает его обратно.
  "new с размещением" можно переопределить.
  Обычный оператор new вызывает функцию new с одним аргументом, а "new с размещением" вызывает функцию new с двумя аргументами, где второй - это блок памяти для размещения.
  (ситуация сложнее с объектами класса, см Прата гл. 12)
  #include <new>
  struct User {
      char name[20];
      int id;
  }
  char buffer1[50];
  char buffer2[500];
  User *p1, *p2;
  int *p3, *p4;
  // обычный new
  p1 = new User;
  p3 = new int[20];
  // new с размещением
  p2 = new (buffer1) User;
  p4 = new (buffer2) int[20];
- Особенность указателя void* в том, что указатель этого типа можно присвоить любому другому указателю.
  http://citforum.ru/programming/cpp_march/cpp_048.shtml






--

Static library (.lib) сразу после компиляции во время [статического] связывания добавляется внутрь конечного dll/exe-файла.
Dynamic library (.dll) во время запуска программы динамически связывается с основным exe/dll-файлом.
Статическая библиотека работает быстрее.
Динамическую библиотеку можно шарить между процессами (?).
Статическая библиотека, как obj-файл содержит машинный код вместе с символами, поэтому вместе со статической библиотекой
всегда идёт хедер, в котором определены прототипы сущностей.

--

Решение (solution) состоит как минимум из одного проекта (project).
Каждый проект состоит из разных файлов: .h, .cpp, и тд.
Поэтому есть несколько вариантов сборки:
- Скомпилировать (без связывания) только одну единицу компиляции внутри какого-то проекта внутри решения.
- Собрать какой-то из проектов внутри решения.
- Собрать всё решение.
* Под "собрать" подразумевается компиляция с последующим связыванием.

--

Подгрузка динамических библиотек (в какой сегмент)
? Precompiled headers
How to create and load lib and dll libs

static - static or thread storage duration and internal linkage.
extern - static or thread storage duration and external linkage.

ресурсы:
- memory management in c
- прата ЯП С++б стр 430

obj/lib/dll
linkage
linking
storage durations
namespaces
precompiled headers

+----------------------------------+
|----------------------------------|
+----------------------------------+

<h2>Условные операторы</h2>
<p>В C++17 вместо такого выражения:</p>
<!--<listing lang="cpp">
    {
        int var{ /* init */ };

        if (var > 5 && var < 10) {
            std::cout << var << std::endl;
        }
    }
</listing>-->
<p>можно использовать такое:</p>
<!--<listing lang="cpp">
    if (int var{ /* init */ }; var > 5 && var < 10) {
        std::cout << var << std::endl;
    }
</listing>-->
<p>При этом переменная <code>var</code> будет видна как в условном выражении, так и внутри блока.</p>
<p><code>switch</code> имеет такую же возможность в C++17: <code>switch (initialization; condition) { ... }</code></p>

<h2>Массивы</h2>
<p>Инициализировать массивы можно несколькими способами. При это в квадратных скобках нужно указать кол-во элементов (должна быть константа), 
а в фигурных можно сразу задать элементы. Если элементы заданы сразу, то кол-во эл-ов в квадратных скобках можно опустить.</p>
<!--<listing lang="cpp">
    int months[12];                 // в стеке, только выделение памяти
    int months[12] = { 1, 2, 3 };   // в стеке, выделение памяти для 12 элементов, заполнение только 3х элементов
    int months[] = { 1, 2, 3 };     // в стеке, 
    int months[] { 1, 2, 3 };       // в стеке, стиль С++11
</listing>-->
<p>Некоторые правила:</p>
<ul>
    <li>
        Самый простой способ определить количество элементов в массиве в C++17 – функция <code>std::size(arr)</code> из STL.<br>
        Эта функция работает и с <code>std::array</code>, <code>std::vector</code>.<br>
        Эта ф-ция определна в хедере <code>iterator</code> и в <code>array</code>.
    </li>
    <li>
        Второй способ - <code>sizeof(arr) / sizeof(type)</code>, где <code>arr</code> - массив, а <code>type</code> - тип элементов массива.<br>
        Или <code>sizeof(arr) / sizeof(arr[0])</code>.
    </li>
    <li></li>
    <li></li>
    <li></li>
</ul>






<!-- 0000000000000000000 -->
<br><br><br><br><br><br><br><br><br><br><br>


static делает функцию (именно функцию, а не метод класса) видимой только для текущей единицы трансляции.
Это свойство можно использовать, например, для избавления от ошибки связывании при объявлении нескольких функций с одинаковой сигнатурой.

У include название хедера записывается в треугольных скобках когда компилятору нужно сообщить, чтобы он искал этот хедер
во всех include-директориях проекта. Двойные кавычки используется, когда нужно указать относительный для данного файла путь.

NULL определён как 0. В C++11 есть nullptr для того, чтобы обозначить указатель нулевым.

char* buffer = new char[8];  // буфер из 8 байт
memset(buffer, 0, 8);  // заполняет буфер нулями
delete[] buffer;

// Ссылочные переменные - это алиазы для переменной
// Ссылка - это T* const
int a = 5;
int& refA = a;  // ссылочная переменная
cout << refA;   // выведется 5
refA = 10;      // записывается новое значение в память, на которую укзаывает refA. То есть переменной a присваивается новое значение.
cout << a;      // выведется 10
// ! Ссылочной переменной необходимо назначать адрес во время объявления, как константе. Назначить новый адрес самой ссылочной переменной невозможно.
//-----------
void inc (int& v) { v++; }
int a = 5;
inc(a);
cout << a;  // 6



if-else, switch-case, while, for, do-while 
static, volatile, extern, inline, virtual, private, public, protected
struct, class, enum, union,
array, vector
ссылки; обычные указатели; умные указатели; указатели на строки, массивы, константы; арифметика указателей
Как представлены числа в C++ и особенности работы с ними
template, constexpr, decltype
obj, internal linkage, static linkage, dynamic linkage, thread storage
RAII, RTTI
Как работать со строками
Комбинация ссылок/указателей и многомерных/одномерных массивов
В чём принципиальное отличие класса от функции

УКАЗАТЕЛИ: 
    на функции/объекты/константы/указатели/строки
    на массивы скаляров/строк/указателей/констант/объектов
    константные указатели
    передача указателя в качестве аргумента и в качестве возвратного значения
    указатели и ссылки
    арифметика указателей
    указатель void*
    приведение разных типов указателей
    указатель на память, определённую через new с размещением
    reinterpret/dynamic_cast();

Static class member/static function (C-style)

Как правильно работать с арифметикой целых чисел и чисел с плавающей точкой:
- "Совершенный код" стр 282
- "Beginning C++17" стр 157
- Книги по алгоритмам
- https://www.codeproject.com/Articles/29637/%2FArticles%2F29637%2FFive-Tips-for-Floating-Point-Programming
- ! https://floating-point-gui.de/

virtual: http://www.lrdev.com/lr/c/virtual.html
*_cast: https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used

Кроссплатформенность C++

Best Practices

<!--
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
-->
<pre hidden>
    В 60х года была разработана ASCII для представления символов. Для кодирования каждого символа она использовала
    7 бит, что позволяло закодировать 128 символов (кодовых точек). Из языков туда помещался только латинский.
    Для того, чтобы преодолеть огричения, начали разрабатывать кучу 8-битных кодировок, первые 128 бит, которых
    повторяли ASCII, а оставшиеся 128 бит отдавали под прочие символы и алфавиты. Например, Latin-1 предоставляет
    символы для большинства европейских языков.

    +-------+
    | ASCII |
    +-------+-------------------------------+----------------------------+
    |                                       | <32 управляющих символа>   |
    | Знаки пунктуации:                     | <пробел>!"#$%&'()*+,-./    |
    | Цифры:                                | 0123456789                 |
    | Ещё знаки:                            | :;<=>?@                    |
    | Латинский алфавит в верхнем регистре: | ABCDEFGHIJKLMNOPQRSTUVWXYZ |
    | Ещё знаки:                            | [\]^_`                     |
    | Латинский алфавит в нижнем регистре:  | abcdefghijklmnopqrstuvwxyz |
    | Ещё знаки:                            | {|}~                       |
    +---------------------------------------+----------------------------+

    Для того, чтобы преодолеть и эти ограничения, в начале 90х был разработан стандарт Universal Character Set (UCS),
    который позволял кодировать каждый символ 32 битами (стандарт ISO 10646). UCS определяет соответсвие между
    кодируемыми символами и их числовыми кодами (кодовыми точками).

    <послед._символов> -----> (UCS) -----> <послед._кодовых_точек> -----> (кодировка_UTF-8/16/32) -----> <послед._байт>

    Universal Character Set (UCS) - стандартизированный набор символов, определяемый стандартом ISO 10646. Поскольку
    он разрабатывается в тесном сотрудничестве со стандартом кодирования Unicode, то наборы сиволов в обоих
    стандартах идентичны.

    Помимо самого набора символов ISO 10646 определяет ещё и несколько способов их кодирования (encoding forms).
    Один из этих способов - 16-битная кодировка UCS-2. Эта кодировка способна закодировать 2 ^ 16 = 65536 символов.
    То есть всю Basic Multilingual Plane (BMP).

    Первая поправка к UCS добавила кодировку UTF-16 в качестве расширения к UCS-2. В рамках BMP (65536 кодовых точек)
    UTF-16 полностью совместима с UCS-2. Но для того, чтобы кодировать символы выходящие за рамки BMP использована
    следующая схема: ближе к концу BMP специальным образом выбраны два интервала кодовых точек, стандарт запрещает
    размещать в них символы. Кодовые точки из первого интервала называются нижней сурогатной парой, а кодовые точки
    из второго – верхней сурогатной парой. Сложив их вместе определённым образом, UTF-16 получает кодовые точки
    выше BMP.

    Ещё один способ кодирования символов - UCS-4. Эта кодировка использует фиксированные 4 байта для кодирования символов,
    что теоретически позволит закодировать 0x7FFFFFFF символов, но стандарт определяет предел в 0x10FFFF.

    Итак:
    - UCS - универсальный набор символов, который используется стандартами UCS (ISO 10646) и Unicode.
    - UCS-2 - самая первая кодировка фиксированной ширины - 16 бит. Может закодировать 2 ^ 16 = 65536 символов (всю BMP).
    - UCS-4 - вторая кодировка фиксированной ширины - 32 бита. Может закодировать 2 ^ 32 = 0x7FFFFFFF символов, но ограничена 0x10FFFF.
    - UTF-16 - кодировка переменной ширины, является расширение UCS-2, то есть полность совместима с ней при кодировании
      всей BMP, но дальше использует механизм сурогатных пар.
    - UTF-8 - кодировка переменной ширины, которая совместима с ASCII, в отличие от других кодировок стандарта.
      Кроме того, у этой кодировки отсутствует проблема порядка следования бит, и, как следствие, – BOM.

    UCS-2 и UCS-4 устарели.
    UTF-16 используется редко, в основном в Windows, Java и Javascript.
    UTF-32 используется реже всего.
    UTF-8 доминирует в мире.
                                                                  ~84%                ~85%                ~87%
    +------------------------------------------------------------------------------------------------------------------+
    | 0                                                             | D800 ....... DBFF | DC00 ....... DFFF |     FFFF | 
    +---------------------------------------------------------------+-------------------+-------------------+----------+
                                                                    |  High Surrogates  |  Low Surrogates   |
                                                                    +-------------------+-------------------+

    0x10000 + 0xFFFFF = 0x10FFFF - максимум кодируемых символов (~1.1 млн)

    --

    UTF-16

    // Кодирование в UTF-16
    codePoint = 0x10437
    H = (0x0437 >> 10) + 0xD800    // 0xD801
    L = (0x0437 & 0x3FF) + 0xDC00  // 0xDC37

    // Декодирование из UTF-16
    H = 0xD801
    L = 0xDC37
    codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000  // 0x10437

    Unicode определяет абстрактные символы и присваивает ему порядковый номер в таблице - кодовую точку.
    Кодовые точки лежат в диапазоне от 0 до 0x10FFFF (1 114 112) вне зависимсоти от кодировки.
    0x10FFFF - 21 бит.

    --

    UTF-8:
    - Полностью совместима с ASCII
    - Использует 1-4 байта для кодирования символов
    - 


    --


    Источники:
    - https://en.wikipedia.org/wiki/Universal_Coded_Character_Set
    - https://en.wikipedia.org/wiki/Unicode
    - https://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings
    - https://en.wikipedia.org/wiki/UTF-8
    - https://en.wikipedia.org/wiki/UTF-16
    - https://en.wikipedia.org/wiki/UTF-32
    - https://codeahoy.com/2016/05/08/the-char-type-in-java-is-broken/


    // -------------------------------------
    // СТРОКИ И КОДИРОВКИ
    // -------------------------------------

    <СТАРОЕ_ОПИСАНИЕ>

    ASCII - 7-битная кодировка, которая может отображать символы 0-127.
    ISO-8859-1 и the latin-1 - 8-битные кодировки, отображающие 0-255 символы, перые 128 символов совпадают с ASCII.

    В таблицах символов коды символов правильно называются codepoints, а сами таблицы - code pages.
    Сами по себе codepoints являются обычными числами, а их представление в памяти выражено в
    encoding scheme. Еncoding scheme определяет, сколько байт использовать для каждой codepoint
    в памяти. Это число может быть постоянным (2 байта на codepoint) или динамическим (1/2/3 байта на символ).
    Набор символов, за каждым из которых закреплена codepoint, в code pages называется character set.

    Unicode - кодировка, в code pages которой есть codepoints для всех известных человеку символов, в том числе для всех языков.
    Каждая codepoint в юникоде имеет свой порядковый номер в формате U+0048 ('\u0048'), где 48 - hex (символ H). 
    Первые 256 codepoints соотвествуют latin-1, а первые 128 символов - ASCII.
    Все codepoints в юникоде разделяются на области (planes) по 2 ^ 16 (65536) codepoints на каждую область.
    Первый plane (0 - 0xFFFF) называется Basic Multilingual Plane (BMP) и покрывает все человеческие языки.

    UNICODE

    У Unicode несколько сосуществующих стандартов кодирования codepoints:
    - UTF-8: в этом стандарте используется схема кодирования переменной длины: 
      первые 127 символов (codepoints) (U+0000 - U+007F) кодируются 7 битами в соответствии с ASCII.
      для всех остальных codepoints специальный escape-символ заставляет интерпретировать следующие за ним байты
      для отображения codepoints требующих больше 8 бит для кодирования. Фактически UTF-8 не совместим с latin-1.
    - UTF-16: использует 16 бит для кодирования codepoints, что позволяет последовательно закодировать 
      2 ^ 16 (65536) codepoints, то есть весь Basic Multilingual Plane (BMP). Но UTF-16 также может кодировать и 
      codepoints >65536 с помощью специальной хитрой схемы:
      По стандарту юникод резервирует два интервала codepoints в BMP: 
      - High Surrogates (HS): от U+D800 до U+DB7F
      - Low Surrogates (LS): от U+DC00 до U+DFFF
      И для кодирования codepoints >65536 использует пары codepoints из HS и LS:
      левый элемент пары выражается codepoint из HS, а правый - codepoint из LS: например, U+D800U+DC00.
      Такие пары называются сурогатными. Как только декодер натыкается на codepoint из HS, он понимает ,что имеет дело с 
      сурогатной парой, нужно считать следующий LS-codepoint и декодировать их вместе особым образом.
    - UTF-32: просто использует 32 бита для кодирования codepoints, что позволяет выразить 2 ^ 32 (4294967296) codepoints.

    BOM

    Для многобайтных кодировок (UTF-16 и UTF-32) важно указать порядок следования байт (Big Endian или Little Endian).
    Есть два варианта как это сделать:
    - Использовать BOM (Byte order mark): в начало текста поместить символ U+FEFF, который не имеет визуального представления.
      Этот символ даёт понять декодеру, что он сам должен определить порядок следования байт.
    - Если BOM не задействован, то необходимо указывать порядок следования битов в самой кодировке (UTF-16BE/UTF-16LE, UTF-32BE/UTF-32LE)

    </СТАРОЕ_ОПИСАНИЕ>


    ГЛОССАРИЙ

    - Октет - 8 смежных бит, вместе образующих кусок данных. В большинстве архитектур
      соответствует одному байту.
    - Абстрактный символ (Abstract character) - графическое представление символа.
    - Кодовое пространство - диапазон целых чисел, каждому из которых может соответствовать
      его абстрактный символ. Другими словами, это код символа в наборе символов.
    - Кодовая точка - любое число из кодового пространства (код символа в наборе символов).
    - Закодированный символ (Encoded character) - абстрактный символ, которому 
      поставлена в соответствие кодовая точка.
    - Кодовая единица (Code unit) - минимальное количество бит, которыми может быть 
      закодирован один символ текста.
    - Кластер графем (Grapheme cluster) - последовательность закодированных символов,
      которые визуально (для пользователя) являются одним символом.
    - Набор символов (Character set/Charset) - конечное множество закодированных 
      символов.
    - Кодовая страница (Code page) - частный случай набора символов. В отличие от 
      набора символов, который выражает множество всех закодированных символов данной
      кодировкой, кодовая страница выражает подмножество этого множества, которое
      может быть закодировано одной кодовой единицей. Таким образом, если набор символов
      текущей кодировки превышает одну кодовую страницу, то этот набор делится на
      несколько кодовых страниц. В однобайтовых кодировках набор символов совпадает 
      с кодовой страницей. В Windows понятие кодовой страницы имеет особое значение
      для локализации ОС, так как для неё Юникод не является основным стандартом 
      кодирования, и для каждой локали используются разные кодовые страницы, например 
      Windows-12XX и CP-XXX. Так в Windows 7 для русскоязычной командной оболочки CMD 
      используется кодовая страница CP866.


    УСТРОЙСТВО КОДИРОВОК

    В таблицах символов коды символов называются кодовыми позициями (code points), 
    а сами таблицы - кодовыми страницами (code pages). Сами по себе кодовые позиции 
    являются обычными числами, и они не определяют, как символы представлены в памяти. 
    Их представление в памяти задаётся схемами кодирования (encoding scheme), которые
    определяют, сколькими байтами представляется каждая кодовая позиция в памяти. 
    Например, одна схема кодирования может представлять кодовую позицию в памяти 
    с помощью 4-байт, а другая – переменным количеством байт: для наиболее часто 
    используемых символов - 2 байта, а для более редких - 3 или 4 байта. Символы, 
    расположенные в кодовых страницах, называются наборами символов (character set).


    НЕКОТОРЫЕ КОДИРОВКИ И КОДОВЫЕ СТРАНИЦЫ

    - ASCII - набор символов, кодовая страница и кодировка, использующая для кодирования
      один октет, старший бит которого всегда равен 0, а оставшиеся 7 бит кодируют 
      кодовые позиции 0-127. Позднее были разработаны многие другие 1-байтовые кодировки, 
      которые задействовали все 8 бит октета. Наборы символов этих кодировок содержат
      уже до 2 ^ 8 (256) кодовых позиций, первые 128 из которых идентичны соответствующим 
      кодовым позициям ASCII, а оставшиеся 128 используются для кодирования специфичных
      для этих кодировок кодовых позиций. То есть, эти кодировки совместимы с ASCII.
      К таким кодировкам относятся Latin-1, КОИ-8, CP866, Windows-1251, ISO-8859-1 и т.д.
    - CP866 - кодовая страница, разработанная в СССР для поддержки кириллицы. Полностью
      совместима с ASCII и для кодирования новых кодовых точек использует значения байтов
      со 128 до 255. Является стандартной для Windows 7 CMD.
    - ANSI-кодировка - превдоним для внутренней кодировки Windows, которая зависит 
      от текущей локали ОС. Например, если локаль "ru-RU", то ANSI-кодировкой будет
      Windows-1251, которая поддерживает кириллицу. Также эта используется ОС в качестве 
      кодировки по умолчанию для программ, не поддерживающих Юникод. Не смотря на то, 
      что имеет название идентичное стандарту ANSI, никакого отношения к нему не имеет.
    - OEM-кодировка - подобие ANSI-кодировки, но используется для командной строки.
      Например, локали "ru-RU" соответствует OEM-кодировка CP866.


    ЮНИКОД

    Юникод - стандарт, который включает в себя набор символов и 3 схемы кодирования.

    Юникод включает в себя набор символов, который называется "Стандартизованный набор 
    символов" (Universal Character Set, UCS). Этот набор целиком разбит на диапазон
    целых положительных чисел от 0 до 0x10FFFF. Этот диапазон называется "кодовым 
    пространством Юникода" (Unicode codespace), а сами числа "кодовыми точками" (Code 
    points). Например, U+0067, U+007F, U+1F428. Каждой кодовой точке может быть назначено 
    одно графическое представление, которое называется "абстрактным символом" (Abstract 
    character). Абстрактным символом также считается любой символ из реального мира, 
    который не добавлен в набор символов Юникода, но потенциально мог бы. Кодовые 
    точки 0-127 совпадают с соответствующими кодовыми точками ASCII, а кодовые точки 
    0-255 – с соответствующими кодовыми точками Latin-1. Кодовое пространство Юникода 
    разделено на 17 (0-0x10) "плоскостей" (planes) по 2 ^ 16 (65536) кодовых точек 
    в каждой. 4 правые цифры кодовой точки соответствуют его порядковому номеру 
    в плоскости (0-0xFFFF), а те цифры, которые находятся левее этих четырёх, означают 
    порядковый номер плоскости (0-0x10), именно поэтому кодовое пространство Юникода 
    разбито на диапазон 0-0x10FFFF. Например, кодовая точка U+0067 представляет символ 
    0x0067 из плоскости 0 ("g"), а кодовая точка U+1F428 представляет символ 0xF428 
    из плоскости 0x1 (символ "KOALA"). Самая первая плоскость (plane 0) называется 
    "основной многоязычной плоскостью" (Basic Multilingual Plane, BMP) и содержит 
    в себе большинство основных символов для всех письменностей мира, а также многие 
    исторические и редко используемые символы. На сегодняшний день большинство всех 
    символов Юникода для почти всех текстовых данных можно найти в BMP. Кроме того, 
    кодовое пространство Юникода разделено на 291 "блок" (Block) разного размера, 
    которые можно рассматривать как категории различных символов. 
    Например, 0x0000-0x007F: Basic Latin; 0x0080-0x00FF: Latin-1 Supplement. 
    Текст, который по сути представляет из себя последовательность кодовых точек, 
    для обработки и хранения компьютером преобразуется в последовательность байт.
    Этот процесс выполняют кодировки (Unicode Transformation Format, UTF), которых 
    в стандарте Юникод три. Каждая из них задаёт "кодовую единицу" (Code unit) - 
    минимальное количество бит, которым может быть закодирован один символ текста.

    В 1988 году был опубликован черновик первой версии стандарта Юникод, в которой 
    авторы наивно предполагали, что 16 бит будет достаточно для кодирования кодовых 
    точек, представляющих все возможные языки и прочие символов. В 1991 опубликовали 
    Юникод 1.0, а саму кодировку назвали UCS-2, где "2" означает, что каждая кодовая 
    точка кодируется строго двумя октетами. Это означает, что UCS-2 фактически была 
    кодировкой фиксированной ширины. Очень быстро на Юникод/UCS-2 переключились многие 
    проекты и IT-компании, в том числе и Qt (1992), Windows NT 3.1 (1993) и Java (1995).
    Вскоре выяснилось, что 16 бит на кодовую точку не достаточно, и в 1996 вышел 
    стандарт Юникод 2.0, в котором кодовое пространство было расширено и разбито на 
    17 плоскостей. Кроме того, была введена кодировка UTF-16, полностью совместимая 
    с UCS-2 и исправлявшая её недостатки. Однако, UTF-16 в отличие от UCS-2 не была
    полностью кодировкой фиксированной ширины: строго 16 битами кодировались только
    первые 2 ^ 16 (65536) кодовых точек (BMP), а последующие – суррогатными парами.
    Помимо этого, Юникод 2.0 получил новые механизмы кодирования символов, с которыми 
    могла взаимодействовать UTF-16 и не могла UCS-2.

      1. UTF-8: в этом стандарте используется схема кодирования переменной длины: 
         Первые 127 кодовые позиции (U+0000 - U+007F) кодируются 7 битами в соответствии 
         с ASCII. Для всех остальных кодовых позиций специальный escape-символ 
         заставляет интерпретировать следующие за ним байты для отображения кодовых 
         позиций требующих больше 8 бит для кодирования. Фактически UTF-8 не совместим 
         с Latin-1.
      2. UTF-16 (ранее USC-2): использует 16 бит для кодирования codepoints, что 
         позволяет последовательно закодировать 2 ^ 16 (65536) codepoints, то есть 
         весь Basic Multilingual Plane (BMP). Но UTF-16 также может кодировать и 
         codepoints >65536 с помощью специальной хитрой схемы:
         По стандарту юникод резервирует два интервала codepoints в BMP: 
         - High Surrogates (HS): от U+D800 до U+DB7F
         - Low Surrogates (LS): от U+DC00 до U+DFFF
         И для кодирования codepoints >65536 использует пары codepoints из HS и LS:
         левый элемент пары выражается codepoint из HS, а правый - codepoint из LS: 
         например, U+D800U+DC00. Такие пары называются суррогатными. Как только декодер 
         натыкается на codepoint из HS, он понимает, что имеет дело с суррогатной парой, 
         нужно считать следующий LS-codepoint и декодировать их вместе особым образом.
      3. UTF-32 (ранее UCS-4): просто использует 32 бита (4 байта) для кодирования 
         кодовых позиций, что позволяет выразить 2 ^ 32 (> 4 млдр) кодовых позиций. 
         Эта кодировка удобная для работы со строками в языках программирования 
         в силу своей простоты, но не слишком удобна для хранения текстов, т. к. 
         использует много памяти для кодирования каждого символа.


    BOM

    Для многобайтных кодировок (UTF-16 и UTF-32) важно указать порядок следования 
    байт (Big Endian или Little Endian).
    Есть два варианта как это сделать:
    - Использовать BOM (Byte order mark): в начало текста поместить символ U+FEFF, 
      который не имеет визуального представления. Этот символ даёт понять декодеру, 
      что он сам должен определить порядок следования байт.
    - Если BOM не задействован, то необходимо указывать порядок следования битов 
      в самой кодировке (UTF-16BE/UTF-16LE, UTF-32BE/UTF-32LE)

    ПРИМЕР

    Unicode-символ "снеговик" (U+2603) кодируется в UTF-8 как трехбайтовая 
    последовательность: 0xE2 0x98 0x83, а его эквивалент в UTF-16 является одной 
    16-битной кодовой единицей 0x2603. Unicode-символ "кружка пива" (U+1F37A), 
    находящийся вне BMP, кодируется в UTF-8 как четырехбайтовая последовательность: 
    0xF0 0x9F 0x8D 0xBA, а в UTF-16 использует две 16-битные кодовые единицы-суррогатные 
    пары: 0xD83C 0xDF7A.


    ПЛЮСЫ И МИНУСЫ КОДИРОВОК ЮНИКОДА
    - UTF-8
      + Не зависит от порядка следования байт.
      + При лексикографической сортировке даёт правильный порядок символов.
      + Тратит 8 бит на кодирование ASCII-символов, которые являются наиболее частыми.
      + Совместима с ASCII.
    - UTF-16
      - По сути, костыль для UCS-2, выбор которого был ошибкой проектирования.
      - Зависит от порядка следования байт.
      - Widechar-тип в C++ по стандарту не имеет размера, поэтому для UTF-16 он
        подходит только в Windows-системах, где этот тип имеет 16 бит (в UNIX он
        имеет размер 32 бита). 
      - При лексикографической сортировке даёт неправильный порядок символов.
      - Отдаёт предпочтние в компактности кодирования нескольким блокам азиатских 
        символов, что неэффективно, так как чаще всего в тексте встречаются символы
        ASCII.
      - Часто по ошибке используется как кодировка фиксированной ширины, поэтому как
        только встречаются сурогатные пары, софт интерпретирует их как два разных
        символа, которые даже не имеют представления в наборе символов Юникода.
      - Не совместима с ASCII.
    - UTF-32
      + Наиболее проста в использовании.
      + При лексикографической сортировке даёт правильный порядок символов.
      - Избыточная кодировка, использующая для кодирования каждого символа по 32 бита.
      - Не совместима с ASCII.


    БАЙТЫ И СИМВОЛЫ

    Условно говоря, строки бывают в двух состояниях:
    - Последовательность символов/текст/строка. То есть мы имеем дело с последовательностью 
      незакодированных кодовых точек из таблицы какой-то кодировки. Какой именно кодировке 
      принадлежит эта таблица символов, зависит от интерпретатора языка, компилятора или ОС.
      Например, в Python 3 в качестве набора символов для реализации использует набор 
      сиволов Юникода. Поэтому строковые литералы можно записывать по разному: 
      u"абв" == "абв" == "\u0430\u0431\u0432". Все эти три способа записи являются 
      текстом, то есть последовательностью кодов символов.
    - Последовательность байт. Берётся символ из текста, определяется его код в таблице 
      символов какой-то кодировки. Этот код кодируется кодировкой, и на выходе получается
      один байт или последовательность из нескольких байт. Алгоритм повторяется для
      всех символов строки, и получившиеся байты выстраиваются в одну последовательность.
      Эту последовательность невозможно отобразить в виде текста, так как символы 
      закодированы. Важно знать, какой кодировкой закодирована эта последовательность,
      чтобы можно было правильно произвести процесс декодирования и отобразить символы.

    Пример: в Python 3 текст имеет тип "str" и является неизменяемой последоветльностью 
    кодовых точек из таблицы Юникода. str выглядит так "абв" или так u"абв" (оба варианта
    эквивалентны, но второй является избыточным). Но для того, чтобы компьютер мог
    оперировать этими строками, передавать их или записывать в файл, их нужно закодировать
    в последовательность байт с помощью какой-то кодировки: 
    >>> "абв".encode('utf-8')  # кириллица
    b'\xd0\xb0\xd0\xb1\xd0\xb2'
    На выходе получается последовательность байт. В данном случае, каждая кодовая 
    позиция закодирована двумя байтами.
    Может полуиться и так:
    >>> "abc".encode('utf-8')  # латиница
    b'abc'
    Возникает вопрос: почему Python в предыдущем случае вывел байты в виде экранированных
    шестнадцатеричных значений, а в этом случа - в виде сиволов. Дело в том, что все
    кодировки совместимы с ASCII, которая однозначно определяет коды для 128 символов.
    Поэтому в таблице каждой кодировки первые 128 кодовых точек (0-127) идентичны.
    При этом каждая кодовая точка кодируется 1 байтом, а точнее, 7 битами. Соответственно
    если в получившейся при кодировании последовательности байт есть байты, имеющие
    значение от 0 (0x0) до 127 (0x7f) то их можно однозначно интерпретировать как символы 
    из таблицы ASCII. Те байты, которые имеют значения больше 127, уже не в компетенции
    ASCII – они зависят от кодировки и не могут быть однозначно интерпретированы,
    поэтому Python выводит их в виде \xXX.

    Итак:
    Это текст без кодировок:  u"абв" == "абв" == "\u0430\u0431\u0432"
    Это он закодирован UTF-8: b'\xd0\xb0\xd0\xb1\xd0\xb2'


    СТРОКИ И КОДИРОВКИ В C++

    В начале развития стандарта Юникод в C++ был введён новый тип символа - wchar_t, 
    по определению являющийся целочисленным типом с диапазоном, достаточным для 
    представления всех символов, доступных на данной системе. Так как поначалу 
    предполагалось, что Юникоду хватит 16 бит для представления всех номеров UCS, 
    в некоторых системах (например, Windows) был закреплён 16-битный wchar_t. 
    В современных GNU/Linux-системах используется 32-битный wchar_t, подходящий для 
    кодировки UTF-32. В связи с введением в обиход различных кодировок UTF и отсутствием 
    совместимости между различными системами при использовании wchar_t, в C++11 были 
    добавлены два новых символьных (целочисленных) типа: char16_t для 16-битных кодировок 
    (UCS-2, UTF-16) и char32_t для 32-битных кодировок (UTF-32). Возможно введение 
    в будущем стандарте типа char8_t, пока же для представления единиц кодирования 
    строк в кодировке UTF-8 используется тип char.

    Символьный литерал - один символ в одинарных кавычках: 'a', '2', '+', '\x5c' (hex), '\134' (oct)
    Строковой литерал - строка в двойных кавычках: "hello", "z", "zzzz"

    При записи непосредственно символа в литерал, компилятор может оставить код в той 
    кодировке, в которой символ был введён, либо преобразовать в некоторую кодировку 
    по умолчанию. Например, исходный код может быть набран в кодировке UTF-8, в которой 
    кириллические знаки записываются двухбайтными кодами, но компилятор Visual C++ 
    при оформлении символьного литерала типа char (один байт) преобразует их к 
    кодировке Windows-1251.


    СОВЕТЫ

    - I/O всегда в байтах (utf-8)
    - Файлы всегда читать и писать в binary mode
    - Концы строк на всех платформах обозначать через \n, и писать в файл в binary mode
    - Всегда использовать #define UNICODE и #define _UNICODE или Project Preferences ->
      -> General -> Use Unicode Character Set -> Yes, чтобы компилятор выдавал ошибку
      там, где Windows API-функция ожидает ANSI-строку, а мы ей пытаемся передать 
      обычную utf-8 char* строку. В этих местах нужно использовать функции явного 
      преобразования типов строк narrow() / widen().
    - Избегать fopen() из соображений RAII/OOD. Если необходимо, использовать _wfopen().
      ? http://utf8everywhere.org/#how.files
    - Всегда использовать char*/std::string для всех строк внутри программы
    - Строковой литерал в utf-8 можно записать следующими способами:
      - В виде С++11 utf-8 литерала: u8"Хай!"
        В этом случае независимо от кодировки ОС и компилятора, литерал будет в UTF-8.
      - В виде последовательности байтов: "\xd0\xa5\xd0\xb0\xd0\xb9!"
      - Просто записать литерал в виде строки и сохранить в utf-8: "Хай!"
        В этом случае кодировку литерала определяет компилятор вместе с ОС. Например,
        компилятор MSVC сконвертирует эту строку в какую-то кодовую страницу ANSI, 
        и тем самым повредит строку. В этом случае, нужно сохранить файл исходника 
        в utf-8 без BOM. Это решит проблему, но так же сделает невозможным использование 
        Юникодовых идентификаторов \uXXXX и wchar_t-литералов L"". Но эти вещи и 
        не нужны.

    ----------------------------------

    - #include <cstring> для использования функций strlen, strcpy, strcat и тд. для строк char[]
    - #include <string> для использования std::string
    - С объектом cout имя char-массива, указатель на char и строковая константа интерпретируются как адрес первого символа строки
    - В строках, хранимых в char[] нельзя забывать про нулевой символ
    - string:
    - можно инициализировать с помощью char[]-строк
    - string можно соединять через +
    - к отдельным символам можно обращаться через индекс, как у массивов
    - длина строки: str.size()
    - Указатели в строках:
    char text[]{ "Hello" };
    const char *text{ "Hello" };
    char *text = new char[6];
    - Кодировка: utf-8  / Тип: char (1 байт/8 бит)        / Литерал: u8""  // char* utf8String = u8"С Новым Годом!";
    Кодировка: utf-16 / Тип: char16_t (2 байта/16 бит)  / Литерал: u""   // char16_t* utf16String = u"С Новым Годом!";
    Кодировка: utf-32 / Тип: char32_t (4 байта/32 бита) / Литерал: U""   // char32_t* utf32String = U"С Новым Годом!";

    std::string    == typedef basic_string<char> string;          // C++98; тип строки: string;    одна кодовая позиция выражается типом: char      // Подходит для utf-8
    std::wstring   == typedef basic_string<wchar_t> wstring;      // C++98; тип строки: wstring;   одна кодовая позиция выражается типом: wchar_t   // Подходит для utf-16 в Windows
    std::u16string == typedef basic_string<char16_t> u16string;   // C++11; тип строки: u16string; одна кодовая позиция выражается типом: char16_t
    std::u32string == typedef basic_string<char32_t> u32string;   // C++11; тип строки: u32string; одна кодовая позиция выражается типом: char32_t

      "text"     char *                                                                                    C90
      "text"s    std::string s                                                                             C++98
    u8"text"     char *                        std::string    (typedef basic_string<char> string)          C++98
     L"text"     wchar_t  *    wchar_t  s[]    std::wstring   (typedef basic_string<wchar_t> wstring)      C++98
     u"text"     char16_t *    char16_t s[]    std::u16string (typedef basic_string<char16_t> u16string)   C++11
     U"text"     char32_t *    char16_t s[]    std::u32string (typedef basic_string<char32_t> u32string)   C++11
     R"te\xt"    

     !!! char, wchar_t, char16_t, char32_t HOLD VALUES OF CODE UNITS

    * Для wchar_t стандарт не определяет размер, поэтому в компиляторе VS sizeof(wchar_t) == 2, а в GCC sizeof(wchar_t) == 4,
      поэтому std::wstring / wchar_t подходит для utf-16 только в Windows, и использование этого типа для представления utf-16
      делает код не кросс-платформенным. Для Windows API родной кодировкой является UTF-16, поэтому std::wstring / wchar_t идеально
      подходит для кода, специфичного для Windows.

    - R"(This string is "raw" string)";
    - Префикс R скомбинированный с другими префиксами

    std::basic_string<T> - шаблонный класс похожий на контейнер, который позволяет 
    создать строку, каждый символ в которой будет представлен типом T (любой POD-тип).

    На кодировки влияют:
    - Кодировка файла исходного кода
    - Особенности различных компиляторов
    - BOM

    * Что такое ANSI
    * Что такое BOM
    * рассмотреть все префиксы и суффиксы https://blogs.msmvps.com/gdicanio/2018/05/28/how-many-strings-does-c-have/
    * рассмотреть конвертеры кодировок
    * как BOM вляет на исходники
    * почему не важен порядок байт в UTF-8 -> UTF-8 has no endianness issues, and the UTF-8 BOM exists only to manifest that this is a UTF-8 stream.
    * различия между символьными и строковыми литералами и как они соотносятся
    * разница между типами byte и "текст", как это реализовано в Python 2 и 3
    * отличие мультибайтовых строк от широких
    * narrow() / widen() (http://utf8everywhere.org/#windows)

    * Посмотреть реализацию строк в проектах:
      - Unreal Engine: 
        Runtime\Core\Private\Containers\String.cpp, 
        Runtime\Core\Public\Containers\UnrealString.h, 
        Runtime\Core\Public\Containers\StringConv.h
      - Qt:
        utils\unicode\*
        src\corelib\tools\qchar.cpp
        src\corelib\tools\qstring.cpp

    Статьи:
    - https://habr.com/post/257895/
      - Экскурс в историю кодировок
      - Об ICU (ICU4C) и iconv

    Если посмотреть на Python 3 в сравнении с Python 2, то третья версия совершила по-настоящему серьезный скачок в развитии, разделив эти два понятия. Крайне рекомендую даже опытному C/C++ разработчику поработать немного в Python 3, чтобы ощутить всю глубину, с которой произошло разделение текста и байтов на уровне языка в Python. Фактически текст в Python 3 отделен от понятия кодировки, что для разработчика C/C++ звучит крайне непривычно, строки в Python 3 отображаются одинаково в любой точке мира, и если мы хотим работать с представлением этой строки в какой-либо кодировке, то придется преобразовать текст в набор байтов, с указанием кодировки. При этом внутреннее представление объекта типа str, по сути, не так важно, как понимание, что внутреннее представление сохранено в Юникоде и готово к преобразованию в любую кодировку, но уже в виде набора байтов типа bytes.

    Как в проектах реализованы строки
    - Banshee Game Engine: String - обёрнутая string для ASCII, WString - обёрнутая wstring для Unicode
    - Unigine 2010: char
    - Unreal Engine 4: макрос TEXT: L"String"s, FString


    // -------------------------------------
    // УСТРОЙСТВО ПАМЯТИ И УКАЗАТЕЛИ
    // -------------------------------------

    // Ссылки:
    // https://rsdn.org/article/cpp/ObjectsAndPointers.xml
    // https://www.wikiwand.com/ru/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8

    Адрес памяти - адрес байта.
    Адресное пространство - непрерывный диапазон ячеек, доступный для адресации в конкретной операционной системе.
    Адресное пространство можно представить ввиде упорядоченных вертикально ячеек, адресованных снизу вверх.

    Оперативная память делится на 4 типа:
    - Статическое хранилище - выделяется при запуске программы до вызова функции main, а освобождается после завершения работы функции main (на стадии завершения всей программы).
      Этот вид памяти используется для хранения ГЛОБАЛЬНЫХ и статических (static) объектов, констант и объектов, определённых в пространствах имён.
      Статической памятью управляет компилятор.
      Объекты в этой области памяти живут на протяжении всего времени работы ПРОГРАММЫ.
    - Автоматическое хранилище - располагается в стеке; этот вид памяти выделяется и освобождается на тех же стадиях, что и статическая, но используется для хранения ЛОКАЛЬНЫХ объектов.
      Стек работает по принципу LIFO. Стек определяется двумя указателями: первый указывает на начало стека и не сдвигается во время выполнения программы (?). 
      Второй - указывает на вершину стека. У каждой программы свой стек. Размер стека всегда ограничен. Для программ, разработанных в Visual Studio ограничение составляет 1 Мб.
      Обычно говорят, что стек растёт вверх в соответствии с увеличением адресов памяти.
      Но на архитектуре x86 стек растёт вниз - в сторону уменьшеня адресов памяти.
      Стеком управляет компилятор.
      Объекты в этой области памяти живут на протяжении всего времени работы ФУНКЦИИ.
    - Динамическое хранилище - располагается в куче; многократно выделяется и освобождается на протяжении всей работы программы.
      В C++ место в динамической памяти выделяет оператор new, освобождает оператор delete, а доступ к выделенным областям осуществляют указатели (*) и ссылки (&).
      ! Оператор delete освобождает динамически выделенную память, на которую указывает указатель, а не удаляет указатель.
      При выделении памяти отыскивается ближайшая подходящая по размеру область.
      Динамической памятью управляет программист.
      Объекты в этой области памяти живут с new до delete.
    - Хранилище потока - ?

    Примечания:
    - Объект, на который указывает указатель, может находиться как в любой из трёх областей памяти. Но сам указатель находится в стеке.
    - Оператор delete освобождает динамически выделенную память, на которую указывает указатель, а не удаляет указатель.
      После этой операции указатель становится "недействительным" - продолжает указывать на ту область, которая уже не пренадлежит программе.
      Если есть желание переиспользовать указатель после delete, лучше явно указать, что этот указатель больше ни на что не указывает (p = nullptr) (после delete).

    Указатель, созданный локально в функции, уничтожается при выходе из функции, т. к. он хранился в стеке. 

    Регион > область > блок памяти - непрерывные последовательности ячеек памяти.

    // --------------------------

    УКАЗАТЕЛИ

    // Темы:
    // - Указатели на stack-память
    // - Указатели на heap-память
    // - Указатели без инициализации
    // - Указатели со всеми видами инициализации
    // - Указатели на примитивные типы
    // - Указатели на массивы
    // - разница между указаталем на первый элемент массива и на весь массив
    // - Указатели на строки
    // - Многомерные массивы указателей на простые и сложные типы
    // - Освобождение памяти многомерных массивов и строк
    // - Арифметика указателей
    // - Указатели на (строковые) константы и константные указатели
    // - Указатели в качестве элементов списка инициализации
    // - Поведение массивов и строк в выражениях, и с cout/cin
    // - Как указатели на разные типы интерпретируются в разных ситуациях
    // - Указатели на функции

    - Указатель - переменная, хранимая в стеке, указывающая на данные, расположенные в стеке или в куче.
    - Прямое значение указателя - адрес
      Косвенное значение указателя - начение в памяти
    - Объявление указателя легче читать справа налево
    - Имя массива является указателем
    - Имя функции является указателем
    - Разыменовывание нулевого указателя приводит к неопределённому поведению
    - <type> const == const <type>
    - Указатель типа const <type>* может указывать как на константу, так и на переменную

    int num = 5;       // Обычная переменная

    // Создание указателя с инициализацией и без
    int *p;                  // Создание указателя на данные типа int; без инициализации
    int *p = &num;           // Создание указателя на данные типа int; указатель указывает на переменную num, хранимую в стеке
    int *p = new int;        // Создание указателя на данные типа int; указатель указывает на выделенную heap-память типа int, в которой хранится мусор
    int *p = new int{ 10 };  // Создание указателя на данные типа int; указатель указывает на выделенную heap-память типа int, в которой хранится число 10

    // Присваивание нового значения указателю
    p = &num;          // Теперь указатель укаызвает на переменную num, которая хранится в стеке
    p = new int;       // Создание указателя на данные типа int; указатель указывает на выделенную heap-память типа int, в которой хранится мусор
    p = new int{ 10 }; // Теперь указатель укаызвает на данные типа int, расположенные в куче

    // Указатель на указатель
    int *p = &num;                     // Указатель на переменную
    int **pp = &p;                     // Указатель на указатель на переменную
    int ***ppp = &pp;                  // Указатель на указатель на указатель на переменную
    *p == **pp == ***ppp == num == 5   // Разыменовывание указателей

    // Указатель на функцию
    int func (int, int);            // Прототип функции
    int (*pFunc)(int, int) = func;  // Указатель на эту функцию

    // ПРИМЕРЫ
    int *const p;                       // указатель-константа
    const int *p;                       // указатель на константу
    const int *const p;                 // указатель-константа на константу
    int const *const p;                 // указатель-константа на константу (то же самое, что и предыдущий пример)
    const int *const * *const * * * x;  // указатель на указатель на указатель на константный указатель на указатель на константный указатель на int-константу


    // ----------------

    // Базовое использование
    int *p;              // указатель на переменную типа int
    int *const p;        // указатель-константа на переменную типа int, ему нельзя присвоить другой адрес
    const int *p;        // указатель на константу типа int
    const int *const p;  // указатель-константа на константу типа int

    // Использование с выделением памяти
    int *p = new int;       // выделение памяти в куче посредством оператора new и присваивание адреса указателю p
    int *p = new int{ 5 };  // то же самое, только с иициализацией
    *p = 10;                // присваивание нового значения указателю
    delete p;               // ! освобождает память, выделенную оператором new, а не удаляет указатель. Указатель продолжает указывать на тот же адрес.
    int *p = new int[100];  // выделение памяти для массива из 100 элементов типа int
    delete []p;             // освобождение памяти из-под массива

    int *p;
    p = (int *)0xB8000000;  // присваивание указателю нового адреса
    *p = 200;               // записать значение 200 в область памяти, на которую указывает указатель


    int *pYears = new int[3]{ 2000, 2010, 2020 };
    sizeof(nums)    // 12 (размер массива в байтах)
    sizeof(pYears)  // 4  (размер указателя на int)


    int nums[]{ 10, 20, 30 };                       // статическое (раннее) связывание
    int *pYears = new int[3]{ 2000, 2010, 2020 };   // динамическое (позднее) связывание; при создании массива через оператор new обязательно указывать кол-во элементов массива в [] скобках

    nums[0] или *nums        // доступ к 0-му элементу обычного массива
    nums[1] или *(nums + 1)  // доступ к 1-му элементу обычного массива

    pYears[0]      // 2000
    *pYears        // 2000
    *(++pYears)    // 2010 (так указатель лучше не изменять, потому что delete [] pYears будет работать некорректно)
    *(pYears + 1)  // 2020 (а вот так нормально)

    pYears = nums;       // так можно заставить указатель указывать на массив
    pYears = &nums[0];   // а можно и так

    // Важно:
    &nums[0] и &nums - один и тот же адрес, но &nums[0] - адрес 0-ого элемента массива, а &nums - адрес всего массива
    int *pNums1 = nums;        // pNums указывает на первый элемент массива nums
    int (*pNums2)[3] = &nums;  // pNums указывает на массив из 3 элементов

    int (*p)[3] = &nums;  // p - указатель на массив из трёх элементов int
    int *p[3]             // p - массив из трёх указателей на int

    // -------------------------------------
    // -------------------------------------
    // -------------------------------------

    Заметки:

    - Списковая инициализация через {} (стиль С++11) имеет следующие особенности
      - Не допускает сужения
      - Пустые скобки инициализируют переменную нулём
    - Чтение из консоли (cin, .get(), .getline(), getline(), .clear()): 
      // с. 142-146, 151-152, 240-249, глава 6
      - cin >> <var> - читает строку до первого пробельного символа или до тех пор, 
        пока ввод подходит под тип переменной. Если <var> - числовая переменная, то
        пробельный символ остаётся в очереди, а если <var> - строка, то пробельный 
        символ отбрасывается. Если <var> - char, то пробелы и символы новой строки 
        из очереди ввода просто выбрасывает и не записывает в <var>. Не следит 
        за количеством введённых символов, поэтому может переполнить переменную <var>.
      - cin.get(<var>[, <length>]) - считывает строку вплоть до символа новой строки, 
        (а не до пробельного символа, как cin >>), но не более <length> - 1 (1 место
        оставляет для символа конца строки). Не считывает из потока ввода конец строки,
        а оставляет его там. Если была считана пустая строка, то ставит флаг failbit
        и запрещает дальнейший ввод. Чтобы разблокировать ввод, нужно использовать 
        метод cin.clear(), который обнуляет этот флаг. В отличие от cin.getline() 
        позволяет проверить, был ли ввод считан полностью (по наличию символа новой 
        строки в очереди ввода). Если метод натыкается на EOF, то cin при приведении
        к типу bool превратится в false.
        EOF из iostream.
      - cin.get() - читает один любой символ (даже символ конца строки) и возвращает
        его. Если метод натыкается на EOF в очереди ввода, то возвращает константу 
        EOF из iostream.
      - cin.getline(<var>, <length>) - считывает строку вплоть до символа новой строки, 
        (а не до пробельного символа, как cin >>), но не более <length> - 1 (1 место
        оставляет для символа конца строки). Сам символ новой строки тоже считывает 
        и отбрасывает. Если ввод не был считан полностью по причине нехватки места
        в переменной, то устанавливает флаг failbit.
      - cin.clear() - сбрасывает флаги failbit и eofbit и позволяет вводить данные 
        снова.
      - getline(cin, <var>) - считывает в строку типа std::string. Аргумент <length>
        отсутствует, потому что std::string-строки автоматически подстраиваются под 
        размер ввода.

      Здесь:
      - <var> - переменная, в которую нужно записать ввод.
      - <length> - максимальная длина считывания

      Примечания:
      - Все разновидности методов cin.get() и cin.getline() появились задолго 
        до введения string-строк, поэтому эти методы не умели работать с такими строкми, 
        чтобы исправить проблему, была введена функция getline(), которая для совместимости 
        используется внутри cin.getline().
      - Методы cin.get() и cin.getline() возвращают объект cin, что позволяет использовать 
        цепной вызов. Можно комбинировать вызовы так: (cin >> i).get()
      - Когда cin обнаруживает EOF, то устанавливает два флага: failbit и eofbit.
        Проверить, установлены ли эти флаги, можно с помощью методов cin.fail() и cin.eof()
        соответственно. 
      - cin преобразуется в bool-значение, когда используется в выражении, ожидающем
        именно этот тип. Принимает значение true, когда последняя попытка чтения была 
        успешной и false - в противном случае. Пример: while (cin) { ... }


    - Массивы и указатели:  
      int nums[]{ 10, 20, 30 };                       // статическое (раннее) связывание
      int *pYears = new int[3]{ 2000, 2010, 2020 };   // динамическое (позднее) связывание; при создании массива через оператор new обязательно указывать кол-во элементов массива в [] скобках

      nums[0] или *nums        // доступ к 0-му элементу обычного массива
      nums[1] или *(nums + 1)  // доступ к 1-му элементу обычного массива

      pYears[0]      // 2000
      *pYears        // 2000
      *(++pYears)    // 2010 (так указатель лучше не изменять, потому что delete [] pYears будет работать некорректно)
      *(pYears + 1)  // 2020 (а вот так нормально)
      
      pYears = nums;       // так можно заставить указатель указывать на массив
      pYears = &nums[0];   // а можно и так

      // Важно:
      &nums[0] и &nums - один и тот же адрес, но &nums[0] - адрес 0-ого элемента массива, а &nums - адрес всего массива
      int *pNums1 = nums;        // pNums указывает на первый элемент массива nums
      int (*pNums2)[3] = &nums;  // pNums указывает на массив из 3 элементов

      int (*p)[3] = &nums;  // p - указатель на массив из трёх элементов int
      int *p[3]             // p - массив из трёх указателей на int

      // Двумерный массив
      int matrix[2][4]{
        {1, 2, 3, 4},
        {5, 6, 7, 8}
      };

      // массив указателей на 2 строки
      const char *cities[2] {
        "Moscow",
        "St. Petersburg"
      };

    - Структуры:
      - Варианты синтаксиса:
        // Обычная структура с двумя полями
        struct Tax {
          int amount;
          char currency[3];
        };

        Tax customTax = { 10, "USD" }; // переменная типа Tax
        Tax customTax { 10, "USD" };   // C++11
        Tax customTax {};              // C++11, инициализация каждого поля нулемыми значениями

        cout << customTax.amount << customTax.currency;  // обращение к полям структуры 

        // Можно присваивать одну структура данно типа другой структуре того же типа
        // В этом случае присваиваются отдельные поля.
        Tax smallTax = { 1, "USD" };
        customTax = smallTax;

        // Можно создать переменные во время объявления структуры
        struct Tax {
          int amount;
          char currency[4];
        } customTax, smallTax;

        // ... с инициализацией
        struct Tax {
          int amount;
          char currency[3];
        } customTax { 10, "USD" }, smallTax { 1, "USD" };

        // Структура может быть анонимной в случае одновременного создания переменной
        struct {
          int amount;
          char currency[3];
        } customTax;

        // Массив структур
        Tax taxes[]{
          { 10, "USD" },
          { 610, "RUB" }
        };

        // Можно определить размер члена структуры с помощью битовых полей (только для целочисленных членов int, enum и bool)
        // Это может пондобиться для выравнивания по размеру регистра для увеличения производительности
        struct Tax {
          int amount : 4;        // 4 бита
          bool isRequired : 1;   // 1 бит
          Сurrency сurrency : 4; // 4 бита (Сurrency - enum)
        };

        // Указатели на структуру
        Tax *pCustomTax = new Tax{ 10, "USD" };
        pCustomTax->amount;    // доступ к члену структуры по указателю
        (*pCustomTax).amount;  // доступ к члену структуры по разыменованному указателю

    - Объединения (union):
      - В один момент времени хранит значение только одного поля
      - Работаю те же трюки инициализации и объявления, что и со структурами

      union Offer {
        char id_str[16];
        unsigned int id_num;
      };

      Offer offer2018_58;
      offer2018_58.id_str = "custom_id";  // сечайс хранится в id_str
      offer2018_58.id_num = 50;           // а сечайс хранится в id_num

      // Структура + анонимное объединение
      struct Tax {
        int amount;
        union {
          char currency_str[3];
          Сurrency сurrency_enum;
        }
      } customTax;

      customTax.currency_str = "USD";
      customTax.сurrency_enum = USD;

    Указатели и выделение памяти:
      - new (выделяет память в куче) и delete (освобождает память в куче) используются в паре
      - антипаттерн: new в одной функции, а delete - в другой
      - нельзя многократно освобождать одну и ту же память с помощью delete. Результат будет неопределён.
      - указатель на массив фиктически указывает на первый элемент массива
      - нельзя узнать размер массива через sizeof, созданного с помощью new
      - для доступа к элементам динамического массива можно использовать сам указтель со скобками: p[i], где p - указатель на массив, а i - индекс элемента
      - у указателей на массивы есть арифметика:
        - p + 1 - сдвигает начало массива на 1 вправо, а p - 1 на один влево (при таком сдвиге delete[] будет работать не корректно)
        - 




      // Базовое использование
      int *p;              // указатель на переменную типа int
      int *const p;        // указатель-константа на переменную типа int, ему нельзя присвоить другой адрес
      const int *p;        // указатель на константу типа int
      const int *const p;  // указатель-константа на константу типа int

      // Использование с выделением памяти
      int *p = new int;       // выделение памяти в куче посредством оператора new и присваивание адреса указателю p
      int *p = new int{ 5 };  // то же самое, только с иициализацией
      *p = 10;                // присваивание нового значения указателю
      delete p;               // ! освобождает память, выделенную оператором new, а не удаляет указатель. Указатель продолжает указывать на тот же адрес.
      int *p = new int[100];  // выделение памяти для массива из 100 элементов типа int
      delete []p;             // освобождение памяти из-под массива

      int *p;
      p = (int *)0xB8000000;  // присваивание указателю нового адреса
      *p = 200;               // записать значение 200 в область памяти, на которую указывает указатель
    Циклы:
      for (<type> x : <container>) {}  // C++11; цикл, который перебирает с помощью переменной x все элементы контейнера <container> типа <type>



    // -------------------------------------

    Объявление, инициализация и обращение к переменным:

    Инициализация приминтивных типов:
    int num = 5;      // стек, стиль С
    int num(5);       // стек, стиль C++
    int num = { 5 };  // стек, стиль С++11  | если оставить скобки пустыми, то переменная инициализируется 0
    int num{ 5 };     // стек, стиль С++11  |

    Инициализация строк:
    char char_str[] = { "Stringo" };
    char char_str[]{ "Stringo" };
    string string_str = { "Stringo" };
    string string_str{ "Stringo" };

    // -------------------------------------

    >>> ПРЕОБРАЗОВАНИЯ ТИПОВ 120
    >>> СТРОКИ 136 / СТЕНИЕ ВВОДА СТРОК 141
    >>> Vector & Array 196
    >>> ЧТЕНИЕ ФАЙЛА 287-297 

    // -------------------------------------

    #include <iostream>

    // Константа, хранимая в статической области памяти
    const int GLOB_CONST = 5;

    int main () {
        // Переменная, хранимая в автоматической области памяти (в стеке)
        int num = 5;
        
        // Указатели
        const int *pGC = &GLOB_CONST;  // указывает на константу в статической области памяти
        int *pNum = &num;              // указывает на переменную в автоматической области памяти (в стеке)
        int *pLevel = new int{ 10 };   // указывает на переменную в динамической области памяти (в куче) 

        std::cout << *pGC << " " << *pNum << " " << *pLevel << std::endl;

        // delete pGC;    // нельзя применять delete для указателей, которые указывают на объекты в статической области памяти 
        // delete pNum;   // нельзя применять delete для указателей, которые указывают на объекты в автоматической области памяти (в стеке)
        delete pLevel;    // необходимо применять delete для указателей, которые указывают на объекты в динамической области памяти (в куче) 

        return 0;
    }

    // -------------------------------------
    // -------------------------------------
    // -------------------------------------



    Варианты инициализации переменной:
    - int var = 5;
    - int var = { 5 };
    - int var{ 5 };
    Фигурные скобки можно оставить пустыми, тогда переменная будет инициализирована 0.

    Компьютер наиболее эффективно работает с типом int.

    Системы счисления, в которых C++ позволяет записывать целочисленные литералы:
    - oct: 042 (если чсло начинается с 0 и не имеет цифр больше 7)
    - hex: 0x162f
    - dec: 10
    В std есть соответствующие манипуляторы oct, hex и dec, которые позволяют выводить числа в нужной СС.

    При объявлении целочисленных литералов можно указать суффиксы:
    - l/L - long
    - u/U - unsigned int
    - ul/lu/UL/LU - unsigned long
    - ll/LL - long long
    - ull/ULL - unsigned long long

    При объявлении целочисленных литералов язык подбирает тип, которого достаточно для хранения литерала:
    - dec: int, long, long long
    - hex: int, long, unsigned long, long long, unsigned long long (unsigned - потому что hex-числа часто используются для адресов памяти, которые не могут быть отрицательными)

    -------------------------------

    Указатель хранит адрес значения.

    * – "косвенное значение" или "операция разыменовывания".

    -------------------------------
    Модификаторы доступа:
    - public
    - private
    - protected

    Ключевые слова:
    - auto - имеет новое значение с C++11: автоматически выводит тип переменной
    - friend - ключевое слово для функций, которое даёт функции те же права доступа к членам класса, что и функции-члены этого класса
    - explicit - ключевое слово для функций, запрещающее неявное преобразование типов аргументов

    CV-квалификаторы (C - const, V - volatile): 
    - const - делает переменную константой.
    - volatile - по-умолчанию значение переменных кэшируется в регистре ЦП между двумя использованиями для оптимизации (чтобы не обращаться к памяти каждый раз). Но если мы знаем, что значение в ячейке пямяти может измениться независимо от нашей программы, можно отменить кэширование этим квалификатором.

    Спецификаторы:
    - constexpr - помогает рассчитать значение выражения на этапе компиляции.

    Спецификаторы класса хранения:
    - auto (был спецификатором, сейчас исключён) - в ранних версиях C/C++ насильно делал переменную автоматический. В новых версиях С++ исключён из спецификаторов и имеет другое назначение.
    - register - в ранних версиях C/C++ заставлял хранить переменную в регистре ЦП для скорости. Сейчас он эквивалентен auto.
    - static - делает переменную статической (внутри блоков) или назначает внутреннее связываение глобальным переменным (объявленным вне блоков).
    - extern - указывает на ссылочное объявление. Для переменных, которые видны во всех файлах программы.
    - thread_local - переменная существует только на протяжении существования потока.
    - mutable - разрешает изменять отдельные члены структурной контстантной переменной, каторая имеет тип "const <имя_структуры>"
    В одном объявлении можно использовать только один спецификатор.
    Исключение: thread_local можно использовать вместе со static или extern.

    Знаковость:
    - unsigned - беззнаковая переменная
    - signed - знаковая переменная
    -------------------------------


    Пример:
    pointer – указатель и хранит адрес значения.
    Тогда *pointer – значение по адресу pointer.


    Пример 2:
    variable — простая переменная.
    pointer – указатель на адрес значения переменной variable.
    Тогда:
    – pointer == &variable == адрес значения в памяти;
    – *pointer = variable == значение в памяти по адресу pointer.


    Объявление указателя:
    <type> *<pointer_name>;
    Здесь:
    – <type> – тип значения, хранимого по адресу памяти;
    – <pointer_name> указывает на тип <type>;
    – *<pointer_name> является значением типа <type>;
    – <type> * – тип "указатель на int".


    Схема того, как работает указатель на простую переменную:

           duck              |-------------|  *birddog
        |------->  0xfbaf90  |          12 | <----------|
        |                    |-------------|            |
        |          0xfbaf91  |             |            |
        |                    |-------------|            |
        |          0xfbaf92  |             |            |
        |                    |-------------|   birddog  |
        |          0xfbaf93  |    0xfbaf90 | <----------|
        |                    |-------------|            |
        |          0xfbaf94  |             |            |
        |                    |-------------|            |
        |                                               |
    int duck = 12;                          int *birddog = &duck;


    Адрес, хранимый в указателе, обычно, имеет размер 2-4 байта.

    -----------------------------------------------------
    | Перед тем, как использовать указатель, необходимо |
    | сохранить в указателе адрес памяти!               |
    -----------------------------------------------------

    --------------------------------------------------------
    | <type> * — совершенно самостоятельный тип данных.    |
    | Поэтому, не смотря на то, что визуально адрес памяти |
    | напоминает целое число, указателю нельзя присваивать |
    | целые числа. Сначала необходимо явно преобразовать в |
    | целочисленный тип в тип "указатель на <type>" сле-   |
    | дующим образом: <type> *p = (<type> *) 0x50fa19df    |
    --------------------------------------------------------


    Пример указателя на целочисленный массив:
    int *p = new int[3] { 5, 10, 15 };
    Получить n-ный элемент массива можно 2 способами:
    – p[n]
    – *(p + n)


    ----------------------------------------------------------
    | Имя массива - адрес первого элемента этого массива.    |
    | Поэтому, если создать переменную-массив, то адрес этой |
    | переменной  можно получить без применения операции &.  |
    | int ary = new int[3] {1, 2, 3};                        |
    | int *ap = ary; (БЕЗ &) (или &ary[0])                   |
    ----------------------------------------------------------

    ВАЖНО!
    char-строка, как и массив числового типа, возвращает аресс первой буквы

    Объявление указателей на разные типы:
    int *pa = new int{3};
    short *pb = new sort[3] {5, 16, 80};
    char 9pc = new 

    Как работает:
    int *pa = new int[40];             // так пишем
    int *pa = new(40 * sizeof(int));   // так работает

    ------------------------

    cin >> char       - не принимает пробельные символы. Возвращает cin.
    char = cin.get()  - возвращает введённый символ или константу EOF, если конец файла/ввода (cin.get без аругментов может возвращать беззнаковый char и не получится провериь на конец строки (EOF), поэтому принимать нужно в int)
    cin.get(char)     - принимает все символы. Возвращает cin. Преобразуется в true/false при использовании в логич. выражениях
    В языке С:
    cin.get() == getchar(), но getchar сохраняет код символа в int, а cin.get в char;
    cout.put(char) == putchar(int)
    getchar и putchar находятся в cstdio (stdio.h)


    Vector & array
    Функции
    Встроенные функции
    Прототипы функций
    Шаблоны функций
    ---------------------------------------
    Прототип нешаблонной функции:
    void swap (job &a, job &b);
    ---------------------------------------
    Прототип шаблона с произвольным типом:
    template <typename T>
    void swap (T &a, T &b);
    ---------------------------------------
    Шаблон функции с произвольным типом:
    template <typename T>
    void swap (T &a, T &b)
    {
        
    }
    ---------------------------------------
    Явная специализация для типа job:
    template <> void swap<job>(job &, job &);
    или
    template <> void swap(job &, job &);
    * <job> можно опустить, т. к. специализация функции определяется по типу принимаемых значений
    ---------------------------------------
    Явное создание экземпляра (в данном случае для типа <int>):
    template void swap<int>(int, int);
    ---------------------------------------
    !!! Не путать явную СПЕЦИАЛИЗАЦИЮ и явное создание ЭКЗЕМПЛЯРА !!!
    ---------------------------------------
    Указание типа при вызове шаблонной функции:
    template <typename T>
    void swap (T &a, T &b)
    {
        
    }

    double x = 5, y = 10;
    swap<double>(x, y);   // <===========
    ---------------------------------------


    ----------------------------
    decltype(x) y;    // создаёт переменную "y" с тем же типом, что и "x"
    auto swap (T1 x, T2 y) -> decltype(x);    // определение типа, возвращаемого функцией через decltype
    ----------------------------
    typedef
    ----------------------------
    inline
    ----------------------------

    ----------------------------
    В заголовочные файлы стоит включать следующее:
    - Прототипы функций
    - Символические константы, определённые через define или const
    - Объявления структур
    - Объявления классов
    - Объявления шаблонов
    ----------------------------
    4 хранилища дынных в памяти:
    - Автоматическое (для переменных, созданных внутри функции)
    - Статическое (для переменных, созданных за пределами функций или с модификатором static)
    - Потоковое (переменные, созданные с модификатором thred_local, существуют только на протящении существования потока)
    - Динамическое (здесь хранятся переменные, создаваемые через new)
    ----------------------------
    Доступ к глобальной переменной:
    int myvar = 5;
    void funct () {
        int myvar = 10;

        myvar;    // доступ к локальной перемнной
        ::myvar;  // доступ к глобальной переменной
    }
    ----------------------------
    // file1.cpp
    int myvar = 5;

    // file2.cpp
    static int myvar = 10;
    // Далее везде используется myvar из этого файла (ile2.cpp)

    Здесь myvar из file1.cpp не конфликтует с одноимённой переменной в file2.cpp,
    так как в file2.cpp используется статическая переменная myvar;
    -----------------------------
    Желательно вместо статических глобальных переменных использовать переменные в namespace
    -----------------------------

    -----------------------------
    using Namespace::varname   - объявление using
    using namespace Namespace  - директива using
    -----------------------------

    -----------------------------
    ОШИБКА, т. к. Small, Medium, Large находсятся в одной глобальной области видимости:
    enum egg {Small, Medium, Large}
    enum tshirt {Small, Medium, Large}

    Ключевое слово class устанавливает индивидуальную область видимости для перечисления:
    enum class egg {Small, Medium, Large}
    enum class tshirt {Small, Medium, Large}

    <int_type> - целочисленный тип для числового представления элементов перечисления:
    enum class : <int_type> egg {Small, Medium, Large}
    enum class : <int_type> tshirt {Small, Medium, Large}
    -----------------------------

    -----------------------------
    Создание класса:

    class ClassName {

    private:                                             // Если не указывать этот модификатор для секции, то все свойства и методы в этой секции по умолчанию private
        int private_var;
        void private_func_proto();
        static const int const_var = 5;                  // Создать константу внутри класса можно только с помощью ключевого слова static, но при этом она будет общей для всех объектов, созданных из этого класса
    public:                                              // Публичные свойства и методы
        ClassName();                                     // Конструктор по умолчанию
        ClassName(const ClassName &);                    // Конструктор копирования
        ClassName(int a);                                // Конструктор #3. Конструктор с одним аргументом (или с несколькими, где все кроме первого имеют значения по умолчанию) преобразует присваеваемое значение в тип класса
        ClassName(int a, int b);                         // Конструктор #4
        ~ClassName();                                    // Деструктор

        int public_var;
        void public_func_proto();

        ClassName operator+(const ClassName &t) const;          // Перегрузка операции сложения (+) через функцию-член
        friend ClassName operator+(const ClassName &t) const;   // Перегрузка операции сложения (+) через функцию-друга

        operator double() {                                     // Функция для преобразования объекта в другой тип (в данном случае в double)
            return double(private_var);
        }

        explicit operator int() const;                          // Прототип функции ЯВНОГО преобразования из ClassName в int
    }

    ClassName::operator int() const {                           // Функция ЯВНОГО преобразования из ClassName в int
        // ...
    }

    // Функция-друг для класса ClassName, которая перегружает операцию сложения переменных этого класса
    // Имеет те же права, что и функция-член класса
    // Её прототип указывается внутри целевого класса, а не отдельно
    ClassName operator+(const ClassName &t, const ClassName &t2) const {
        
    }
    -----------------------------
    [inline] <type> <class_name>::<method_name>([<args>]) [const] {};
    const обозначает, что метод обязуется не изменять аргументы <args>.
    -----------------------------
    По умолчанию все функции, объявленные внутри класса - встроенные.
    Если нужно сделать метод класса, объявленный вне класса встроенным, еспользовать inline.
    -----------------------------
    Статические переменные в классе создаются по следующим правилам:
    - Объявление переменной должно иметь кл. слово static и должно находиться в объявлении класса в заголовочном файле (.h), но не должно быть инициализировано значением.
    - Присвоение значения статической перемнной класса должно иметь тип, но не иметь кл. слова static.

    // example.h
    class ExampleClass {
    private:
        static int example_num;          // Не имеет значения, но имеет static
    }

    // example.cpp
    int ExampleClass::example_num = 10;  // Не имеет static, но имеет тип
    -----------------------------
    Создание объекта из класса:
    <class_name> <var_name> = <class_name>(<args>);        // основная форма
    <class_name> <var_name>(<args>);                       // сокращённая форма
    <class_name> *<var_name> = new <class_name>(<args>);   // через укаазтель

    Создание объекта из класса в С++11 с аргументами:
    <class_name> <var_name> = {<args>};                    // 1я форма
    <class_name> <var_name>{<args>};                       // 2я форма
    <class_name> *<var_name> = new <class_name>{<args>};   // через укаазтель
    -----------------------------


    ----------------------------------------------------------------------------------------
    Статические переменные:
    - Статическими переменными считаются переменные, которые объявлены в глобальной области видимости или с ключевым словом static.
    - Хранятся в стеке, существуют на протяжении всего выполнения программы.
    - Если при объявлении статическая переменная не получает значения, то она инициализируется нулевым значением (все биты устанавливаются в 0).
    - Стат. перем. с внешним связыванием создаётся с помощью объявления в глобальнй области видимости.
    - Стат. перем. с внутренним связываение создаётся с помощью объявления с ключевым словом static.
    - Стат. перем. без связывания создаётся с ключевым словом static внутри любого блока, заключённого в {}.
    - Если у переменной со внешним связываем используется модификатор const, то эта меерменная становится константной переменной СО ВНУТРЕННИМ связываением.
    - Ключевое слово static вне блоков управляет связыванием, но внутри блоков оно управляет временем хранения. 

    int global;              // Переменная, статическая, внешнее связывание
    static int one_file;     // Переменная, статическая, внутреннее связывание
    const int с_one_file;    // Константа, статическая, внутреннее связывание

    void func () {
        static int count;    // Переменная, статическая, нет связывания
    }
    ----------------------------------------------------------------------------------------
    Ключевое слово extern и ссылочная инициализация:
    - Ключевое слово extern указывает на то, что переменная является общей для нескольких файлов.
    - Переменная с ключевым словом extern может быть инициализирована значением ТОЛЬКО В 1 файле, а в остальных её можно только объявить.

    int maindecl = 5;    // file1.cpp Главное объвление переменной в одном файле...
    extern int maindecl; // file2.cpp ...ссылочное объявление переменной в другом файле с помощью extern
    ----------------------------------------------------------------------------------------
    Связываение:
    - Внешнее:
    - - Переменные, доступные для нескольких/всех единиц трансляции.
    - Внутреннее:
    - - Переменные, доступные внутри только одной единицы трансляции.
    - Без связывания:
    - - Переменные, доступные только внутри блока кода, заключённого в {}.

    Конструкторы и деструкторы:
    - Конструктор по умолчанию создаётся автоматически, если не определён ни один другой конструктор.
    - Конструктор считается по умолчанию, если все его аргументы имеют значение по умолчанию.
    - Контструктор по умолчанию:
    - - Создаётся автоматически при отсутствии.
    - - Конструктором по умолчанию считается конструктор, который не принимает аргументов или у которого все аргументы имеют значения по умолчанию.
    - Конструктор копирования:
    - - Создаётся автоматически при отсутствии.
    - - Служит для копирования объекта в создаваемый объект.
    - - Применяется так же при передаче аргумента по значению и тогда, когда функция возвращает объект.
    - - По умолчанию почленно копирует значения одного объекта в значения другого по значению.
    - - Имеет прототип: <class_name> (const <class_name> &);
    - - Случаи, когда вызывается конструктор копирования:
        <class_name> first_obj;
        1. <class_name> second_obj(first_obj);
        2. <class_name> second_obj = first_obj;
        3. <class_name> second_obj = <class_name>(first_obj);
        4. <class_name> *p_second_obj = new <class_name>(first_obj);




    -----------------------------------------------

    В C++ переменную лучше объявлять непосредственно перед использованием.

    Присваивание возвращает присваеваемое значение.
    int a, b, c;
    a = b = c = 5;  // a, b и c равны 5

    В именах не стоит использовать __ в начале или _ с первой буквой в верхнем регистре, т. к. такое именование зарезервировано за системными переменными (__var, _Var)

    Целочисленные типы: char, short, int, long, long long

    --------------------

    // макросы
    // числовые типы, строки, перечисления, объединения, структуры, классы
    // указатели
    // функции, лямбда-функции
    // приведение типов, ***_cast
    // потоки и файлы
    // volatile, const
    // inline, override
    // friend
    // auto, typedef, decltype
    // size_t 
</pre>        


<p>При работе с переменной, компьютер отслеживает три её фундаментальных свойства:</p>
<ul>
    <li>Где хранится информация</li>
    <li>Какое значение сохранено</li>
    <li>Разновидность (тип) сохранённой информации</li>
</ul>
<p>В программе могут быть несколько функций с одним и тем же именем, но с разным набором аргументов.</p>

<h3>Константы</h3>
<p>Константы позволяют сделать переменные неизменяемыми.</p>
<p>Константы можно определить двумя способами:</p>
<ul>
    <li>С помощью препроцессорной директивы <code>#define</code>. Это способ в стиле C, но поддерживается в C++. Обычно буквы в имени констант такого типа имеют верхний регистр.</li>
    <li>
        С помощью квалификатора <code>const</code>. Это способ в стиле C++, но поддеживается в ANSI C. Имена таким константам принято задавать подобно обычным переменным. Этот способ лучше препроцессорной директивы по трём причинам:
        <ol>
            <li>Можно явно задать тип константы.</li>
            <li>Можно ограничивать область видимости таких констант.</li>
            <li>Можно использовать для более сложных типов, например, для массивов, структур и тд.</li>
        </ol>
    </li>
</ul>

<h3>Преобразования типов</h3>
<p>Правила преобразования при инициализации и присваивании и возможные проблемы:</p>
<ul>
    <li>При присваивании нулевого значения переменной типа <code>bool</code> будет интерпретировано как <code>false</code>, а ненулевого – как <code>true</code>.</li>
    <li>При присваивании значения переменной одного типа переменной другого типа это значение преобразуется к типу переменной, которая получает значение.</li>
    <li>При присваивании значения переменной целочисленного типа переменной с плавающей точкой может привести к потере точности из-за слишком малого количества значащих цифр переменной с плавающей точкой. <span class="more">(см. таблицу типов с плавающей точкой)</span></li>
    <li>
        При преобразовании большего типа с плавающей точкой в меньший тип с плавающей точкой (например, <code>double</code> &rarr; <code>float</code>) могут произойти следующие проблемы:
        <ul>
            <li>Потеря точности (значащих цифр)</li>
            <li>Исходное значение может превысить диапазон, допустимый для целевого типа, поэтому результат окажется неопределённым</li>
        </ul>
    </li>
    <li>
        При преобразовании типа с плавающей точкой в целочисленный тип могут произойти следующие проблемы:
        <ul>
            <li>Потеря дробной части</li>
            <li>Исходное значение может превысить диапазон целевого типа, поэтому результат будет неопределён</li>
        </ul>                       
    </li>
    <li>
        При преобразовании большего целочисленного типа в меньший целочисленный тип (например, <code>long</code> &rarr; <code>short</code>) могут произойти следующие проблемы:
        <ul>
            <li>Исходное значение может превысить диапазон целевого типа</li>
            <li>Обычно копируются только младшие байты</li>
        </ul>
    </li>
    <li>
        Преобразование при списковой инициализации {} (в C++11) имеет следующие свойства:
        <ul>
            <li>Не допускается сужение</li>
            <li>Преобразования типов с плавающей точкой в целочисленные типы не разрешены</li>
            <li>Преобразование целочисленных типов в другие целочисленные типы и в типы с плавающей точкой разрешены только если компилятор может сообщить, способна ли целевая переменная корректно хранить предоставленное значение.</li>
            <li>Преобразование большего целочисленного типа в меньший целочисленный тип разрешено только если значение вмещается в целевой тип и является константой</li>
        </ul>
    </li>
</ul>

<p>Правила преобразования арифметических типов при выполнении арифметических операций над ними:</p>
<ul>
    <li>Если в арифметической операции участвуют два разных типа, то меньший тип преобразуется в больший</li>
    <li>При делении <strong>целочисленного типа</strong> на <strong>целочисленный тип</strong>, в результате получается целочисленный тип, любая дробная часть отбрасывается.</li>
    <li>
        Контрольный список, используемый для преобразований:
        <ol>
            <li>Если один из операндов имеет тип <code>long double</code>, то другой операнд преобразуется в <code>long double</code></li>
            <li>Иначе, если один из операндов имеет тип <code>double</code>, то другой операнд преобразуется в <code>double</code></li>
            <li>Иначе, если один из операндов имеет тип <code>float</code>, то другой операнд преобразуется в <code>float</code></li>
            <li>Иначе, операнды имеют целочисленный тип, и тогда используется целочисленное расширение, описанное ниже</li>
            <li>В этом случае, если оба операнда имеют знак, или оба операнда беззнаковые, и один из них имеет меньший ранг, чем другой, то они оба преобразуются в больший ранг</li>
            <li>Иначе, один операнд имеет знак, а другой беззнаковый. Если беззнаковый операнд имеет больший ранг, чем операнд со знаком, то последний преобрауется в тип беззнакового операнда</li>
            <li>Иначе, если тип со знаком может представить все значения беззнакового типа, беззнаковый опренд преобразуется к типу операнда со знаком</li>
            <li>Иначе, оба операнда преобразуются в беззнаковую версию операнда со знаком.</li>
        </ol>
    </li>
    <li>
        Целочисленные расширения:
        <ul>
            <li>Всегда, когда в выражениях встречаются типы <code>bool</code>, <code>char</code>, <code>unsigned char</code>, <code>signed char</code> и <code>short</code>, на время выполнения операции они преобразуются в тип <code>int</code>, т. к. этот тип наиболее естественный для компьютера, и операции над ним выполняются максимально быстро.</li>
            <li>Тип <code>unsigned short</code> преобразуется в <code>int</code>, если тип <code>short</code> короче, чем <code>int</code></li>
            <li>Если <code>short</code> и <code>int</code> имеют одинаковую ширину, то <code>unsigned short</code> преобразуется в <code>unsigned int</code></li>
            <li>Тип <code>wchar_t</code> расширяется в один из следующих типов, способный уместить значение: <code>int</code>, <code>unsigned int</code>, <code>long</code> или <code>unsigned long</code></li>
        </ul>
    </li>
</ul>

<!-- ===================================== -->

<h2>CLion</h2>
<p><kbd>Ctrl + Q</kbd> – показать тип переменной.</p>