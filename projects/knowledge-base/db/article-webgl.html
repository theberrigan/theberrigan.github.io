<h1>WebGL</h1>

http://learnwebgl.brown37.net

-----------------------------------

Препроцессинг:
1. Выбрать canvas
2. Получить контекст canvas'а
3. Set the desired state for the gl context.
4. Скомпилировать и связать в одну программу vertex-шейдер и fragment-шейдер.
5. Получить ссылки на переменные из шейдерной программы, чтобы можно было изменять их значения во время рендера.
6. Для каждой модели:
   - Сконвертировать obj-файл в специальные массивы данных для рендера
   - Создать buffer object в памяти GPU
   - Скопировать данные модели в этот buffer object

Результат рендеринга - 2D-массив пикселей. размер массива зависи от того, сколько места на экране занимает модель.
У каждого пикселя есть своя дополнительная информация. Пиксель вместе с этой информацией называется fragment.

Два типа программируемых шейдеров:
- Vertex-шейдер - устанавливает правильное положение в пространстве для каждой вершины в сцене.
- Fragment-шейдер - устанавливает цвет каждого пикселя.

Vertex-шейдер может устанавливать переменные, которые затем сможет использовать fragment-шейдер.

Для хранения переменных в шейдерах используются 3 типа хранилищ (Storage Qualifiers):
- uniform - переменная, значение которой не изменяется на протяжении всего вызова gl.drawArrays()
- attribute - переменная, которая принимает разное значение для каждой вершины.
- varying - переменная, которая принимает разное значение для каждого фрагмента.

Для того, чтобы отрендерить новый кадр, JS должен выполнить следующие шаги:
1. Очистить буфер от предыдущего кадра.
2. Очистить depth buffer, если используется удаление невидимых в сцене поверхностей.
3. Выбрать шейдерную программу.
4. Для каждой модели в сцене:
   - отправить значение uniform-переменных в шейдерную программу
   - Прикрепить каждую attribute-переменную к соответствующему buffer object
   - Вызвать gl.drawArrays()

Эти действия вызывают переключение контектса (это плохо, нужно сокращать количество CS):
- Выбор шейдерной программы
- Установка uniform-переменных в шейдерную программу
- Установка attribute-переменных в шейдерную программу
- Любой действие, которое изменяет состояние JS-объекта gl

Для оптимизации:
- В идеальном случае model data загружается в память GPU один раз
- Нужно сокращать количество переключений контекста
- Снижать количество рендерируемых вершин
- Сокращать количество JS-вызовов

buffer object - просто кусок последовательной памяти, который можно использовать для хранения разной информации. 
В одном таком объекте можно хранить одну или несколько моделей.
(вроде как) Если размер каких-то данных для рендера изменяется от кадра к кадру, то каждый раз нужно выделять 
новый object buffer для этих данных.

Шейдерная программа за один раз работает на одной vertex и на одном fragment.
Перед тем, как использовать шейдер, нужно загрузить данные модели в vertex object buffer.
В идеальном случае model data загружается в память vertex object buffer один раз.
Vertex object buffer может содержать массив attribute-переменных для вершин.
Если в один VOB (VBO) не помещаются все вершины модели, то можно создать несколько VOB.
Отрисовать вершины с 5 по 14 (10 штук): gl.drawArrays(mode, 5, 10)

Vertex-шейдер будет выполнять одни и те же рассчёты для каждой вершины.
Задача VS - рассчитать и присовить значение переменной gl_Position (положение вершины).
Задача FS - рассчитать и присовить значение переменной gl_FragColor (цвет пикселя).

Все вершины модели поступают в Vertex Shader (VS) ->
VS запускается для каждой вершины по отдельности и правильно располагает её в сцене, устанавливая переменную gl_Position ->
отпозиционированные вершины отправляются на стадиию Viewport Transformation ->
далее данные отправляются в Rasterizer, на выходе получается массив пикселей ->
Fragment Shader запускается для каждого пикселя по отдельности и назначает ему цвет, устанавливая переменную gl_FragColor ->
Compositing - совмещение всех пикселей в конечное изображение модели

------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------

https://webglfundamentals.org/
https://webgl2fundamentals.org/
https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html
Лучшие практики: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
https://webglfundamentals.org/webgl/lessons/ru/webgl-resizing-the-canvas.html
https://www.programmersought.com/article/74894584653/
https://www.programmersought.com/article/35796017564/
https://blog.scottlogic.com/2019/11/18/drawing-lines-with-webgl.html

- Математика
- Rust
- ОС
- Алгоритмы
- Графика
- Интерпретаторы (для мета-языка шейдеров)

Math:                     |
- Transformation Matrices |    | Bezier Curves |    | Fonts
- Quaternions             | -> | Splines       | -> | (stb_truetype, FreeType, Slug/Sluggish)
- Vectors                 |

- Леворукая система координат: x - вправо, y - вверх, z - вперёд (вращение по часовой)
  Праворукая система координат: x - вправо, y - вверх, z - назад (вращение против часовой) (более традиционная)
  WebGL:   x - вправо, y - вверх, z - назад ???
  OpenGL:  x - вправо, y - вверх, z - вперёд
  Vulkan:  x - вправо, y - вниз,  z - вперёд
  DirectX: x - вправо, y - вверх, z - вперёд
  TODO: Вращение
- Обычно принято использовать полигоны против часовой стрелки. Нужно сохранять однородность в этом.
- Positional light:
  - Лучи исходят в разном направлении
  - Есть затухание света
  - Нужен вектор Light Direction и вектор Light Position
- Directional light:
  - Лучи параллельны
  - Нет затухания
  - Источник света бесконечно далёк
  - Вычисляется проще, чем positional
  - Нужен только Light Direction вектор
- Нормали отражают ориентацию полигона
- Если у одной вершины полигона образуются несколько нормалей из-за принадлежности этой вершины к нескольким полигонам,
  то эти нормали нужно сложить, чтобы получить одну правильную
- VS вызывается параллельно для каждого набора данных для attribute-переменных из VAO/VBO/IBO
- Shading-модели:
  - Goraud - вычислить нормали в хост-коде или в VS, а цвет интерполировать через varying-переменную
  - Phong - Вычислить нормали в хост-коде или в VS, интерполировать их через varying-переменную, в FS вычислить цвет
  - Goraud быстрее, но менее точно, чем Phong
- Lighting-модели:
  - Lambert (ambient = 0; diffuse = <calc>; specular = 0)
  - Phong (ambient = <calc>; diffuse = <calc>; specular = <calc>)
- Типы освещения:
  - Ambient - подсветка объектов независимо от источников света
  - Diffuse - отражение луча от поверхности во все стороны (основное освещение, используется в ламбертовской модели)
  - Specular - отражение только в сторону камеры (блик)
- A - вектор; B - вектор; θ - угол между векторами A и B, когда они соединены концами
  Скалярное произведение (dot product):
  - Первый вариант: A • B = |A||B| * cos(θ) (если A и B нормализованы, то просто cos(θ))
  - Второй вариант: A • B = Ax * Bx + Ay * By + Az * Bz + ...
  Если СП == 0, то векторы перпендикулярны, а если СП == 1, то коллинеарны (если векторы нормализованы)
  Если A - юнит-вектор, то A • B - проекция вектора B на прямую, параллельную вектору А.
- Diffuse (Lambert) = (vNorm • -vLightDir) * vMatColor * vLightColor
- Specular = ((vReflect • vCamera) ^ shininess) * vMatColor * vLightColor
- vA x vB = vC; Векторное произведение (cross product) двух векторов даёт третий перпендикулярный им вектор
- Координата W в векторе - это Homogeneous-координата. Она позволяет выполнять affine и projective преобразования.
  Vec3 - евклидово пространство; Vec3 + W = Vec4 - перспективное пространство.
  Дана система линейных уравнений, каждое из которых представляет линию, параллельную остальным.
  У такой системы нет решения в евклидовом пространстве из-за параллельности линий.
  В перспективном пространстве у такой системы решение есть.
  (x, y, z, w) = (x/w, y/w, z/w, w/w) - перевод из homogeneous в non-homogeneous (евклидовы) координаты.
  Homogeneous (perspective) space to non-homogeneous (euclidean) space: h(x, y, z, w) = v(x/w, y/w, z/w, w/w)
  Non-homogeneous (euclidean) space to homogeneous (perspective) space: v(x, y, z) = h(x, y, z, 1)
  https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/
- Camera Frustum закодирована в Projection Matrix.
  Если задний (near plane) и передний (far plane) план равны, то это ортографическая проекция.
  Если задний (near plane) план больше переднего, то это перспективная проекция.
- Near Plane - это плоскость, на которую будет спроецировано конечное изображение.


Векторы и направления:
- Вектор нормали перпендикулярен фрагменту.
- Eye-вектор начинается из фрагмента, его конец указывает на положение камеры, которая в свою очередь направлена в
  сторону данного фрагмента, то есть в противоположном этому вектору направлении.
- Light-вектор направлен из источника света к началу вектора нормали.
- Reflection-вектор начинается из начала нормали и расположен под тем же углом к ней, что и light-вектор

- В каком порядке что вызывать
- Модели, кости, иерархия
- Граф сцены
- Камера
- Анимация, таймлайны
- Ввод
- Шрифты
- Рей-трейсинг
- Разные GFX (article-gamedev.html)
- PBR
- Математика: кватернионы
- Физика
- Посмотреть, как работать с шейдерами в других движках
- Состав модели, анимации, граф сцены, кватернионы, таймлайны

          ^1  /
          |  /
          | /
-1        |/        1
----------/---------->
         /|
        / |
     1|/_ |-1


Clip space coordinates - координаты от -1 до 1, с которым работает VS
Какую бы систему координат мы не использовали, на выход VS мы должны подавать координаты в Clip space.
В 2D скорее легче работать в пикселях, чем в любых других системах координат.
Если переводить из screen space в clip space, то получится, что начало координат в screen space (0, 0)
соответствует (-1, -1) в clip space - это левый нижний угол. Получается, что картинка перевёрнута вертикально.
Поэтому нужно переворачивать её обратно самому в VS во время конвертации из screen space в clip space.
В 2D API (0, 0) обычно находится в левом верхнем углу.

buffer - sequential access; массив любых бинарных данных, передаваемых из JS в VS
VBO - buffer, в который можно положить любые данные
VAO - buffer, в который нужно положить информацию о том, как WebGL должен итерироваться по данным в VBO.

attribute - переменная в VS, которая получает данные из VBO и интерпретирует данные в соответствии с VAO
uniform - глобальная переменная, которая сохраняет своё значение при каждой итерации VS и FS; можно определять в VS и FS
---
Uniform values stay the same for all vertices of a single draw call.

Сначала данные для рендеринга нужно положит в VBO. Но VBO - это просто последовательность байтов, поэтому WebGL не знает
как их скармливать шейдеру. Нужно создать VAO, в нём нужно определит атрибуты, которые описывают как, в каком количестве
брать данные из соответствующего ему VBO и в какую переменную-атрибут шейдера эти данные передавать.
В VAO нужно включать атрибуты, прежде чем их использовать, иначе в шейдере эти атрибуты получат константное (?) значение.
Во время вызова gl.vertexAttribPointer() с этой функцией неявно связан текущий gl.bindBuffer(gl.ARRAY_BUFFER).

We process vertices in parallel; therefore, each copy/thread of the vertex shader processes a different vertex.

Рисование запускается с помощью gl.drawArrays(M, 0, N). Внутри этого вызова VS запускается N раз (делает N итераций).
С каждой новой итерацией каждый атрибут VS принимает следующее значение из соответствующего ему VBO в соответствии с VAO.
После обработки очередного достаточного количества вершин формируется фигура M. Например, если M == TRIANGLES, то
каждые 3 обработанные вершины формируют треугольник.
После окончания работы VS для каждого фрагмента (пикселя) запускается FS. Для каждого запуска FS, значения
varying-переменных изменяются за счёт интерполяции.

Текстурные юниты - это физические слоты для текстур на видеокарте. Сначала из JS кода нужно положить текстуру
в подходящий юнит. Затем в uniform-sampler-переменную нужно положить индекс текстурного юнита, из которого семплер
достанет эту текстуру.

Фреймбуферы - это слоты для разных текстур-аттачментов. Не все сочетания текстурных форматов и аттачментов ФБ
совместимы. Но есть определённый набор комбинаций, которые должны работать всегда.
Например, RGBA/UNSIGNED_BYTE + COLOR_ATTACHMENT0. Проверить совместимость можно с помощью gl.checkFramebufferStatus().
Чтобы рендерить в ФБ, нужно установить его с помощью gl.bindFramebuffer(fb) и выбрать разрешение с помощью gl.viewport().
Чтобы снова рендерить на канвас, нужно разбиндить ФБ с gl.bindFramebuffer(null) и вернуть разрешение канваса с gl.viewport().


gl.viewport() используется на этапе растеризации, чтобы WebGL мог понять, сколько фрагментов генерировать.
gl.viewport() used for clip space to screen space conversion

gl.createBuffer() -> gl.deleteBuffer()

Порядок вызовов:

gl.useProgram()
gl.uniformX() - после gl.useProgram()

- Прозрачность: https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html#drawing-transparent-things-and-multiple-lists
- https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html
- https://webgl2fundamentals.org/webgl/lessons/webgl-boilerplate.html
- https://webgl2fundamentals.org/webgl/lessons/webgl-less-code-more-fun.html
- https://webgl2fundamentals.org/webgl/lessons/webgl-instanced-drawing.html
- Правильно не делать избыточных вызовов к WebGL. Например, если в данный момент уже используется нужная шейдерная
  программа, то не надо вызывать gl.useProgram() ещё раз.
- Учесть прозрачность, несколько текстур + разные мапы

- Шейдеры, написанные вручную, обычно, узкоспециализированы, поэтому требуют на вход конкретный набор данных.
  Поэтому, лучше сначала задавать объекты - что и как мы хотим нарисовать, а затем на основе требований генерировать
  подходящие шейдеры. Так делают UE, Source, Unity...
- Матрицы трансформации лучше генерировать не во время рисования, а в графе сцены


- B. Nystrom - Game Programming Patterns
- J. Gregory - Game Engine Architecture (3rd Edition, 2018).pdf
- M. McShaffry - Game Coding Complete (4th Edition, 2013)


- Граф сцены
- Модели, мэши, скелеты
- Анимации

- Шейдинг определяет, ГДЕ будет вычисляться конечный цвет фрагмента – в VS (Goraud) или в FS (Phong)
- Лайтинг определяет конечный цвет фрагмента.
  Lambertian – самая распространённая модель вычисления diffuse-света (свет, отражающийся во всех направлениях).
  Specular-свет, в отличие от diffuse, отражается только в одном направлении.
  Phong-модель освещения: ambient + diffuse (обычно ламбертовский) + specular

------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------

#version 300 es

precision highp int;
precision highp float;

---

Системы координат:
- Леворукая система координат:  +X →, +Y ↑, +Z ↗
  Праворукая система координат: +X →, +Y ↑, +Z ↙
- WebGL работает в праворукой системе координат за исключением NDC - там она леворукая.
- Обычные неоднородные координаты вершины содержат 3 компонента в Euclidian Space.
  В этом пространстве система линейных уравнений не имеет решения, потому что нет точек пересечения параллельных линий.
  Homogenous coordinate - это координаты вершины, которые содержат 4ый компонент w, что переносит нас в Projective Space.
  А в этом пространстве параллельные прямые пересекаются в точке схода, что отражено в координатах компонентом w == 0.
  Чтобы перевести из HC в ES, нужно разделить все компоненты на w и убрать w из координаты.
  h(x, y, z, w) == e(x / w, y / w, z / w)
  h(x, y, z, 1) == e(x, y, z) 
  ! В HC координаты имеют w == 1, но векторы (например, вектор нормали) имеют w == 0.
- Model/Object/Local Space (HC) - система координат вершин объекта, [-1, -1, -1] - [1, 1, 1].
  В этом пространстве каждая модель имеет право сама задавать начало координат для своих вершин и размещать их как угодно относительно начала.
  Чтобы трансформировать объект в этом пространстве, нужно умножить на Model-матрицу.
  ObjectSpace * ModelMatrix - в результате мы перешли из object space в world space, т.е. вершины получили новые координаты в world space.
- Global/World Space (HC) - система координат, которая является общей для всех моделей, то есть позволяет определять положение каждой модели в мире относительно друг друга.
- View/Eye/Camera Space (HC) - система координат, которая определяет положение всех моделей относительно камеры/глаза.
  Чтобы перейти из world space во view space, нужно умножить world-координаты на View-матрицу. 
- Clip Space - система координат, в которой происходит clipping и perspective division.
  Чтобы перейти из view space в clip space, нужно умножить view-координаты на Projection-матрицу.
  1. Выполняется clipping - в каждой координате сравниваются компоненты x, y, z с компонентом w, и если x, y или z
     больше +w или меньше -w, то вершина с этой координатой лежит за пределами frustum и поэтому отбрасывается.
  2. Выполняется perspective division - каждый компонент координаты делится на w, а сама w отбрасывается, то есть происходит
     переход из HC в Euclidian Space. Теперь x и y отвечают за положение вершины на экране, а z - за глубину этой вершины.
     Perspective division - это переход в Normalized Device Coordinates (NDC), в ней пространство представляет собой куб
     с координатами [-1, -1, -1] - [1, 1, 1]. Также на этом этапе ось z МЕНЯЕТ ОРИЕНТАЦИЮ на противоположную: near -> far.
  3. Полученные координаты готовы, чтобы записывать их в gl_Position в VS.
- Screen/Pixel/Veiwport Space - система координат вьюпорта [0, 0] - [viewport.width, viewport.height].
  Начало координат находится в нижнем левом углу.
  Для перевода из NDC в screen space используется не матрица, а функция gl.viewport().
- Frustum - усечённая пирамида, которая определяет пространство, за пределами которого все полигоны будут отсечены (не будут отрисоваться).
  Frustum состоит из 6 плоскостей, две из которых - это дальний (near) план и ближний (far) план.
  Ближний план - это по сути плоскость экрана, на которую будет спроецировано изображение.
  В projection-матрице закодированы все 6 плоскостей frustum'а.
  От формы и длины frustum'а зависит как геометрия внутри него будет спроецирована на экран:
  - Если ближний и дальный планы равны по размеру, то frustum будет прямоугольным параллелепипедом, а такая проекция называется ортогональной.
  - Если дальний план больше ближнего, то frustum будет усечённой пирамидой, а такая проекция называется перспективной.
- Не забывать пересчитывать нормали после трансформации вершин [WGLBG, 113]

=== ↓ Homogeneous Coordinates, RH Z↗, Frustum ↓ ===
Model Space * Model Matrix ->
World Space * View Matrix ->
Camera Space * Projection Matrix ->
Clip Space ->
    Clipping (Frustum Culling) ->
    Perspective Division (divide by W) ->
=== ↓ Euclidian Coordinates, LH Z↙, Cube (x = y = z = [-1, 1]) ↓ ===
Normalized Device Coordinates (NDC) (z - depth)

Типы шейдеров:
- VS запускается один раз для каждой вершины из VAO.
- FS запускается один раз для каждого фрагмента.


Буферы:
- VBO - основной буфер, который просто хранит последовательность любых байт.
- VAO - буфер мета-информации о данных в VBO - как их брать из VBO, как интерпетировать и как скармливать атрибутам VS.
- EBO/IBO - буфер, содержащий индексы, которые указывают, в каком порядке рисовать вершины. 
- FBO (framebuffer) - набор аттачментов, в которые рендерится изображение.

* normalizeFlag используется в vertexAttribPointer для конвертации в более экономные типы данных.


Функции рисования используются для записи во framebuffer:
- drawArrays - рисует вершины в том порядке, в котором они определены в VBO. 
  Можно использовать, когда информация об индексах недоступна.
- drawElements - рисует вершины в соответствии с индексами EBO.
  В случае с drawArrays, расшаренные между полигонами вершины должны быть
  продублированы, а это требует много памяти. Чтобы этого избежать в случае
  со сложной геометрией, лучше использовать индексы и drawElements.
  Перед вызовом drawElements нужно удостовериться, что соответствующий EBO забинжен.


Способы передачи данных в шейдер:
- Attribute - переменная, доступная только в VS. Данные извлекаются из буферов (VBO, VAO, ...)
  // Создать буфер и положить в него данные 
  var buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);
  // Получить локацию атрибута в шейдере и указать ему, как он должен получать данные из буферов выше
  var positionLoc = gl.getAttribLocation(someShaderProgram, "a_position");
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, numComponents, type, false, stride, offset);
- Varying - переменная, передаваемая из VS (out) в FS (in). Данные устанавливаются в VS, не может быть установлена за пределами шейдеров.
  VS вызывается для каждой вершины, устанавливают out-переменную, затем для каждого фрагмента вызывается FS с интерполированным значением in-переменной.
- Uniform - переменная, значение которой устанавливается извне, и остаётся неизменным для всего draw call'а. Данные устанавливаются напрямую.
  var offsetLoc = gl.getUniformLocation(someProgram, "u_offset");
  gl.uniform4fv(offsetLoc, [1, 0, 0, 0]); 
- Texture - переменная, доступная в FS, типа sampler2D.

* В WebGL "in" в VS означает атрибут-переменную, а в FS - varying-пеерменную.


Framebuffer - это список аттачментов. Можно прикрепить аттачмент к FBO и рендерить в неё.
Если установить какой-то FBO активным, то рендеринг будет происходить в аттачмент этого FBO, а не на канвас.


Математика:
- Можно перемножить матрицы сдвига, вращения и масштабирования и получить общую матрицу трансформации.
- Identity-матрица, это матрица, где единицы на главной диагонали. Подходит в качестве стартовой матрицы в цепи умножений.


Вершины frontface-полигона идут против часовой стрелки, а вершины backface-полигона – по часовой.
Culling - это отсечение (нерисование) чего-то. По умолчанию WebGL рисует и frontface, и backface.
Чтобы отменить рисование backface, необходимо включить culling: gl.enable(gl.CULL_FACE)

Depth-буфер (z-буфер) - это буфер, соотвествующий color-буферу, и содержащий информацию о глубине пикселя.
В clip space имеет координаты от -1 до 1, но затем переводится в depth space с координатами от 0 до 1.
Depth-буфер используется для определения порядка цветовых пикселей по глубине. 
По умолчанию эта функция отключена. Чтобы её включить: gl.enable(gl.DEPTH_TEST).
Перед рисованием нового кадра, depth-буфер нужно сбросить: gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

translation * rotation * scale


------------------------------------------------------------------------------------------------------------------------------

- Матрицы: https://webgl2fundamentals.org/webgl/lessons/webgl-2d-matrices.html
- Матрицы: http://www.songho.ca/opengl/gl_projectionmatrix.html
- FBOs: https://webgl2fundamentals.org/webgl/lessons/webgl-image-processing-continued.html
- Рисование линий: https://blog.scottlogic.com/2019/11/18/drawing-lines-with-webgl.html
- Рисование кривых: https://www.programmersought.com/article/74894584653/

+ Spaces, NDC, и матрицы
- Когда происходит polygon culling
- FBO, аттачменты и текстуры
- Арифметика матриц и векторов
- VBO, VAO, EBO, IBO, FBO
- 1 / resolution
- gl.drawArrays or gl.drawElements
- Прозрачность (blending)
- Порядок рендеринга сцены
- Когда данные загружаются из буферов в GPU и можно освобождать буферы
- STATIC_DRAW / DYNAMIC_DRAW / STREAM_DRAW

WebGL Beginner's Guide:
- Прозрачность (blending)
- Пикинг курсором, и перемещение объекта
- Перемещение камеры
- Кьюбмэп с отражениями
- Face Culling
- Анимации, интерполяция, frame dropping
- Toon Shader

Pixel Perfect Fingerprinting Canvas in HTML5:
- WebFont rendering

------------------------------------------------------------------------------------------------------------------------------