<h1>WebGL</h1>
<pre>
    http://learnwebgl.brown37.net

    -----------------------------------

    Препроцессинг:
    1. Выбрать canvas
    2. Получить контекст canvas'а
    3. Set the desired state for the gl context.
    4. Скомпилировать и связать в одну программу vertex-шейдер и fragment-шейдер.
    5. Получить ссылки на переменные из шейдерной программы, чтобы можно было изменять их значения во время рендера.
    6. Для каждой модели:
       - Сконвертировать obj-файл в специальные массивы данных для рендера
       - Создать buffer object в памяти GPU
       - Скопировать данные модели в этот buffer object

    Результат рендеринга - 2D-массив пикселей. размер массива зависи от того, сколько места на экране занимает модель.
    У каждого пикселя есть своя дополнительная информация. Пиксель вместе с этой информацией называется fragment.

    Два типа программируемых шейдеров:
    - Vertex-шейдер - устанавливает правильное положение в пространстве для каждой вершины в сцене.
    - Fragment-шейдер - устанавливает цвет каждого пикселя.

    Vertex-шейдер может устанавливать переменные, которые затем сможет использовать fragment-шейдер.

    Для хранения переменных в шейдерах используются 3 типа хранилищ (Storage Qualifiers):
    - uniform - переменная, значение которой не изменяется на протяжении всего вызова gl.drawArrays()
    - attribute - переменная, которая принимает разное значение для каждой вершины.
    - varying - переменная, которая принимает разное значение для каждого фрагмента.

    Для того, чтобы отрендерить новый кадр, JS должен выполнить следующие шаги:
    1. Очистить буфер от предыдущего кадра.
    2. Очистить depth buffer, если используется удаление невидимых в сцене поверхностей.
    3. Выбрать шейдерную программу.
    4. Для каждой модели в сцене:
       - отправить значение uniform-переменных в шейдерную программу
       - Прикрепить каждую attribute-переменную к соответствующему buffer object
       - Вызвать gl.drawArrays()

    Эти действия вызывают переключение контектса (это плохо, нужно сокращать количество CS):
    - Выбор шейдерной программы
    - Установка uniform-переменных в шейдерную программу
    - Установка attribute-переменных в шейдерную программу
    - Любой действие, которое изменяет состояние JS-объекта gl

    Для оптимизации:
    - В идеальном случае model data загружается в память GPU один раз
    - Нужно сокращать количество переключений контекста
    - Снижать количество рендерируемых вершин
    - Сокращать количество JS-вызовов

    buffer object - просто кусок последовательной памяти, который можно использовать для хранения разной информации. 
    В одном таком объекте можно хранить одну или несколько моделей.
    (вроде как) Если размер каких-то данных для рендера изменяется от кадра к кадру, то каждый раз нужно выделять 
    новый object buffer для этих данных.

    Шейдерная программа за один раз работает на одной vertex и на одном fragment.
    Перед тем, как использовать шейдер, нужно загрузить данные модели в vertex object buffer.
    В идеальном случае model data загружается в память vertex object buffer один раз.
    Vertex object buffer может содержать массив attribute-переменных для вершин.
    Если в один VOB (VBO) не помещаются все вершины модели, то можно создать несколько VOB.
    Отрисовать вершины с 5 по 14 (10 штук): gl.drawArrays(mode, 5, 10)

    Vertex-шейдер будет выполнять одни и те же рассчёты для каждой вершины.
    Задача VS - рассчитать и присовить значение переменной gl_Position (положение вершины).
    Задача FS - рассчитать и присовить значение переменной gl_FragColor (цвет пикселя).

    Все вершины модели поступают в Vertex Shader (VS) ->
    VS запускается для каждой вершины по отдельности и правильно располагает её в сцене, устанавливая переменную gl_Position ->
    отпозиционированные вершины отправляются на стадиию Viewport Transformation ->
    далее данные отправляются в Rasterizer, на выходе получается массив пикселей ->
    Fragment Shader запускается для каждого пикселя по отдельности и назначает ему цвет, устанавливая переменную gl_FragColor ->
    Compositing - совмещение всех пикселей в конечное изображение модели
</pre>
