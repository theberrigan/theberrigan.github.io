<h1>Хакинг и дизассемблирование</h1>
<h2>Источники</h2>
<ul>
    <li>Закладки: IT -> Защита и взлом</li>
    <li>Крис Касперски. "Фундаментальные основы хакерства" (Солон-Р, 2005)</li>
    <li>Крис Касперски. "Техника отладки приложений без исходных кодов" (БХВ-Петербург, 2005)</li>
    <li>Крис Касперски. "Техника и философия хакерских атак"</li>
    <li>Крис Касперски. "Техника защиты компакт-дисков от копирования" (коды Рида-Соломона)</li>
    <li>Крис Касперски. "Образ мышления IDA"</li>
    <li>Крис Касперски. "Записки мыщъх'а"</li>
    <li></li>
</ul>
<h2>Инструменты</h2>
<p>
    <strong>SoftICE</strong> - самый популярный и лучший отладчик, который не поддерживается с 2009 года.<br>
    <strong>IceExt</strong> - скрывает от исследуемой программы наличие отладчика.<br>
    <strong>OllyDbg</strong> - бесплатный отладчик с кучей плагинов.<br>
    <strong>IdaPRO</strong> - единственный профессиональный дизассемблер.<br>
    <strong>HxD</strong> - Hex-редактор.<br>
    <strong>Process Monitor</strong> - отслеживает, к каким файлам и ключам реестра обращается программа.<br>
    <strong>fc.exe</strong> - встроенная утилита, которая показывает различия файлов по байтам.<br>
    <strong>Process Patcher</strong> - позволяет патчить программу после запуска (в памяти).<br>
    <strong>TCPView</strong> - утилита для отслеживания сетевой активности процессов.<br>
    <strong>IDA Pro</strong> - интерактивный дизассемблер<br>
    <strong>x32dbg</strong> и <strong>x64dbg</strong> - мощный бесплатный отладчик<br>
    <strong>TrialFreezer</strong> - утилита, которая перехватывает системные вызовы GetLocalTime и передаёт прикладной программе поддельные данные.<br>
    <strong>Advanced Registry Tracer</strong> - создаёт дамп реестра.<br>
    <strong>Filemon.exe</strong> - тречит обращения к файловой системе.<br>
    <strong>Regmon.exe</strong> - тречит обращения к реестру.<br>
    <strong></strong> - .<br>
    <strong></strong> - .<br>
</p>

<h2>Способы защиты</h2>
<ul>
    <li>Защита, основанная на знании – человек <strong>знает</strong> код, поэтому может его сказать.</li>
    <li>Защита, основанная на владении (аппаратным ключом) – человек <strong>не знает</strong>, какие именно характеристики ключа использует программа.</li>
</ul>

<h2>Способы противодействия защите</h2>
<ul>
    <li>Защиту можно эмулировать</li>
    <li>Защиту можно дублировать</li>
    <li>Защиту можно нейтрализовать</li>
</ul>

<h2>Способы проверки подлинности ПО</h2>
<ul>
    <li>Проверка ключа по сети</li>
    <li>Проверка исполняемого файла программы самой программой (контрольная сумма)</li>
    <li>Упаковка (UPX)</li>
    <li>* Защита, как у UniLink (статья Криса Касперски)</li>
    <li>Проверка, не запущен ли дизассемблер или отладчик</li>
    <li>Защита серийным номером (s/n) не препятствует несанкционированному копированию, но если все серийные номера различны, то можно вычислить пользователя, выложившего свой серийный номер в сеть.</li>
    <li>Можно где-нибудь в ОС у системной директории оставить timestamp даты изменения.</li>
    <li>Написать проверялку защиты на своём собственном языке, скомпилировать в байткод, а при запуске интерпретировать.</li>
    <li>В демоверсиях физически вырезать код платных функций.</li>
    <li>В разное время проверять разные части серийного ключа или чего-то ещё.</li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
</ul>

<h2>Типы защитных мезанизмов</h2>
<ul>
    <li><strong>Криптозащиты</strong>, или <strong>защиты Кирхгофа</strong> - стойкость криптозащит определяется исключительно стойкостью секретного ключа. Даже если алгоритм работы такой защиты становится известен,
это не намного упрощает его взлом.</li>
    <li><strong>Логические защиты</strong> - определяются определяется степенью секретности защитного алгоритма.</li>
</ul>

<h2>Законы</h2>
<ul>
    <li>Уровень защищённости всей системы определяется уровнем защищённости самого слабого компонента.</li>
    <li>Защитный механизм должен быть глубоко интегрирован в программу, тесно переплетен с ней.</li>
    <li>Процедура проверки серийного номера/ключа ни в коем случае не должна быть запутанной или чрезмерно сложной, иначе она будет существенно отличаться от всех остальных (обычных) процедур, и опытный хакер распознает ее простым "визуальным" просмотром дизассемблерного листинга программы.</li>
    <li>Несимметричную криптографию можно и нужно использовать только с тщательно проработанным механизмом контроля собственной целостности, с множеством проверок в разных
точках программы.</li>
    <li>Там, где есть CRC32, всегда присутствует и константа 0xEDB88320 (стандартный полином).</li>
    <li>Почти все криптоалгоритмы используют магические константы</li>
    <li>"Искусство дизассемблирования" стр. 101-103</li>
    <li></li>
</ul>
<h2>Дизассемблирование</h2>
<ul>
    <li>C: Очистка стека обычно выполняется командой ADD ESP,xxx, где xxx — количество удаляемых байт.</li>
    <li>C: Оптимизирующие компиляторы могут использовать более хитрый код — для очистки стека от нескольких аргументов они частенько их "выталкивают" в неиспользуемые регистры командой POP или и вовсе очищают стек не сразу же после выхода из функции, а там, где это удобнее компилятору.</li>
    <li>Pascal: Удаление аргументов из функции поручено самой функции и обычно осуществляется командой RET xxx — т. е. возврат из подпрограммы со снятием xxx байт со стека.</li>
    <li>Возвращаемое функцией значение в обоих соглашениях передается через регистр EAX (или через регистровую пару EDX:EAX — при возвращении 64-разрядных переменных).</li>
    <li></li>
    <li></li>
    <li></li>
</ul>